--
-- PostgreSQL database dump
--

-- Dumped from database version 12.5 (Debian 12.5-1.pgdg100+1)
-- Dumped by pg_dump version 14.9 (Ubuntu 14.9-0ubuntu0.22.04.1)

-- Started on 2023-11-07 14:57:52 CET

SET statement_timeout = 0;
SET lock_timeout = 0;
SET idle_in_transaction_session_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SELECT pg_catalog.set_config('search_path', '', false);
SET check_function_bodies = false;
SET xmloption = content;
SET client_min_messages = warning;
SET row_security = off;

--
-- TOC entry 3339 (class 0 OID 16528)
-- Dependencies: 235
-- Data for Name: knowledge_artifact; Type: TABLE DATA; Schema: public; Owner: planqk
--

INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('f05c9136-2f9f-433f-9c35-85009111ee3c', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('87d697a4-6256-4f84-b545-c2024ab380c2', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('3aac6a37-10de-4a95-a2bd-381d357df2a4', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('ae6bdf6f-2656-45bd-9b96-0820eea3cdab', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('9829e814-a707-479f-80c7-8b49ffa543bc', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('52ae7837-58e1-47b2-bda3-4134597ef138', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('2229a430-fe92-4411-9d72-d10dd1d8da14', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('45d09c54-3f4a-453b-885d-2772443c8d72', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('4074490a-4236-49ed-83d1-625ce58e2dbd', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('e595558d-bfea-4b82-9f47-a38a2097b245', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('312bc9d3-26c0-40ae-b90b-56effd136c0d', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('4437fb83-34c0-47a8-8c6f-1272a76b76bb', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('d4f7c247-e2bb-4301-ad06-f758fa58f2dc', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('bcd4c7a1-3c92-4f8c-a530-72b8b95d3750', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('3d1f3991-df47-4d42-8f9a-e6dcf4e3ccec', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('1a5e3708-da39-4356-ab3f-115264da6390', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('b6788c99-24f5-496b-a30c-fc0dd7bb3e96', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('5479acf4-0588-49af-a6a9-4956b7ee32af', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('ed3af509-904e-4732-8113-215d65a7d53d', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('8fcca2dc-fca0-47cf-9bd4-038cd2fe8fb8', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('3f3fabf0-7fa7-4b43-a74a-46a7ac2c55ee', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('c450e0ce-c55f-4b72-afe9-e9e2c7e4c091', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('b657ea73-63c0-4800-a69d-a91925e19ac6', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('96b4d28a-a5ce-4c96-85df-d42587b13c57', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('502147ec-45fa-403f-8f52-e196b3359399', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('1cc7e9d6-ab37-412e-8afa-604a25de296e', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('3f3d5582-1af9-4a23-93f5-5d0474b2b42c', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('c6560c51-d2e3-4595-b9c3-b609c75c0b82', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('1c95912a-128b-44e7-b2d4-930f7ba11060', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('9af072e8-875b-4e7d-980a-98cc6e0e7fd6', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('70adfd6f-0648-47cf-88ff-0212b882a262', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('da93f915-7f4c-49df-99d0-80d91f26a337', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('482714a7-8409-4165-93fe-72b02c2ae99c', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('aa90de15-b7e3-45a7-bb48-f0a5b8b2c479', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('dd15032b-ce2b-40b6-80ac-97623255b531', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('424c803a-aefb-4b54-8e45-d177fedac893', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('d5cda8c9-f39b-474a-9032-c17131884975', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('a4ea9f6c-5b0a-4beb-a056-8b261d96ba80', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('d9c57511-1101-4707-99bf-36f43a12cb13', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('ddd64fb6-b324-45eb-8e21-8193dc311841', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('5850c6ab-5c87-4331-8439-73692a403228', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('bc795a9b-7977-4e01-b513-f9f5aba38aa7', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('27a5d147-a323-4c6a-84ef-45d80cae923d', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('3ea9e187-e91b-4852-84eb-b35b5c480892', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('3d9bca6e-5fca-40c5-b005-8a794958f3aa', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('28c99b35-98ce-4bfe-bb6d-94a65207258a', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('7821a1f9-02a0-4833-a048-3bf184b1c6fe', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('78b1fe35-9739-46b3-8baf-21731d886913', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('cdbd8bf8-84ac-49f6-a58e-e7414333947c', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('92dddd27-4627-42aa-b667-a9c9d805e475', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('aab9d0f8-2c0b-4ed8-8a82-1b4e91358854', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('ebc49a18-4a96-416c-9dd6-5de89d0d1b89', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('5651c09a-634c-4ca1-a5cb-d38ce946c60a', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('8f497741-928c-480c-9085-1036b2e24051', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('b8785a66-2805-4559-8332-dd348ace3afc', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('e316884d-c2c6-453f-a08b-372167957277', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('467cae27-d8be-4509-af26-64ed0a809028', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('61130a8b-68ad-4281-80ad-a62d44bc4090', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('386a4d90-1a3d-427c-96a6-6f1a433daae6', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('2fb586fd-9982-4f4e-987b-17909069e10e', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('cbc6fe12-4a7d-4de5-b709-b20dd0cacbbf', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('7c8849ee-26ad-4910-b798-902367e617d6', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('55f886b3-4fe0-4bc8-8bde-d0b7004a70ee', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('da2bd135-4ba2-4b98-bb77-c60607402094', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('5190eb38-48a2-41ee-b85e-dbb3c609ed30', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('da3a0878-df45-4eb1-857e-82e5ae055683', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('e22b33bc-b5cf-4a61-a8e9-dd204c48857b', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('f675060d-34cd-4af7-abb7-864a8b9adef6', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('155933df-9d41-4b2d-bdf8-11291fb7084c', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('3d6ef3c9-28dd-4d2f-b006-e3427e24c0b0', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('f53f1daa-1eda-4fd9-966f-3f14c107930a', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('10edf46a-113f-4688-9af6-75494b950fbf', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('47e05a38-2201-49f2-80e6-17d618ed260f', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('e4e0fe4d-8757-4253-95de-a6f13ea66f30', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('000904c1-aa91-498b-88da-d6cb014931df', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('a7bc398e-972a-481f-8c63-b4c5a1b946d9', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('678a2e5a-697f-4416-afe6-fd18bc935bdc', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('d6d9a4e5-0944-4360-8af9-77d6f780716e', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('d6db370c-42eb-414b-80b7-af50c14fb7e4', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('2ee3eb24-165d-46d5-976c-9eb052a1912b', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('0a4ffca5-3b28-4897-9842-295f9bb6bea8', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('d285eda8-41ee-4ba2-879d-52acec6a1416', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('d8c99d65-8950-4b83-aa1d-549a88e28339', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('94331ad5-4f67-4183-8fbe-55fe9c542789', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('4710c428-a004-4da1-98a8-58205e051ec2', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('0b5ba218-dcb1-4841-a517-b6010b8a2951', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('9bcced52-edb3-44a2-a86d-43499ea61289', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('7d2e969e-c266-4a83-85a5-5a07d528c6ef', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('35de7456-fced-4c23-bca5-8777984bf731', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('10a46ac6-1420-41ad-9d3a-ab244d959062', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('d53673f0-fc52-48c8-8893-f8f244cf6ee3', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('45fdc628-1914-4b2c-92c4-38f7be3c622a', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('b228d692-009d-4122-b617-1a3799a68766', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('a6e349c7-d5c0-42a7-bd78-21e4b2738fa7', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('4d153210-05d9-43f0-8560-3c3bd722d8bd', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('0145a85e-3b00-4e64-9e20-bdaf77d2fc86', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('407ae0d5-e5be-4151-900b-041ed5dfcdbe', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('e6106e4d-46a4-4557-8c2d-009ff7159464', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('5d7a8af7-94fb-4c63-958c-403d845d4107', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('ce95634f-69e0-4f97-a9b6-10bc8364849f', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('50d0b397-d2df-4797-8975-d2526c8cdd63', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('cd686d46-c77f-4c35-8016-f9819282f8a5', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('b6436fe2-9e3f-49ac-9e09-5cce86e480e1', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('bace6e02-1e3f-4ddc-9e9a-eb04933fa226', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('ecb7d0a0-72d0-44c3-90dd-5b9af536ebca', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('81dba31f-e19a-4a8b-a07f-e1561fc2ce06', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('3baad63c-42d2-46cb-b7a5-ab394b4e012c', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('7116be12-b724-456f-ac3d-0a1ab6e85b9a', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('801d44ab-fc18-4cc0-8e10-49f2e73b229a', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('7f488cff-525f-4e50-a6c6-219b4ab4854d', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('e35d735c-f724-4946-aad9-7fa520d5a843', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('b8e826e0-dc07-4515-ae10-87b402e3d52c', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('358bf776-378f-465e-a9e6-e8a1c7716825', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('3b090377-8703-4cf7-9ce8-a432dce76335', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('f69638dc-6844-415c-a679-d3982c691f38', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('34b02438-ceaf-4177-9a3e-74f907cfd63d', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('b7602673-7825-48e2-829e-b9df269071fc', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('9b50b4bf-4b5c-4d52-a7d3-1b0e6a0f53f9', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('1dafcbc7-f048-4867-ad7f-2d0b40e096e1', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('6d763f90-d7d4-4d58-a82c-09bb68ac6b82', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('68a4bbc9-2535-4cfc-a4f4-b149adfb674a', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('3a1fb1cd-1078-4616-b603-a22c8f9449b2', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('80d829b6-d1ed-40a3-95ea-7e0b34de8eba', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('b9484449-18bd-4667-a9e5-1f6bf66d442d', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('a81eb2c5-84ce-4a14-8242-e9ce19532423', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('15da23b4-5ad5-44ff-8936-140dd98935df', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('599e5d49-ede8-489b-bb72-3e41c288ae89', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('e6e239af-3d3a-4dfb-8c84-cbe268ca90d4', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('b86f6da4-3c9e-4146-8161-9c806b50b923', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('c12b3086-5fa4-4140-915b-330fbffdfc43', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('1a1b9319-e303-431d-91c3-f4a3b6189982', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('9bafcace-20a3-4726-963b-06d09437c677', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('26c8f1cb-a592-415e-846e-22f2ee761c8f', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('d89d5a40-b864-4d97-9b44-211ed25c4f98', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('c56361d3-4230-4653-942b-fc8ac7488bf9', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('19c5ed05-1a24-4971-9aac-390e1931f010', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('b14e9775-09ad-4019-b5db-dd9670221679', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('f3afc386-7c81-41d1-9b94-a06a49deb965', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('ef45bb4d-7f1a-4840-9783-aa22ed40032a', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('ea7c0692-6545-40e3-8cf8-f4c828c5fce8', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('330ba4a6-411d-4d44-913a-2805a9f21cf7', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('acb053d6-b8be-4bce-b62d-3a8aa10b9a0d', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('c34d4c11-da4f-445d-8682-1c92dcfbb6be', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('01d63259-109f-4136-878d-77e503ac8a11', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('9c49472d-47fc-417e-b75a-512d57e76870', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('be9c4245-79db-40cd-a0d4-c750c3a822b6', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('0b8fa48f-6ccf-48ef-ac0b-3dadadad40bf', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('7d28fe21-466a-4e22-9851-374e9cb93cd9', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('db5033cf-c13f-47b1-a617-aea77a0d5864', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('8c047398-63a1-4940-a5c5-c44834f48516', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('885ade35-d310-421a-98b8-877e27e51531', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('ba3aaa33-9010-459f-acb5-5452788e9abc', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('c7e15bdd-a5f3-486d-8e3d-f3117f39eb1a', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('53adbbff-f4d6-4bd7-8b90-475f57913c1a', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('329b49fc-de79-4d63-97ca-87a8f83ef1e2', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('29f4224d-6b91-4218-aed6-0db3e5fa9dc2', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('658b6fce-40b0-4f05-a2da-2fd3e33684fb', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('b3418862-26a6-4bbb-b546-c12f48c45b16', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('26bc2583-1c9f-4d6e-9968-e5aa0e8ab82f', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('6c3f4121-65c2-444e-9d5a-f16f47fd2ed5', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('89dd6672-dd42-470b-8e84-129e4ec7540c', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('98ccd4dc-86a8-4652-b2c1-5b83b6f078e1', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('3953e924-30f6-4561-8e02-e761b417c1d4', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('02fc1261-b7d6-4d85-89ef-c987ab92f3d4', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('29acda13-a41f-4270-9248-375814889f20', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('a2b0eaca-aa24-4036-b730-265a97043b75', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('78b58f38-9075-44a1-8eb4-5ab0ba4b801d', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('d9bd086d-030c-4ca4-b6d2-29c2fbf517c8', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('7c775873-1ebf-4574-8cb1-29b0c661b8f3', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('0ee54310-5f4d-4435-9c34-cf93f742e101', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('ca07715c-696e-4a62-af10-74145ff818f5', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('06c5d5cc-5c29-4a74-be75-dfba20cc4f80', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('9167d0da-69ec-40a5-b7f8-5eab25833d70', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('3b3a9b48-63aa-4523-be3a-6a39fdf4bda7', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('28343b10-ce82-4c1f-aef2-f7d95316b48e', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('cf3a2b5f-9d7a-4f2c-ba39-abd290230b5b', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('3e74edee-f076-45b3-8247-a5dd19cb24b2', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('78185c7d-f353-49ee-b1e2-c2a0bcfc4ed2', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('96ec8c86-c024-4d03-a283-49375e43e086', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('b5c458ea-3a4e-4211-afc9-82510c2cff46', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('adcaac7d-a028-4d33-9111-ef3e711637e7', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('ccb661e2-6c0d-4020-9eb2-abd290230b5b', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('712b29e2-411b-4ef8-8f81-6cae15222c07', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('662ffad9-7dd3-490f-93d2-efb92f74c5ae', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('b244a2fb-1f27-4e6d-8f43-7e512798f299', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('84c81b22-765b-4edb-a6e7-c626151e0af8', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('c699fdf0-f31e-45c0-9d0d-cee2388e1544', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('5778b4ba-4acd-4c94-9c10-d83d80f75d50', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('38b1dd17-c3ff-46c4-b300-2e1c7d542abe', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('f619a8fd-fff8-4981-8947-48ebaaad993c', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('60e3ca01-0b7a-4785-acd7-3dddad0eea8e', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('36531ec5-477c-4d74-8d84-43276359aa14', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('a7e45f3a-e408-4593-9aba-0a724c5ebf26', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('9fee292c-8c59-4a99-a3c2-467717a22c70', NULL, NULL);
INSERT INTO public.knowledge_artifact (id, creation_date, last_modified_at) VALUES ('87ae00d9-3fc7-4b9b-ac8b-48b79cbf8f65', NULL, NULL);


--
-- TOC entry 3306 (class 0 OID 16388)
-- Dependencies: 202
-- Data for Name: algorithm; Type: TABLE DATA; Schema: public; Owner: planqk
--

INSERT INTO public.algorithm (acronym, algo_parameter, assumptions, computation_model, input_format, intent, name, output_format, problem, solution, id) VALUES (NULL, NULL, NULL, 1, NULL, NULL, 'Initialization', NULL, NULL, NULL, '9829e814-a707-479f-80c7-8b49ffa543bc');
INSERT INTO public.algorithm (acronym, algo_parameter, assumptions, computation_model, input_format, intent, name, output_format, problem, solution, id) VALUES (NULL, NULL, NULL, 1, NULL, NULL, 'Uniform Superposition', NULL, NULL, NULL, '52ae7837-58e1-47b2-bda3-4134597ef138');


--
-- TOC entry 3315 (class 0 OID 16424)
-- Dependencies: 211
-- Data for Name: application_area; Type: TABLE DATA; Schema: public; Owner: planqk
--

INSERT INTO public.application_area (id, name) VALUES ('ce597b06-c55e-46ce-976c-8de398e049b9', 'Cryptography');
INSERT INTO public.application_area (id, name) VALUES ('12b0d326-8b6a-4f7c-8717-d9cc5eb4a567', 'Classification');
INSERT INTO public.application_area (id, name) VALUES ('da982d08-30a8-48f7-8db1-204c0b4f1865', 'Machine Learning');


--
-- TOC entry 3307 (class 0 OID 16394)
-- Dependencies: 203
-- Data for Name: algorithm_application_area; Type: TABLE DATA; Schema: public; Owner: planqk
--



--
-- TOC entry 3341 (class 0 OID 16534)
-- Dependencies: 237
-- Data for Name: learning_method; Type: TABLE DATA; Schema: public; Owner: planqk
--



--
-- TOC entry 3308 (class 0 OID 16397)
-- Dependencies: 204
-- Data for Name: algorithm_learning_method; Type: TABLE DATA; Schema: public; Owner: planqk
--



--
-- TOC entry 3345 (class 0 OID 16552)
-- Dependencies: 241
-- Data for Name: problem_type; Type: TABLE DATA; Schema: public; Owner: planqk
--

INSERT INTO public.problem_type (id, name, parent_problem_type) VALUES ('76d773b5-4635-4d67-877c-e565b9f08496', 'Integer Factorization', NULL);


--
-- TOC entry 3309 (class 0 OID 16400)
-- Dependencies: 205
-- Data for Name: algorithm_problem_type; Type: TABLE DATA; Schema: public; Owner: planqk
--



--
-- TOC entry 3346 (class 0 OID 16555)
-- Dependencies: 242
-- Data for Name: publication; Type: TABLE DATA; Schema: public; Owner: planqk
--

INSERT INTO public.publication (doi, title, url, id) VALUES ('10.1137/S0097539795293172', 'Polynomial-Time Algorithms for Prime Factorization and Discrete Logarithms on a Quantum Computer', 'https://arxiv.org/abs/quant-ph/9508027', 'f05c9136-2f9f-433f-9c35-85009111ee3c');
INSERT INTO public.publication (doi, title, url, id) VALUES ('10.1109/TSMCB.2008.925743', 'Quantum reinforcement learning', 'https://arxiv.org/abs/0810.3828', '87d697a4-6256-4f84-b545-c2024ab380c2');
INSERT INTO public.publication (doi, title, url, id) VALUES ('10.1038/s41586-019-0980-2', 'Supervised learning with quantum enhanced feature spaces', 'https://arxiv.org/abs/1804.11326', '3aac6a37-10de-4a95-a2bd-381d357df2a4');
INSERT INTO public.publication (doi, title, url, id) VALUES ('10.1016/j.cpc.2019.107006', 'Support vector machines on the D-Wave quantum annealer', 'https://arxiv.org/abs/1906.06283', 'ae6bdf6f-2656-45bd-9b96-0820eea3cdab');


--
-- TOC entry 3310 (class 0 OID 16403)
-- Dependencies: 206
-- Data for Name: algorithm_publication; Type: TABLE DATA; Schema: public; Owner: planqk
--



--
-- TOC entry 3312 (class 0 OID 16409)
-- Dependencies: 208
-- Data for Name: algorithm_relation_type; Type: TABLE DATA; Schema: public; Owner: planqk
--



--
-- TOC entry 3311 (class 0 OID 16406)
-- Dependencies: 207
-- Data for Name: algorithm_relation; Type: TABLE DATA; Schema: public; Owner: planqk
--



--
-- TOC entry 3352 (class 0 OID 16576)
-- Dependencies: 248
-- Data for Name: revinfo; Type: TABLE DATA; Schema: public; Owner: planqk
--

INSERT INTO public.revinfo (rev, revtstmp) VALUES (1, 1698650562455);
INSERT INTO public.revinfo (rev, revtstmp) VALUES (2, 1698650562578);
INSERT INTO public.revinfo (rev, revtstmp) VALUES (3, 1698650570493);
INSERT INTO public.revinfo (rev, revtstmp) VALUES (4, 1698650570501);
INSERT INTO public.revinfo (rev, revtstmp) VALUES (5, 1698650570540);
INSERT INTO public.revinfo (rev, revtstmp) VALUES (6, 1698656605831);
INSERT INTO public.revinfo (rev, revtstmp) VALUES (7, 1698656617204);


--
-- TOC entry 3340 (class 0 OID 16531)
-- Dependencies: 236
-- Data for Name: knowledge_artifact_revisions; Type: TABLE DATA; Schema: public; Owner: planqk
--

INSERT INTO public.knowledge_artifact_revisions (id, rev, revtype, creation_date, last_modified_at) VALUES ('b3b616b6-6e4a-49b1-baf7-f08fa962a441', 1, 1, NULL, NULL);
INSERT INTO public.knowledge_artifact_revisions (id, rev, revtype, creation_date, last_modified_at) VALUES ('1066e01c-e3ac-4830-b610-eb613187850c', 1, 1, NULL, NULL);
INSERT INTO public.knowledge_artifact_revisions (id, rev, revtype, creation_date, last_modified_at) VALUES ('e07898e3-280f-4701-9d54-7d051af8d448', 2, 1, NULL, NULL);
INSERT INTO public.knowledge_artifact_revisions (id, rev, revtype, creation_date, last_modified_at) VALUES ('816a96fc-696d-419f-8bd4-98752cc72aac', 2, 1, NULL, NULL);
INSERT INTO public.knowledge_artifact_revisions (id, rev, revtype, creation_date, last_modified_at) VALUES ('c293bbf4-b8cf-4393-a403-a359a77b868c', 2, 1, NULL, NULL);
INSERT INTO public.knowledge_artifact_revisions (id, rev, revtype, creation_date, last_modified_at) VALUES ('170eff66-733f-4043-a56b-3189bf474d62', 2, 1, NULL, NULL);
INSERT INTO public.knowledge_artifact_revisions (id, rev, revtype, creation_date, last_modified_at) VALUES ('649859eb-7709-4beb-9738-d57f11d80455', 3, 1, NULL, NULL);
INSERT INTO public.knowledge_artifact_revisions (id, rev, revtype, creation_date, last_modified_at) VALUES ('10bc87a9-9317-41c8-8d19-fc6594d23383', 4, 1, NULL, NULL);
INSERT INTO public.knowledge_artifact_revisions (id, rev, revtype, creation_date, last_modified_at) VALUES ('e7a33256-0ab4-4baa-a805-0296b97960d6', 4, 1, NULL, NULL);
INSERT INTO public.knowledge_artifact_revisions (id, rev, revtype, creation_date, last_modified_at) VALUES ('7de45de7-aca2-4966-a5f9-8ef018688722', 5, 1, NULL, NULL);
INSERT INTO public.knowledge_artifact_revisions (id, rev, revtype, creation_date, last_modified_at) VALUES ('8179d686-afa1-4f03-8ec9-95899002488a', 5, 1, NULL, NULL);
INSERT INTO public.knowledge_artifact_revisions (id, rev, revtype, creation_date, last_modified_at) VALUES ('9829e814-a707-479f-80c7-8b49ffa543bc', 6, 0, NULL, NULL);
INSERT INTO public.knowledge_artifact_revisions (id, rev, revtype, creation_date, last_modified_at) VALUES ('52ae7837-58e1-47b2-bda3-4134597ef138', 7, 0, NULL, NULL);


--
-- TOC entry 3313 (class 0 OID 16415)
-- Dependencies: 209
-- Data for Name: algorithm_revisions; Type: TABLE DATA; Schema: public; Owner: planqk
--

INSERT INTO public.algorithm_revisions (id, rev, acronym, algo_parameter, assumptions, computation_model, input_format, intent, name, output_format, problem, solution) VALUES ('9829e814-a707-479f-80c7-8b49ffa543bc', 6, NULL, NULL, NULL, 1, NULL, NULL, 'Initialization', NULL, NULL, NULL);
INSERT INTO public.algorithm_revisions (id, rev, acronym, algo_parameter, assumptions, computation_model, input_format, intent, name, output_format, problem, solution) VALUES ('52ae7837-58e1-47b2-bda3-4134597ef138', 7, NULL, NULL, NULL, 1, NULL, NULL, 'Uniform Superposition', NULL, NULL, NULL);


--
-- TOC entry 3357 (class 0 OID 16597)
-- Dependencies: 253
-- Data for Name: tag; Type: TABLE DATA; Schema: public; Owner: planqk
--

INSERT INTO public.tag (value, category) VALUES ('Phase Estimation', 'Subroutine');
INSERT INTO public.tag (value, category) VALUES ('Reinforcement learning', 'Algorithm class');
INSERT INTO public.tag (value, category) VALUES ('Classification', 'Algorithm class');
INSERT INTO public.tag (value, category) VALUES ('Factorization', 'Algorithm class');


--
-- TOC entry 3314 (class 0 OID 16421)
-- Dependencies: 210
-- Data for Name: algorithm_tag; Type: TABLE DATA; Schema: public; Owner: planqk
--



--
-- TOC entry 3316 (class 0 OID 16427)
-- Dependencies: 212
-- Data for Name: classic_algorithm; Type: TABLE DATA; Schema: public; Owner: planqk
--



--
-- TOC entry 3317 (class 0 OID 16430)
-- Dependencies: 213
-- Data for Name: classic_algorithm_revisions; Type: TABLE DATA; Schema: public; Owner: planqk
--



--
-- TOC entry 3332 (class 0 OID 16498)
-- Dependencies: 228
-- Data for Name: implementation; Type: TABLE DATA; Schema: public; Owner: planqk
--



--
-- TOC entry 3318 (class 0 OID 16433)
-- Dependencies: 214
-- Data for Name: classic_implementation; Type: TABLE DATA; Schema: public; Owner: planqk
--



--
-- TOC entry 3336 (class 0 OID 16516)
-- Dependencies: 232
-- Data for Name: implementation_revisions; Type: TABLE DATA; Schema: public; Owner: planqk
--

INSERT INTO public.implementation_revisions (id, rev, assumptions, contributors, dependencies, description, input_format, license, name, output_format, parameter, problem_statement, technology, version, implemented_algorithm_id) VALUES ('b3b616b6-6e4a-49b1-baf7-f08fa962a441', 1, NULL, NULL, 'Python3', NULL, 'U: Float Array; Precision: Integer', NULL, 'forest-qpe', 'Eigenvalue: Integer Array', 'U: unitary matrix; precision: precision > 0', NULL, NULL, NULL, NULL);
INSERT INTO public.implementation_revisions (id, rev, assumptions, contributors, dependencies, description, input_format, license, name, output_format, parameter, problem_statement, technology, version, implemented_algorithm_id) VALUES ('1066e01c-e3ac-4830-b610-eb613187850c', 1, NULL, NULL, 'Python3', NULL, NULL, NULL, 'qiskit-qpe', NULL, NULL, NULL, NULL, NULL, NULL);
INSERT INTO public.implementation_revisions (id, rev, assumptions, contributors, dependencies, description, input_format, license, name, output_format, parameter, problem_statement, technology, version, implemented_algorithm_id) VALUES ('e07898e3-280f-4701-9d54-7d051af8d448', 2, NULL, NULL, 'Python3', NULL, 'N: Integer', NULL, 'forest-shor', 'Factors: Integer Array', 'N: N > 2', NULL, NULL, NULL, NULL);
INSERT INTO public.implementation_revisions (id, rev, assumptions, contributors, dependencies, description, input_format, license, name, output_format, parameter, problem_statement, technology, version, implemented_algorithm_id) VALUES ('816a96fc-696d-419f-8bd4-98752cc72aac', 2, NULL, NULL, NULL, NULL, NULL, NULL, 'shor-general-qiskit', NULL, NULL, NULL, NULL, NULL, NULL);
INSERT INTO public.implementation_revisions (id, rev, assumptions, contributors, dependencies, description, input_format, license, name, output_format, parameter, problem_statement, technology, version, implemented_algorithm_id) VALUES ('c293bbf4-b8cf-4393-a403-a359a77b868c', 2, NULL, NULL, NULL, NULL, NULL, NULL, 'shor-fix-15-qiskit', NULL, NULL, NULL, NULL, NULL, NULL);
INSERT INTO public.implementation_revisions (id, rev, assumptions, contributors, dependencies, description, input_format, license, name, output_format, parameter, problem_statement, technology, version, implemented_algorithm_id) VALUES ('170eff66-733f-4043-a56b-3189bf474d62', 2, NULL, NULL, 'Python3', NULL, 'N: Integer', NULL, 'qiskit-aqua-shor', 'Factors: Integer Array', 'N: N > 2', NULL, NULL, NULL, NULL);
INSERT INTO public.implementation_revisions (id, rev, assumptions, contributors, dependencies, description, input_format, license, name, output_format, parameter, problem_statement, technology, version, implemented_algorithm_id) VALUES ('649859eb-7709-4beb-9738-d57f11d80455', 3, NULL, NULL, NULL, NULL, NULL, NULL, 'simon-general-qiskit', NULL, NULL, NULL, NULL, NULL, NULL);
INSERT INTO public.implementation_revisions (id, rev, assumptions, contributors, dependencies, description, input_format, license, name, output_format, parameter, problem_statement, technology, version, implemented_algorithm_id) VALUES ('10bc87a9-9317-41c8-8d19-fc6594d23383', 4, NULL, NULL, NULL, NULL, NULL, NULL, 'grover-fix-truthtable-qiskit', NULL, NULL, NULL, NULL, NULL, NULL);
INSERT INTO public.implementation_revisions (id, rev, assumptions, contributors, dependencies, description, input_format, license, name, output_format, parameter, problem_statement, technology, version, implemented_algorithm_id) VALUES ('e7a33256-0ab4-4baa-a805-0296b97960d6', 4, NULL, NULL, NULL, NULL, NULL, NULL, 'grover-general-truthtable-qiskit', NULL, NULL, NULL, NULL, NULL, NULL);
INSERT INTO public.implementation_revisions (id, rev, assumptions, contributors, dependencies, description, input_format, license, name, output_format, parameter, problem_statement, technology, version, implemented_algorithm_id) VALUES ('7de45de7-aca2-4966-a5f9-8ef018688722', 5, NULL, NULL, NULL, NULL, NULL, NULL, 'grover-general-sat-qiskit', NULL, NULL, NULL, NULL, NULL, NULL);
INSERT INTO public.implementation_revisions (id, rev, assumptions, contributors, dependencies, description, input_format, license, name, output_format, parameter, problem_statement, technology, version, implemented_algorithm_id) VALUES ('8179d686-afa1-4f03-8ec9-95899002488a', 5, NULL, NULL, NULL, NULL, NULL, NULL, 'grover-fix-sat-qiskit', NULL, NULL, NULL, NULL, NULL, NULL);


--
-- TOC entry 3319 (class 0 OID 16436)
-- Dependencies: 215
-- Data for Name: classic_implementation_revisions; Type: TABLE DATA; Schema: public; Owner: planqk
--



--
-- TOC entry 3320 (class 0 OID 16439)
-- Dependencies: 216
-- Data for Name: cloud_service; Type: TABLE DATA; Schema: public; Owner: planqk
--

INSERT INTO public.cloud_service (id, cost_model, description, name, provider, url) VALUES ('7ac0786f-4d4d-4ab6-beb8-6d3c9d80857d', NULL, NULL, 'IBMQ', 'IBM', 'https://quantum-computing.ibm.com/');
INSERT INTO public.cloud_service (id, cost_model, description, name, provider, url) VALUES ('bac9b43d-6ced-41c6-ae85-ef065e280d8b', NULL, NULL, 'Rigetti', 'Rigetti', 'https://www.rigetti.com/');


--
-- TOC entry 3322 (class 0 OID 16448)
-- Dependencies: 218
-- Data for Name: compute_resource; Type: TABLE DATA; Schema: public; Owner: planqk
--

INSERT INTO public.compute_resource (dtype, id, name, quantum_computation_model, technology, vendor, qprov_origin) VALUES ('ComputeResource', 'faea0025-9096-4582-b2f9-93096358dbc2', 'ibmq_16_melbourne', 0, '', 'IBMQ', NULL);
INSERT INTO public.compute_resource (dtype, id, name, quantum_computation_model, technology, vendor, qprov_origin) VALUES ('ComputeResource', 'c0fc8141-4d19-4654-910b-109882b4b99b', 'ibmqx2', 0, NULL, 'IBMQ', NULL);
INSERT INTO public.compute_resource (dtype, id, name, quantum_computation_model, technology, vendor, qprov_origin) VALUES ('ComputeResource', '2e683cee-8363-4327-8765-3b5f957acc90', 'Rigetti 19Q', 0, 'Superconducting', 'Rigetti', NULL);
INSERT INTO public.compute_resource (dtype, id, name, quantum_computation_model, technology, vendor, qprov_origin) VALUES ('ComputeResource', '82df8861-b7de-464d-9dab-4adabbe78cd2', 'Rigetti 8Q', 0, 'Superconducting', 'Rigetti', NULL);


--
-- TOC entry 3321 (class 0 OID 16445)
-- Dependencies: 217
-- Data for Name: cloud_services_compute_resources; Type: TABLE DATA; Schema: public; Owner: planqk
--

INSERT INTO public.cloud_services_compute_resources (cloud_service_id, compute_resource_id) VALUES ('7ac0786f-4d4d-4ab6-beb8-6d3c9d80857d', 'faea0025-9096-4582-b2f9-93096358dbc2');
INSERT INTO public.cloud_services_compute_resources (cloud_service_id, compute_resource_id) VALUES ('bac9b43d-6ced-41c6-ae85-ef065e280d8b', '2e683cee-8363-4327-8765-3b5f957acc90');
INSERT INTO public.cloud_services_compute_resources (cloud_service_id, compute_resource_id) VALUES ('7ac0786f-4d4d-4ab6-beb8-6d3c9d80857d', 'c0fc8141-4d19-4654-910b-109882b4b99b');
INSERT INTO public.cloud_services_compute_resources (cloud_service_id, compute_resource_id) VALUES ('bac9b43d-6ced-41c6-ae85-ef065e280d8b', '82df8861-b7de-464d-9dab-4adabbe78cd2');


--
-- TOC entry 3324 (class 0 OID 16457)
-- Dependencies: 220
-- Data for Name: compute_resource_property_type; Type: TABLE DATA; Schema: public; Owner: planqk
--

INSERT INTO public.compute_resource_property_type (id, datatype, description, name) VALUES ('e658e9bb-ca15-4b3a-9dd2-833ccd144e50', 0, '', 'Number of Qubits');
INSERT INTO public.compute_resource_property_type (id, datatype, description, name) VALUES ('6fd6e29e-8fa4-4682-9ea6-f1b9a1cb2553', 2, '', 't1');
INSERT INTO public.compute_resource_property_type (id, datatype, description, name) VALUES ('ff58dc2e-b805-4d32-b2ac-a059464e5102', 0, '', 'Max gate time');


--
-- TOC entry 3323 (class 0 OID 16454)
-- Dependencies: 219
-- Data for Name: compute_resource_property; Type: TABLE DATA; Schema: public; Owner: planqk
--

INSERT INTO public.compute_resource_property (id, value, algorithm_id, compute_resource_id, compute_resource_property_type_id, implementation_id) VALUES ('92376664-12fc-4143-9ce3-0ce2a7372e05', '15', NULL, 'faea0025-9096-4582-b2f9-93096358dbc2', 'e658e9bb-ca15-4b3a-9dd2-833ccd144e50', NULL);
INSERT INTO public.compute_resource_property (id, value, algorithm_id, compute_resource_id, compute_resource_property_type_id, implementation_id) VALUES ('f052fab4-8fa7-4b20-a053-a655f362e5b7', '50063.8361', NULL, 'faea0025-9096-4582-b2f9-93096358dbc2', '6fd6e29e-8fa4-4682-9ea6-f1b9a1cb2553', NULL);
INSERT INTO public.compute_resource_property (id, value, algorithm_id, compute_resource_id, compute_resource_property_type_id, implementation_id) VALUES ('5d57ecb5-f071-472f-a0c3-213d99569f8e', '1043', NULL, 'faea0025-9096-4582-b2f9-93096358dbc2', 'ff58dc2e-b805-4d32-b2ac-a059464e5102', NULL);
INSERT INTO public.compute_resource_property (id, value, algorithm_id, compute_resource_id, compute_resource_property_type_id, implementation_id) VALUES ('29d3b8b6-9523-4610-9587-98a1019035e0', '5', NULL, 'c0fc8141-4d19-4654-910b-109882b4b99b', 'e658e9bb-ca15-4b3a-9dd2-833ccd144e50', NULL);
INSERT INTO public.compute_resource_property (id, value, algorithm_id, compute_resource_id, compute_resource_property_type_id, implementation_id) VALUES ('039b068c-cadd-4a95-a408-e3f058a540e2', '62104.6608', NULL, 'c0fc8141-4d19-4654-910b-109882b4b99b', '6fd6e29e-8fa4-4682-9ea6-f1b9a1cb2553', NULL);
INSERT INTO public.compute_resource_property (id, value, algorithm_id, compute_resource_id, compute_resource_property_type_id, implementation_id) VALUES ('428ac66a-c08d-441c-96a7-3c5976daa08d', '391', NULL, 'c0fc8141-4d19-4654-910b-109882b4b99b', 'ff58dc2e-b805-4d32-b2ac-a059464e5102', NULL);
INSERT INTO public.compute_resource_property (id, value, algorithm_id, compute_resource_id, compute_resource_property_type_id, implementation_id) VALUES ('79834b76-82d5-4962-b78a-012f374fe4b1', '20', NULL, '2e683cee-8363-4327-8765-3b5f957acc90', 'e658e9bb-ca15-4b3a-9dd2-833ccd144e50', NULL);
INSERT INTO public.compute_resource_property (id, value, algorithm_id, compute_resource_id, compute_resource_property_type_id, implementation_id) VALUES ('064f93f4-d50a-49ae-a7e4-ea36fc67a662', '20330', NULL, '2e683cee-8363-4327-8765-3b5f957acc90', '6fd6e29e-8fa4-4682-9ea6-f1b9a1cb2553', NULL);
INSERT INTO public.compute_resource_property (id, value, algorithm_id, compute_resource_id, compute_resource_property_type_id, implementation_id) VALUES ('51d3b698-0698-4058-bb9b-2de809a3a704', '214', NULL, '2e683cee-8363-4327-8765-3b5f957acc90', 'ff58dc2e-b805-4d32-b2ac-a059464e5102', NULL);
INSERT INTO public.compute_resource_property (id, value, algorithm_id, compute_resource_id, compute_resource_property_type_id, implementation_id) VALUES ('486fbc6f-20b2-4247-8742-b36cfd5b3c44', '8', NULL, '82df8861-b7de-464d-9dab-4adabbe78cd2', 'e658e9bb-ca15-4b3a-9dd2-833ccd144e50', NULL);
INSERT INTO public.compute_resource_property (id, value, algorithm_id, compute_resource_id, compute_resource_property_type_id, implementation_id) VALUES ('d772d10b-0614-480a-b2ec-b33a32d74e42', '13406.25', NULL, '82df8861-b7de-464d-9dab-4adabbe78cd2', '6fd6e29e-8fa4-4682-9ea6-f1b9a1cb2553', NULL);
INSERT INTO public.compute_resource_property (id, value, algorithm_id, compute_resource_id, compute_resource_property_type_id, implementation_id) VALUES ('dde0fa28-a69d-4e51-83c7-5e23d06aeb2a', '198', NULL, '82df8861-b7de-464d-9dab-4adabbe78cd2', 'ff58dc2e-b805-4d32-b2ac-a059464e5102', NULL);


--
-- TOC entry 3325 (class 0 OID 16463)
-- Dependencies: 221
-- Data for Name: concrete_solution; Type: TABLE DATA; Schema: public; Owner: planqk
--



--
-- TOC entry 3326 (class 0 OID 16469)
-- Dependencies: 222
-- Data for Name: concrete_solution_revisions; Type: TABLE DATA; Schema: public; Owner: planqk
--



--
-- TOC entry 3328 (class 0 OID 16478)
-- Dependencies: 224
-- Data for Name: discussion_topic; Type: TABLE DATA; Schema: public; Owner: planqk
--



--
-- TOC entry 3327 (class 0 OID 16475)
-- Dependencies: 223
-- Data for Name: discussion_comment; Type: TABLE DATA; Schema: public; Owner: planqk
--



--
-- TOC entry 3329 (class 0 OID 16484)
-- Dependencies: 225
-- Data for Name: file; Type: TABLE DATA; Schema: public; Owner: planqk
--



--
-- TOC entry 3353 (class 0 OID 16579)
-- Dependencies: 249
-- Data for Name: sketch; Type: TABLE DATA; Schema: public; Owner: planqk
--



--
-- TOC entry 3331 (class 0 OID 16492)
-- Dependencies: 227
-- Data for Name: image; Type: TABLE DATA; Schema: public; Owner: planqk
--



--
-- TOC entry 3333 (class 0 OID 16504)
-- Dependencies: 229
-- Data for Name: implementation_package; Type: TABLE DATA; Schema: public; Owner: planqk
--



--
-- TOC entry 3334 (class 0 OID 16510)
-- Dependencies: 230
-- Data for Name: implementation_package_file; Type: TABLE DATA; Schema: public; Owner: planqk
--



--
-- TOC entry 3335 (class 0 OID 16513)
-- Dependencies: 231
-- Data for Name: implementation_publication; Type: TABLE DATA; Schema: public; Owner: planqk
--



--
-- TOC entry 3354 (class 0 OID 16585)
-- Dependencies: 250
-- Data for Name: software_platform; Type: TABLE DATA; Schema: public; Owner: planqk
--

INSERT INTO public.software_platform (id, licence, link, name, version) VALUES ('7c2c4b2e-5b4e-421c-a487-54fd897bfe41', 'Apache-2.0 License', 'https://pyquil-docs.rigetti.com/en/stable/', 'Forest', NULL);
INSERT INTO public.software_platform (id, licence, link, name, version) VALUES ('41299c3c-297a-4d61-be24-cc957186306e', 'Apache-2.0 License', 'https://github.com/Qiskit/qiskit', 'Qiskit', '0.21.0');


--
-- TOC entry 3337 (class 0 OID 16522)
-- Dependencies: 233
-- Data for Name: implementation_software_platforms; Type: TABLE DATA; Schema: public; Owner: planqk
--



--
-- TOC entry 3338 (class 0 OID 16525)
-- Dependencies: 234
-- Data for Name: implementation_tag; Type: TABLE DATA; Schema: public; Owner: planqk
--



--
-- TOC entry 3342 (class 0 OID 16537)
-- Dependencies: 238
-- Data for Name: pattern; Type: TABLE DATA; Schema: public; Owner: planqk
--

INSERT INTO public.pattern (id, name, uri, content, icon_url, rendered_content, pattern_language_id, paper_ref, deployment_modeling_behavior_pattern, deployment_modeling_structure_pattern, tags) VALUES ('2229a430-fe92-4411-9d72-d10dd1d8da14', 'Uniform Superposition', 'https://patternpedia.org/patternLanguages/reformulatedQuantumComputingPatterns/uniformSuperposition', '{"Alias": "", "Intent": "Create a uniform superposition of all possible states of a quantum register", "Result": "A [Uniform Superposition](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/2229a430-fe92-4411-9d72-d10dd1d8da14) can be achieved by performing a single parallel operation on each qubit, increasing the depth of the entire circuit by only one.\n\n", "Context": "The power of quantum algorithms partially originates in the ability to represent multiple states at once, the so-called quantum parallelism.  \nTo realize quantum parallelism, some qubits of a quantum register must be brought into superposition.  \nMany algorithms start with obtaining an equally weighted superposition in (a part of) a quantum register. \nTherefore, for every state represented by (this part of) the quantum register,  the measurement probability is the same.", "Solution": "After initializing the quantum register as the unit vector $\\left|0 \\ldots 0\\right>$, a Uniform Superposition is created via the Hadamard transformation:\n\n\n$$\n\\newcommand{\\colVec}[1]{% inline column vector\n\\bigl( \\begin{smallmatrix}#1\\end{smallmatrix}\\bigr)\n}\n\\newcommand{\\bigColVec}[1]{% inline column vector\n\\left( \\begin{matrix}#1\\end{matrix}\\right)\n}\n\\newcommand{\\state}[1]{{\\left| #1 \\right>}}H^{\\otimes n} \\left( \\left| 0 \\right>^{\\otimes n} \\right)= \\dfrac{1}{\\sqrt{2^n}} \\sum_{x=0}^{2^n-1} \\left|x \\right>$$\nThe quantum register may also include ancilla bits that must not necessarily be brought into superposition.\nFor example, if the last part of the quantum register is used for ancilla qubits, a different [Initialization](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/312bc9d3-26c0-40ae-b90b-56effd136c0d) on the two parts of the register can be accomplished by using a tensor product operator $H^{\\otimes n}\\otimes U$ where the Hadamard transformation $H^{\\otimes n}$ only operates on the first part and $U$ operates on the ancilla qubits. If the ancilla qubits are not brought into superposition, $U$ is the Identity (e.g., $U=I^{\\otimes m}$):\n$$ \n\\newcommand{\\state}[1]{{\\left| #1 \\right>}}\nH^{\\otimes n} \\otimes I^{\\otimes m} \\left( \\left| 0 \\right>^{\\otimes n} \\otimes \\left| 0 \\right>^{\\otimes m} \\right)= \\frac{1}{\\sqrt{2^n}} \\sum_{x=0}^{2^n-1} \\left|x \\right> \\otimes \\state{0}^{\\otimes m}\n$$", "Variants": "", "Known Uses": "Countless quantum algorithms start with a  uniform superposition.\n\n[Grover''s Algorithm (PlanQK)](https://platform.planqk.de/algorithms/86dfd279-db46-4adb-84a7-39bcf1d19d3a/)\n[Dürr-Høyer Quantum Minimization Algorithm (PlanQK)](https://platform.planqk.de/algorithms/061f4eb3-d9ee-4f47-befc-9e242bf801ce/)\n[Quantum Phase Estimation (PlanQK)](https://platform.planqk.de/algorithms/ba4c50e3-7429-4471-a250-1762ed4c556a/)\n[Quantum approximate optimization algorithm (PlanQK)](https://platform.planqk.de/algorithms/fae60bca-d2b6-4aa2-88b7-58caace34179/)\n\n", "Related Patterns": "[Uniform Superposition](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/2229a430-fe92-4411-9d72-d10dd1d8da14) is a special case of [Initialization](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/312bc9d3-26c0-40ae-b90b-56effd136c0d).  \nAfter a register is brought into uniform superposition, [Creating Entanglement](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/3d1f3991-df47-4d42-8f9a-e6dcf4e3ccec) may be used. \nA [Function Table](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/3f3fabf0-7fa7-4b43-a74a-46a7ac2c55ee)can be computed on a register in uniform superposition.\nAn [Oracle](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/1cc7e9d6-ab37-412e-8afa-604a25de296e) may  require its input to be in uniform superposition."}', 'https://quantumcomputingpatterns.org/assets/pattern-icons/equal_superposition_icon.png', '{"Alias": "", "Intent": "Create a uniform superposition of all possible states of a quantum register", "Result": "A [Uniform Superposition](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/2229a430-fe92-4411-9d72-d10dd1d8da14) can be achieved by performing a single parallel operation on each qubit, increasing the depth of the entire circuit by only one.\n\n", "Context": "The power of quantum algorithms partially originates in the ability to represent multiple states at once, the so-called quantum parallelism.  \nTo realize quantum parallelism, some qubits of a quantum register must be brought into superposition.  \nMany algorithms start with obtaining an equally weighted superposition in (a part of) a quantum register. \nTherefore, for every state represented by (this part of) the quantum register,  the measurement probability is the same.", "Solution": "After initializing the quantum register as the unit vector $\\left|0 \\ldots 0\\right>$, a Uniform Superposition is created via the Hadamard transformation:\n\n\n$$\n\\newcommand{\\colVec}[1]{% inline column vector\n\\bigl( \\begin{smallmatrix}#1\\end{smallmatrix}\\bigr)\n}\n\\newcommand{\\bigColVec}[1]{% inline column vector\n\\left( \\begin{matrix}#1\\end{matrix}\\right)\n}\n\\newcommand{\\state}[1]{{\\left| #1 \\right>}}H^{\\otimes n} \\left( \\left| 0 \\right>^{\\otimes n} \\right)= \\dfrac{1}{\\sqrt{2^n}} \\sum_{x=0}^{2^n-1} \\left|x \\right>$$\nThe quantum register may also include ancilla bits that must not necessarily be brought into superposition.\nFor example, if the last part of the quantum register is used for ancilla qubits, a different [Initialization](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/312bc9d3-26c0-40ae-b90b-56effd136c0d) on the two parts of the register can be accomplished by using a tensor product operator $H^{\\otimes n}\\otimes U$ where the Hadamard transformation $H^{\\otimes n}$ only operates on the first part and $U$ operates on the ancilla qubits. If the ancilla qubits are not brought into superposition, $U$ is the Identity (e.g., $U=I^{\\otimes m}$):\n$$ \n\\newcommand{\\state}[1]{{\\left| #1 \\right>}}\nH^{\\otimes n} \\otimes I^{\\otimes m} \\left( \\left| 0 \\right>^{\\otimes n} \\otimes \\left| 0 \\right>^{\\otimes m} \\right)= \\frac{1}{\\sqrt{2^n}} \\sum_{x=0}^{2^n-1} \\left|x \\right> \\otimes \\state{0}^{\\otimes m}\n$$", "Variants": "", "Known Uses": "Countless quantum algorithms start with a  uniform superposition.\n\n[Grover''s Algorithm (PlanQK)](https://platform.planqk.de/algorithms/86dfd279-db46-4adb-84a7-39bcf1d19d3a/)\n[Dürr-Høyer Quantum Minimization Algorithm (PlanQK)](https://platform.planqk.de/algorithms/061f4eb3-d9ee-4f47-befc-9e242bf801ce/)\n[Quantum Phase Estimation (PlanQK)](https://platform.planqk.de/algorithms/ba4c50e3-7429-4471-a250-1762ed4c556a/)\n[Quantum approximate optimization algorithm (PlanQK)](https://platform.planqk.de/algorithms/fae60bca-d2b6-4aa2-88b7-58caace34179/)\n\n", "Related Patterns": "[Uniform Superposition](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/2229a430-fe92-4411-9d72-d10dd1d8da14) is a special case of [Initialization](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/312bc9d3-26c0-40ae-b90b-56effd136c0d).  \nAfter a register is brought into uniform superposition, [Creating Entanglement](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/3d1f3991-df47-4d42-8f9a-e6dcf4e3ccec) may be used. \nA [Function Table](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/3f3fabf0-7fa7-4b43-a74a-46a7ac2c55ee)can be computed on a register in uniform superposition.\nAn [Oracle](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/1cc7e9d6-ab37-412e-8afa-604a25de296e) may  require its input to be in uniform superposition."}', 'af7780d5-1f97-4536-8da7-4194b093ab1d', 'https://link.springer.com/chapter/10.1007/978-3-030-14082-3_19', false, false, 'circuit-level');
INSERT INTO public.pattern (id, name, uri, content, icon_url, rendered_content, pattern_language_id, paper_ref, deployment_modeling_behavior_pattern, deployment_modeling_structure_pattern, tags) VALUES ('b6788c99-24f5-496b-a30c-fc0dd7bb3e96', 'Gate Error Mitigation', 'https://patternpedia.org/patternLanguages/quantumAlgorithmPatterns/gateErrorMitigationPattern', '{"Alias": "Enter your input for this section here.", "Forces": "The execution of gates on current NISQ devices is not perfectly accurate. Hence, every execution of a gate causes a minor error. These errors keep accumulating, eventually making large computations impossible. The pulses used for the implementation of gate operations can be controlled on many quantum devices. Therefore, custom pulse schedules can be used to individually calibrate gates. Furthermore, the capabilities of current quantum devices are limited, e.g., the number of qubits and the decoherence times are bound. Thus, minimal additional quantum resources, such as gates and qubits, shall be used for error mitigation.", "Intent": "How to reduce the negative impact of noisy gate executions such that the pre-measurement state is closer to the expected error-free state?", "Result": "GEM can significantly reduce the impact of errors caused by erroneous gate executions. As a consequence, the state computed by the quantum algorithm is closer to the expected error-free quantum state and a more precise algorithm result can be obtained. However, the mitigation process may induce additional quantum gates into the circuit or require classical pre-processing to calculate optimal device calibrations, e.g., gate pulse calibrations. Generally, GEM methods can be used in combination with other error mitigation methods, such as REM to reduce the overall error further.", "Context": "A NISQ-compatible quantum algorithm, e.g., VQE, needs to be run on a quantum device. The device’s gate implementations are error-prone, causing errors in the quantum computation. To obtain precise results for the executed algorithm, the measured state needs to be computed accurately. Thus, it is crucial to mitigate the effects of gate errors.", "Examples": "The figure below shows the process of a typical gate addition-based method. These methods mitigate gate errors by adding additional gates to the quantum circuit that balance out gate errors. The initial quantum circuit is modified by adding specific gates for each error-prone operation. Hence, the depth of the circuit increases significantly. Therefore, the device’s decoherence times need to be kept in mind, as otherwise, the mitigation might decrease the result quality. \n![](https://quantumcomputingpatterns.org/assets/sketches/gate-error-mitigation-solution-example1.svg)\nThe figure below depicts the typical process of a pulse calibration method. First, the pulse calibrations for the device are generated, e.g., it is determined which frequency is perfect to perform a bit-flip operation on a specific qubit. Once all required frequencies are determined, the information can be incorporated into the quantum circuit. When executing the modified circuit, the custom pulse calibrations will now be used instead of the default values. More precise pulse calibrations make gate executions more accurate, thus, decreasing gate error rates and increasing the solution’s precision\n![](https://quantumcomputingpatterns.org/assets/sketches/gate-error-mitigation-solution-example1.svg)", "Solution": "Mitigate the impact of gate errors by applying a Gate Error Mitigation (GEM) method. The mitigation of gate errors has to be performed before the execution of the quantum circuit, as occurring errors otherwise accumulate during the computation, making it difficult to retrace them. The resulting pre-measurement quantum state is closer to the expected error-free state, therefore, providing more accurate measurement results. The figure below depicts a solution sketch for GEM. First, the circuit is implemented. Afterwards, a GEM method is applied, modifying the circuit, to generate a more precise implementation for the selected device. The circuit modifications can range from simple gate additions over custom gate pulse adjustments to full circuit rewrites based on Machine Learning (ML). Next, the improved circuit is executed on the quantum device. Finally, the improved measurement result can be evaluated to obtain a more precise solution.\n![](https://quantumcomputingpatterns.org/assets/sketches/gate-error-mitigation-solution-sketch.svg)", "Known Uses": "Several circuit adjustment methods, e.g., FIIM or Random Identity Insertion (RIIM), are presented in the literature [[Nachman et al.]](https://journals.aps.org/pra/abstract/10.1103/PhysRevA.102.012426),[[Temme et al.]](https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.119.180509),[[Harper et al.]](https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.122.080504). Further, machine learning-based circuit adjustment methods have been introduced, e.g., Noise-Aware Circuit Learning (NACL) [[Cincio et al.]](https://journals.aps.org/prxquantum/abstract/10.1103/PRXQuantum.2.010324). Moreover, pulse modification-based GEM methods have been presented [[Carvalho et al.]](https://journals.aps.org/prapplied/abstract/10.1103/PhysRevApplied.15.064054),[[Giurgica-Tiron et al.]](https://ieeexplore.ieee.org/abstract/document/9259940).", "Related Pattern": "Enter your input for this section here."}', 'https://quantumcomputingpatterns.org/assets/pattern-icons/gate_error_mitigation_icon.png', '{"Alias": "Enter your input for this section here.", "Forces": "The execution of gates on current NISQ devices is not perfectly accurate. Hence, every execution of a gate causes a minor error. These errors keep accumulating, eventually making large computations impossible. The pulses used for the implementation of gate operations can be controlled on many quantum devices. Therefore, custom pulse schedules can be used to individually calibrate gates. Furthermore, the capabilities of current quantum devices are limited, e.g., the number of qubits and the decoherence times are bound. Thus, minimal additional quantum resources, such as gates and qubits, shall be used for error mitigation.", "Intent": "How to reduce the negative impact of noisy gate executions such that the pre-measurement state is closer to the expected error-free state?", "Result": "GEM can significantly reduce the impact of errors caused by erroneous gate executions. As a consequence, the state computed by the quantum algorithm is closer to the expected error-free quantum state and a more precise algorithm result can be obtained. However, the mitigation process may induce additional quantum gates into the circuit or require classical pre-processing to calculate optimal device calibrations, e.g., gate pulse calibrations. Generally, GEM methods can be used in combination with other error mitigation methods, such as REM to reduce the overall error further.", "Context": "A NISQ-compatible quantum algorithm, e.g., VQE, needs to be run on a quantum device. The device’s gate implementations are error-prone, causing errors in the quantum computation. To obtain precise results for the executed algorithm, the measured state needs to be computed accurately. Thus, it is crucial to mitigate the effects of gate errors.", "Examples": "The figure below shows the process of a typical gate addition-based method. These methods mitigate gate errors by adding additional gates to the quantum circuit that balance out gate errors. The initial quantum circuit is modified by adding specific gates for each error-prone operation. Hence, the depth of the circuit increases significantly. Therefore, the device’s decoherence times need to be kept in mind, as otherwise, the mitigation might decrease the result quality. \n![](https://quantumcomputingpatterns.org/assets/sketches/gate-error-mitigation-solution-example1.svg)\nThe figure below depicts the typical process of a pulse calibration method. First, the pulse calibrations for the device are generated, e.g., it is determined which frequency is perfect to perform a bit-flip operation on a specific qubit. Once all required frequencies are determined, the information can be incorporated into the quantum circuit. When executing the modified circuit, the custom pulse calibrations will now be used instead of the default values. More precise pulse calibrations make gate executions more accurate, thus, decreasing gate error rates and increasing the solution’s precision\n![](https://quantumcomputingpatterns.org/assets/sketches/gate-error-mitigation-solution-example1.svg)", "Solution": "Mitigate the impact of gate errors by applying a Gate Error Mitigation (GEM) method. The mitigation of gate errors has to be performed before the execution of the quantum circuit, as occurring errors otherwise accumulate during the computation, making it difficult to retrace them. The resulting pre-measurement quantum state is closer to the expected error-free state, therefore, providing more accurate measurement results. The figure below depicts a solution sketch for GEM. First, the circuit is implemented. Afterwards, a GEM method is applied, modifying the circuit, to generate a more precise implementation for the selected device. The circuit modifications can range from simple gate additions over custom gate pulse adjustments to full circuit rewrites based on Machine Learning (ML). Next, the improved circuit is executed on the quantum device. Finally, the improved measurement result can be evaluated to obtain a more precise solution.\n![](https://quantumcomputingpatterns.org/assets/sketches/gate-error-mitigation-solution-sketch.svg)", "Known Uses": "Several circuit adjustment methods, e.g., FIIM or Random Identity Insertion (RIIM), are presented in the literature [[Nachman et al.]](https://journals.aps.org/pra/abstract/10.1103/PhysRevA.102.012426),[[Temme et al.]](https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.119.180509),[[Harper et al.]](https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.122.080504). Further, machine learning-based circuit adjustment methods have been introduced, e.g., Noise-Aware Circuit Learning (NACL) [[Cincio et al.]](https://journals.aps.org/prxquantum/abstract/10.1103/PRXQuantum.2.010324). Moreover, pulse modification-based GEM methods have been presented [[Carvalho et al.]](https://journals.aps.org/prapplied/abstract/10.1103/PhysRevApplied.15.064054),[[Giurgica-Tiron et al.]](https://ieeexplore.ieee.org/abstract/document/9259940).", "Related Pattern": "Enter your input for this section here."}', 'af7780d5-1f97-4536-8da7-4194b093ab1d', 'https://www.thinkmind.org/index.php?view=article&articleid=patterns_2022_2_10_70007', false, false, 'augmentation');
INSERT INTO public.pattern (id, name, uri, content, icon_url, rendered_content, pattern_language_id, paper_ref, deployment_modeling_behavior_pattern, deployment_modeling_structure_pattern, tags) VALUES ('45d09c54-3f4a-453b-885d-2772443c8d72', 'Matrix Encoding', 'https://patternpedia.org/patternLanguages/reformulatedQuantumComputingPatterns/matrixEncoding', '{"Alias": "Dynamic Encoding [[Schuld and Petruccione 2018](http://dx.doi.org/10.1007/978-3-319-96424-9)]", "Intent": "Represent a matrix as an operation on a quantum computer", "Result": "Since the eigenvectors $\\newcommand{\\state}[1]{{\\left| #1 \\right>}}\\{\\state{v_i}\\}$ of the $n \\times n$ matrix $H$ form a basis, each state vector $\\ket{\\psi}$ can be written as a linear combination of these eigenvectors: \n$$ \\newcommand{\\state}[1]{{\\left| #1 \\right>}}\\state{\\psi}= \\gamma_1 \\state{v_1} + \\ldots + \\gamma_n \\state{v_n}$$\nApplying $U$ to this state results in the following state [[Schuld and Petruccione 2018](http://dx.doi.org/10.1007/978-3-319-96424-9)]:\n$$\\newcommand{\\state}[1]{{\\left| #1 \\right>}}e^{-iHt} \\state{\\psi}= e^{-i \\lambda_1 t} \\gamma_1 \\state{v_1} + \\ldots + e^{-i \\lambda_n t} \\gamma_n \\state{v_n}$$\nIf $\\ket{\\psi}$ is an eigenvector of $H$ and thus, only one $\\gamma_i \\neq 0$, the state acquires a global phase shift: $U \\gamma_i \\ket{v_i} = e^{-i \\lambda_i t} \\gamma_i \\ket{v_i}$ (see original paper for a definition of phase shift). This nicely reflects that applying the matrix A to an eigenstate leads to a scaling factor.\nThe main drawback of this encoding is that the depth of the circuit that implements $U$ can be exponential.", "Context": "A matrix $A$ has to be represented on a quantum computer as an operation $U$. \nTherefore, it is not sufficient to represent the entries of the matrix by a data encoding pattern as this does not define an operation.", "Solution": "If $A$ is not Hermitian, encode\n$$H = \\left( \\begin{matrix}0 & A\\\\ A^{\\dagger} & 0 \\end{matrix} \\right) $$\ninstead of A. Since $H$ is hermitian, $U=e^{-iHt}$ is unitary and can be used to encode $H$ where $t$ specifies the time for which the operation is applied (usually $t$ is chosen to be small). ", "Variants": "Enter your input for this section here.", "Known Uses": "This encoding is often used for the simulation of a quantum system, see [[Nielsen and Chuang 2002](https://doi.org/10.1119/1.1463744)] for various examples. The HHL algorithm for solving linear equations~ HHL algorithm [[Harrow, Hassidim and Lloyd 2009](https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.103.150502)] is an example of an algorithm that uses _Matrix Encoding_ in conjunction with _Quantum Phase Estimation_. [Pennylane](https://pennylane.readthedocs.io/en/stable/code/api/pennylane.templates.subroutines.ApproxTimeEvolution.html) provides an implementation for this encoding.\n\n[HHL Algorithm (PlanQK)](https://platform.planqk.de/algorithms/8c6909bd-a258-4702-8356-6ef28321a826/)", "Related Patterns": "This pattern can be used to define a unitary operation as input for [Quantum Phase Estimation](pattern-languages/a4ea9f6c-5b0a-4beb-a056-8b261d96ba80/a4ea9f6c-5b0a-4beb-a056-8b261d96ba80)."}', 'https://quantumcomputingpatterns.org/assets/pattern-icons/matrix_encoding_icon.png', '{"Alias": "Dynamic Encoding [[Schuld and Petruccione 2018](http://dx.doi.org/10.1007/978-3-319-96424-9)]", "Intent": "Represent a matrix as an operation on a quantum computer", "Result": "Since the eigenvectors $\\newcommand{\\state}[1]{{\\left| #1 \\right>}}\\{\\state{v_i}\\}$ of the $n \\times n$ matrix $H$ form a basis, each state vector $\\ket{\\psi}$ can be written as a linear combination of these eigenvectors: \n$$ \\newcommand{\\state}[1]{{\\left| #1 \\right>}}\\state{\\psi}= \\gamma_1 \\state{v_1} + \\ldots + \\gamma_n \\state{v_n}$$\nApplying $U$ to this state results in the following state [[Schuld and Petruccione 2018](http://dx.doi.org/10.1007/978-3-319-96424-9)]:\n$$\\newcommand{\\state}[1]{{\\left| #1 \\right>}}e^{-iHt} \\state{\\psi}= e^{-i \\lambda_1 t} \\gamma_1 \\state{v_1} + \\ldots + e^{-i \\lambda_n t} \\gamma_n \\state{v_n}$$\nIf $\\ket{\\psi}$ is an eigenvector of $H$ and thus, only one $\\gamma_i \\neq 0$, the state acquires a global phase shift: $U \\gamma_i \\ket{v_i} = e^{-i \\lambda_i t} \\gamma_i \\ket{v_i}$ (see original paper for a definition of phase shift). This nicely reflects that applying the matrix A to an eigenstate leads to a scaling factor.\nThe main drawback of this encoding is that the depth of the circuit that implements $U$ can be exponential.", "Context": "A matrix $A$ has to be represented on a quantum computer as an operation $U$. \nTherefore, it is not sufficient to represent the entries of the matrix by a data encoding pattern as this does not define an operation.", "Solution": "If $A$ is not Hermitian, encode\n$$H = \\left( \\begin{matrix}0 & A\\\\ A^{\\dagger} & 0 \\end{matrix} \\right) $$\ninstead of A. Since $H$ is hermitian, $U=e^{-iHt}$ is unitary and can be used to encode $H$ where $t$ specifies the time for which the operation is applied (usually $t$ is chosen to be small). ", "Variants": "Enter your input for this section here.", "Known Uses": "This encoding is often used for the simulation of a quantum system, see [[Nielsen and Chuang 2002](https://doi.org/10.1119/1.1463744)] for various examples. The HHL algorithm for solving linear equations~ HHL algorithm [[Harrow, Hassidim and Lloyd 2009](https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.103.150502)] is an example of an algorithm that uses _Matrix Encoding_ in conjunction with _Quantum Phase Estimation_. [Pennylane](https://pennylane.readthedocs.io/en/stable/code/api/pennylane.templates.subroutines.ApproxTimeEvolution.html) provides an implementation for this encoding.\n\n[HHL Algorithm (PlanQK)](https://platform.planqk.de/algorithms/8c6909bd-a258-4702-8356-6ef28321a826/)", "Related Patterns": "This pattern can be used to define a unitary operation as input for [Quantum Phase Estimation](pattern-languages/a4ea9f6c-5b0a-4beb-a056-8b261d96ba80/a4ea9f6c-5b0a-4beb-a056-8b261d96ba80)."}', 'af7780d5-1f97-4536-8da7-4194b093ab1d', 'Weigold, M., et al.: Encoding patterns for quantum algorithms. IET Quant. Comm. 1–12 (2021). https://doi.org/10.1049/qtc2.12032', false, false, 'encoding');
INSERT INTO public.pattern (id, name, uri, content, icon_url, rendered_content, pattern_language_id, paper_ref, deployment_modeling_behavior_pattern, deployment_modeling_structure_pattern, tags) VALUES ('4074490a-4236-49ed-83d1-625ce58e2dbd', 'Hybrid Module', 'https://patternpedia.org/patternLanguages/quantumAlgorithmPatterns/hybridModule', '{"Alias": "–", "Forces": "Quantum algorithms typically require a classical computer for some parts of their computation. This means that they can have multiple quantum and classical parts. For example, VQAs, such as VQE and QAOA, alternate between quantum and classical computations [[Cerezo et al. 2021]](https://doi.org/10.1038/s42254-021-00348-9)[[Weigold et al. 2021]](https://doi.org/10.1007/978-3-030-87568-8_2). Both, the quantum and the classical part, are required for the algorithm to work correctly. This also includes the control flow of the algorithm, which is included in the classical part of the algorithm.\n\n\nIntegrating a quantum algorithm into an application requires the implementation of the entire algorithm. A dedicated interface is required to enable the integration into applications. Deploying the algorithm to a hybrid runtime, which can execute both the quantum and the classical part of the algorithm, even requires both parts to be deployed together.", "Intent": "How can the implementation of a quantum algorithm requiring both classical and quantum computations be packaged so that it can be integrated into applications? ", "Result": "The entire quantum algorithm implementation is packaged as a Hybrid Module. It contains both the quantum and the classical parts, as well as the control flow logic. Hybrid Modules can be used to deploy the algorithm as a standalone service, e.g., in a hybrid runtime environment that can execute both the classical and the quantum part [[Riel 2022]](https://doi.org/10.1109/ESSDERC55479.2022.9947181). Furthermore, a Hybrid Module can be distributed as a library that implements the quantum algorithm and can be integrated into classical applications. It provides an interface for the application to use. To facilitate the integration of a Hybrid Module by problem-domain experts, a [Classical-Quantum Interface](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/8fcca2dc-fca0-47cf-9bd4-038cd2fe8fb8) can be used as the modules’ interface.", "Context": "Quantum algorithms often require classical computation for pre- and post-processing of the quantum computation results [[Leymann and Barzen 2020]](https://doi.org/10.1088/2058-9565/abae7d). This means that almost all quantum algorithms are hybrid. Thus, any implementation of a quantum algorithm has to contain both the quantum and the classical parts for the algorithm to be functional.", "Examples": "–", "Solution": "Package the entire quantum algorithm, i.e., both the quantum parts and the classical parts, as a Hybrid Module. This module can be composed of smaller modules, e.g., [Quantum Modules](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/424c803a-aefb-4b54-8e45-d177fedac893). It also contains the control flow logic to orchestrate the quantum and classical computation. The Hybrid Module should provide an interface that facilitates its integration into applications. This interface should mainly accept the required problem-specific input values, i.e., the problem that should be processed by the algorithm. Moreover, the interface of a Hybrid Module can also allow behavior inputs to the classical as well as quantum computation, similar to the [Quantum Module Templates](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/d5cda8c9-f39b-474a-9032-c17131884975).\n\n![Solution sketch hybrid module](https://raw.githubusercontent.com/PatternAtlas/pattern-atlas-content/7870b15afcae629bfbc0d0022fcb758832b3b8eb/sketches/quantum_computing_patterns/hybrid-module.svg)\n\nAn exemplary sketch of a Hybrid Module is shown in the sketch. It includes the control flow logic and implementations of classical and quantum parts with a loop between quantum and classical computation. The implementation of such a hybrid module can consist of multiple smaller modules, e.g., the three classical and one quantum computation steps shown can each be implemented in a separate module.", "Known Uses": "One concrete example are implementations of Shor’s algorithm [[Shor 1997]](https://doi.org/10.1137/s0097539795293172) which computes the prime factors of the input number. The period-finding calculated on the quantum computer and the classical post-processing performing the continued fraction expansion is packaged as a Hybrid Module in [Amazon Braket](https://docs.aws.amazon.com/braket/latest/developerguide/braket-using.html), [Qiskit](https://qiskit.org/documentation) and [Q#](https://learn.microsoft.com/en-us/azure/quantum/\noverview-what-is-qsharp-and-qdk).\n\n\nOther examples of Hybrid Modules are implementations of VQAs [[Cerezo et al. 2021]](https://doi.org/10.1038/s42254-021-00348-9), e.g., QAOA and VQE implementations for the [Qiskit](https://qiskit.org/documentation) Runtime contain the full quantum algorithm implementation. [[Beisel et al. 2023]](https://doi.org/10.1007/978-3-031-26507-5_35) showcase a service ecosystem enabling a workflow-based composition of Hybrid Modules for VQAs.", "Related Pattern": "The quantum part of the algorithm implementation inside a Hybrid Module can be organized into [Quantum Modules](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/424c803a-aefb-4b54-8e45-d177fedac893) and [Quantum Module Templates](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/d5cda8c9-f39b-474a-9032-c17131884975). To facilitate their integration into applications by problem-domain experts without quantum computing knowledge, the Hybrid Module can expose a problem domain-specific [Classical-Quantum Interface](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/8fcca2dc-fca0-47cf-9bd4-038cd2fe8fb8)."}', 'https://raw.githubusercontent.com/PatternAtlas/pattern-atlas-content/7870b15afcae629bfbc0d0022fcb758832b3b8eb/icons/quantum_computing_patterns/hybrid-module.svg', '{"Alias": "–", "Forces": "Quantum algorithms typically require a classical computer for some parts of their computation. This means that they can have multiple quantum and classical parts. For example, VQAs, such as VQE and QAOA, alternate between quantum and classical computations [[Cerezo et al. 2021]](https://doi.org/10.1038/s42254-021-00348-9)[[Weigold et al. 2021]](https://doi.org/10.1007/978-3-030-87568-8_2). Both, the quantum and the classical part, are required for the algorithm to work correctly. This also includes the control flow of the algorithm, which is included in the classical part of the algorithm.\n\n\nIntegrating a quantum algorithm into an application requires the implementation of the entire algorithm. A dedicated interface is required to enable the integration into applications. Deploying the algorithm to a hybrid runtime, which can execute both the quantum and the classical part of the algorithm, even requires both parts to be deployed together.", "Intent": "How can the implementation of a quantum algorithm requiring both classical and quantum computations be packaged so that it can be integrated into applications? ", "Result": "The entire quantum algorithm implementation is packaged as a Hybrid Module. It contains both the quantum and the classical parts, as well as the control flow logic. Hybrid Modules can be used to deploy the algorithm as a standalone service, e.g., in a hybrid runtime environment that can execute both the classical and the quantum part [[Riel 2022]](https://doi.org/10.1109/ESSDERC55479.2022.9947181). Furthermore, a Hybrid Module can be distributed as a library that implements the quantum algorithm and can be integrated into classical applications. It provides an interface for the application to use. To facilitate the integration of a Hybrid Module by problem-domain experts, a [Classical-Quantum Interface](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/8fcca2dc-fca0-47cf-9bd4-038cd2fe8fb8) can be used as the modules’ interface.", "Context": "Quantum algorithms often require classical computation for pre- and post-processing of the quantum computation results [[Leymann and Barzen 2020]](https://doi.org/10.1088/2058-9565/abae7d). This means that almost all quantum algorithms are hybrid. Thus, any implementation of a quantum algorithm has to contain both the quantum and the classical parts for the algorithm to be functional.", "Examples": "–", "Solution": "Package the entire quantum algorithm, i.e., both the quantum parts and the classical parts, as a Hybrid Module. This module can be composed of smaller modules, e.g., [Quantum Modules](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/424c803a-aefb-4b54-8e45-d177fedac893). It also contains the control flow logic to orchestrate the quantum and classical computation. The Hybrid Module should provide an interface that facilitates its integration into applications. This interface should mainly accept the required problem-specific input values, i.e., the problem that should be processed by the algorithm. Moreover, the interface of a Hybrid Module can also allow behavior inputs to the classical as well as quantum computation, similar to the [Quantum Module Templates](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/d5cda8c9-f39b-474a-9032-c17131884975).\n\n![Solution sketch hybrid module](https://raw.githubusercontent.com/PatternAtlas/pattern-atlas-content/7870b15afcae629bfbc0d0022fcb758832b3b8eb/sketches/quantum_computing_patterns/hybrid-module.svg)\n\nAn exemplary sketch of a Hybrid Module is shown in the sketch. It includes the control flow logic and implementations of classical and quantum parts with a loop between quantum and classical computation. The implementation of such a hybrid module can consist of multiple smaller modules, e.g., the three classical and one quantum computation steps shown can each be implemented in a separate module.", "Known Uses": "One concrete example are implementations of Shor’s algorithm [[Shor 1997]](https://doi.org/10.1137/s0097539795293172) which computes the prime factors of the input number. The period-finding calculated on the quantum computer and the classical post-processing performing the continued fraction expansion is packaged as a Hybrid Module in [Amazon Braket](https://docs.aws.amazon.com/braket/latest/developerguide/braket-using.html), [Qiskit](https://qiskit.org/documentation) and [Q#](https://learn.microsoft.com/en-us/azure/quantum/\noverview-what-is-qsharp-and-qdk).\n\n\nOther examples of Hybrid Modules are implementations of VQAs [[Cerezo et al. 2021]](https://doi.org/10.1038/s42254-021-00348-9), e.g., QAOA and VQE implementations for the [Qiskit](https://qiskit.org/documentation) Runtime contain the full quantum algorithm implementation. [[Beisel et al. 2023]](https://doi.org/10.1007/978-3-031-26507-5_35) showcase a service ecosystem enabling a workflow-based composition of Hybrid Modules for VQAs.", "Related Pattern": "The quantum part of the algorithm implementation inside a Hybrid Module can be organized into [Quantum Modules](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/424c803a-aefb-4b54-8e45-d177fedac893) and [Quantum Module Templates](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/d5cda8c9-f39b-474a-9032-c17131884975). To facilitate their integration into applications by problem-domain experts without quantum computing knowledge, the Hybrid Module can expose a problem domain-specific [Classical-Quantum Interface](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/8fcca2dc-fca0-47cf-9bd4-038cd2fe8fb8)."}', 'af7780d5-1f97-4536-8da7-4194b093ab1d', 'IARIA, 2023', NULL, NULL, 'design');
INSERT INTO public.pattern (id, name, uri, content, icon_url, rendered_content, pattern_language_id, paper_ref, deployment_modeling_behavior_pattern, deployment_modeling_structure_pattern, tags) VALUES ('e595558d-bfea-4b82-9f47-a38a2097b245', 'Angle Encoding', 'https://patternpedia.org/patternLanguages/reformulatedQuantumComputingPatterns/angleEncoding', '{"Alias": "This pattern has also been referred to as Qubit Encoding [(LaRose and Coyle 2020)](https://journals.aps.org/pra/abstract/10.1103/PhysRevA.102.032420) since each qubit represents a single data point.\nThe resulting encoding of this pattern is not entangled, thus, another alias for this pattern is (Tensor) Product Encoding [(Leymann and Barzen 2020)](https://iopscience.iop.org/article/10.1088/2058-9565/abae7d). \n\n", "Intent": "\"Represent each data point by a separate qubit\" [(Weigold et al. 2021)](https://ieeexplore.ieee.org/document/9425837/)\n\n", "Result": "This creates the following separable state ([Weigold et al. 2021](https://ieeexplore.ieee.org/document/9425837/)): \n\n\n$$\n\\newcommand{\\colVec}[1]{% inline column vector\n\\bigl( \\begin{smallmatrix}#1\\end{smallmatrix}\\bigr)\n}\n\\newcommand{\\bigColVec}[1]{% inline column vector\n\\left( \\begin{matrix}#1\\end{matrix}\\right)\n}\n\\newcommand{\\state}[1]{{\\left| #1 \\right>}}\n  \\state{\\psi} = \\bigColVec{\\cos{x_0} \\\\ \\sin{x_0}} \n  \\otimes \\bigColVec{\\cos{x_1} \\\\ \\sin{x_1}} \n  \\otimes \\ldots \n  \\otimes \\bigColVec{\\cos{x_n} \\\\ \\sin{x_n}}\n$$  \n\n\nIt can easily be seen that one qubit is needed per data point which is not optimal. To load the data, the rotations on the qubits can be performed in parallel, thus, the depth of the circuit is optimal. \n\n", "Context": "In the current NISQ era, an algorithm requires an encoding schema that is efficient in terms of operations. \nThis enables to perform more operations within the decoherence time after encoding the data. \n\n", "Solution": "As a first step, each data point of the input is normalized to the interval $[0,\\frac{\\pi}{2}]$.\nTo encode the data points, a rotation around the y-axis is used (see solution sketch) for which the angle depends on the value of the normalized data point. \n\n![sketch](https://quantumcomputingpatterns.org/assets/sketches/angle_encoding_solution.png)\n\nPattern sketch, taken from: Weigold, Manuela; Barzen, Johanna; Leymann, Frank; Salm, Marie: [“Expanding Data Encoding Patterns For Quantum Algorithms.”](https://ieeexplore.ieee.org/document/9425837/) In: 2021 IEEE 18th International Conference on Software Architecture Companion (ICSA-C), IEEE, 2021.\n", "Variants": "A variant of this pattern is presented in [(LaRose and Coyle 2020)](https://journals.aps.org/pra/abstract/10.1103/PhysRevA.102.032420) where the relative phase, another property of qubits, is exploited to produce a more dense encoding which requires only half of the qubits to encode the same amount of data points. \n\n", "Known Uses": "A classification algorithm based on the encoding of this pattern can be found in [(LaRose and Coyle 2020)](https://journals.aps.org/pra/abstract/10.1103/PhysRevA.102.032420) and [(Grant et al. 2018)](https://www.nature.com/articles/s41534-018-0116-9). \nAdditionally, this encoding has been applied in quantum image processing: \nHere, angle encoding is used to represent a pixel''s color information in the flexible representation of quantum image (FRQI) while the position is represented by an additional register [(Yan, Iliyasu and Venegas-Andraca 2015)](https://link.springer.com/content/pdf/10.1007/s11128-015-1195-6.pdf).\nFor quantum neural networks, a so-called quantum neuron (quron) makes use of this encoding [(Schuld, Sinayskiy and Petruccione 2014)](https://link.springer.com/article/10.1007/s11128-014-0809-8).\nA state preparation routine to create this encoding is provided by  [PennyLane](https://pennylane.readthedocs.io/en/stable/introduction/templates.html) where a rotation on the axis x, y, or z can be chosen. \nSince the state preparation is straightforward (see solution sketch), this encoding can easily be implemented using default qubit rotations [(Leymann and Barzen 2020)](https://iopscience.iop.org/article/10.1088/2058-9565/abae7d).\n\n[Quantum Boltzmann Machine (Gate-based) (PlanQK)](https://platform.planqk.de/algorithms/ae9bac80-672e-432a-983f-a3a7e1a8c92c/)\n[Hybrid Transfer Learning (PlanQK)](https://platform.planqk.de/algorithms/2803f6d4-094e-4aa9-b09d-5847fba03d21/)\n[Quantum approximate optimization algorithm (PlanQK)](https://platform.planqk.de/algorithms/fae60bca-d2b6-4aa2-88b7-58caace34179/)\n", "Related Patterns": "As this pattern provides a concrete encoding strategy, it specifies [Initialization](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/312bc9d3-26c0-40ae-b90b-56effd136c0d).\n\n"}', 'https://quantumcomputingpatterns.org/assets/pattern-icons/angle_encoding_icon.png', '{"Alias": "This pattern has also been referred to as Qubit Encoding [(LaRose and Coyle 2020)](https://journals.aps.org/pra/abstract/10.1103/PhysRevA.102.032420) since each qubit represents a single data point.\nThe resulting encoding of this pattern is not entangled, thus, another alias for this pattern is (Tensor) Product Encoding [(Leymann and Barzen 2020)](https://iopscience.iop.org/article/10.1088/2058-9565/abae7d). \n\n", "Intent": "\"Represent each data point by a separate qubit\" [(Weigold et al. 2021)](https://ieeexplore.ieee.org/document/9425837/)\n\n", "Result": "This creates the following separable state ([Weigold et al. 2021](https://ieeexplore.ieee.org/document/9425837/)): \n\n\n$$\n\\newcommand{\\colVec}[1]{% inline column vector\n\\bigl( \\begin{smallmatrix}#1\\end{smallmatrix}\\bigr)\n}\n\\newcommand{\\bigColVec}[1]{% inline column vector\n\\left( \\begin{matrix}#1\\end{matrix}\\right)\n}\n\\newcommand{\\state}[1]{{\\left| #1 \\right>}}\n  \\state{\\psi} = \\bigColVec{\\cos{x_0} \\\\ \\sin{x_0}} \n  \\otimes \\bigColVec{\\cos{x_1} \\\\ \\sin{x_1}} \n  \\otimes \\ldots \n  \\otimes \\bigColVec{\\cos{x_n} \\\\ \\sin{x_n}}\n$$  \n\n\nIt can easily be seen that one qubit is needed per data point which is not optimal. To load the data, the rotations on the qubits can be performed in parallel, thus, the depth of the circuit is optimal. \n\n", "Context": "In the current NISQ era, an algorithm requires an encoding schema that is efficient in terms of operations. \nThis enables to perform more operations within the decoherence time after encoding the data. \n\n", "Solution": "As a first step, each data point of the input is normalized to the interval $[0,\\frac{\\pi}{2}]$.\nTo encode the data points, a rotation around the y-axis is used (see solution sketch) for which the angle depends on the value of the normalized data point. \n\n![sketch](https://quantumcomputingpatterns.org/assets/sketches/angle_encoding_solution.png)\n\nPattern sketch, taken from: Weigold, Manuela; Barzen, Johanna; Leymann, Frank; Salm, Marie: [“Expanding Data Encoding Patterns For Quantum Algorithms.”](https://ieeexplore.ieee.org/document/9425837/) In: 2021 IEEE 18th International Conference on Software Architecture Companion (ICSA-C), IEEE, 2021.\n", "Variants": "A variant of this pattern is presented in [(LaRose and Coyle 2020)](https://journals.aps.org/pra/abstract/10.1103/PhysRevA.102.032420) where the relative phase, another property of qubits, is exploited to produce a more dense encoding which requires only half of the qubits to encode the same amount of data points. \n\n", "Known Uses": "A classification algorithm based on the encoding of this pattern can be found in [(LaRose and Coyle 2020)](https://journals.aps.org/pra/abstract/10.1103/PhysRevA.102.032420) and [(Grant et al. 2018)](https://www.nature.com/articles/s41534-018-0116-9). \nAdditionally, this encoding has been applied in quantum image processing: \nHere, angle encoding is used to represent a pixel''s color information in the flexible representation of quantum image (FRQI) while the position is represented by an additional register [(Yan, Iliyasu and Venegas-Andraca 2015)](https://link.springer.com/content/pdf/10.1007/s11128-015-1195-6.pdf).\nFor quantum neural networks, a so-called quantum neuron (quron) makes use of this encoding [(Schuld, Sinayskiy and Petruccione 2014)](https://link.springer.com/article/10.1007/s11128-014-0809-8).\nA state preparation routine to create this encoding is provided by  [PennyLane](https://pennylane.readthedocs.io/en/stable/introduction/templates.html) where a rotation on the axis x, y, or z can be chosen. \nSince the state preparation is straightforward (see solution sketch), this encoding can easily be implemented using default qubit rotations [(Leymann and Barzen 2020)](https://iopscience.iop.org/article/10.1088/2058-9565/abae7d).\n\n[Quantum Boltzmann Machine (Gate-based) (PlanQK)](https://platform.planqk.de/algorithms/ae9bac80-672e-432a-983f-a3a7e1a8c92c/)\n[Hybrid Transfer Learning (PlanQK)](https://platform.planqk.de/algorithms/2803f6d4-094e-4aa9-b09d-5847fba03d21/)\n[Quantum approximate optimization algorithm (PlanQK)](https://platform.planqk.de/algorithms/fae60bca-d2b6-4aa2-88b7-58caace34179/)\n", "Related Patterns": "As this pattern provides a concrete encoding strategy, it specifies [Initialization](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/312bc9d3-26c0-40ae-b90b-56effd136c0d).\n\n"}', 'af7780d5-1f97-4536-8da7-4194b093ab1d', 'https://ieeexplore.ieee.org/document/9425837/', false, false, 'encoding');
INSERT INTO public.pattern (id, name, uri, content, icon_url, rendered_content, pattern_language_id, paper_ref, deployment_modeling_behavior_pattern, deployment_modeling_structure_pattern, tags) VALUES ('312bc9d3-26c0-40ae-b90b-56effd136c0d', 'Initialization', 'https://patternpedia.org/patternLanguages/reformulatedQuantumComputingPatterns/initialization', '{"Alias": "This pattern has also been referred to as State Preparation. ", "Intent": "Initialize the input of a quantum register, taking into account the prerequisites of the subsequent steps of the algorithm.", "Result": "More advanced states may be prepared which build on the previously described initialization techniques.\nFor example, in [(Cortese and Braje 2018)](https://arxiv.org/abs/1803.01958) various algorithms for loading classical bits into a quantum register are presented.  \nComplex vectors can be loaded as described in [(Nielsen and Chuang 2002)](https://doi.org/10.1119/1.1463744). \n[(Derovic et al. 2018)](https://arxiv.org/abs/1802.08227) describes how a real-valued vector can be loaded; therefore, it is also possible to load a matrix that is represented as a set of vectors [(Kerenidis and Prakash 2016)](https://arxiv.org/abs/1603.08675).", "Context": "Usually, the underlying problem to be solved by a quantum algorithm is represented by specific parameters. \nThese parameters must be given as input data to the algorithm in order to solve the problem.\nIn most algorithms, the process of loading the input data is part of the quantum algorithm itself,  which is defined as a unitary transformation $U$ and measurements.  \nIn this case, the overall algorithm $U = U_n \\circ \\ldots  \\circ U_{i}  \\circ U_{i-1} \\circ \\ldots  \\circ U_1,$  can be split up into two parts. \nThe operators of the first part  $U_1, \\ldots , U_{i-1}$ encode the input data into the quantum register according to a defined encoding,  whereas the operators of the second part $U_i, \\ldots , U_n$ are used to solve the problem.  \nSince $U_{i-1} \\circ  \\ldots  \\circ U_1$ set the register to an initial state, this step is referred to as state preparation.", "Solution": "Frequently, the unit vector $\\left| 0 \\ldots 0\\right>$ is used as initialization of a quantum register.  \nSome qubits of the register can be used as so-called ancilla bits (working qubits) which may be used for the storage of intermediate results or quantum error correction. \nFor example, to compute the function table of a Boolean function $f:\\{0, 1\\}^n \\rightarrow \\{0, 1\\}^m$, the overall register is initialized as $\\left| 0 \\right>^{\\otimes n}\\left| 0 \\right>^{\\otimes m}$ (including $m$ ancilla bits in the second part of the register).  \nTo expose membership in an indicator function-based set (e.g., in decision problems) often an initialization with $\\left| 0 \\right>^{\\otimes n}\\left| 1 \\right>$ is chosen.  \nThe membership to the set is then indicated by changing the sign of the qubits representing members of this set. ", "Variants": "", "Known Uses": "Initialization is the first step in every quantum algorithm.\n\n[Grover''s Algorithm (PlanQK)](https://platform.planqk.de/algorithms/86dfd279-db46-4adb-84a7-39bcf1d19d3a/)\n[Shor''s Algorithm (PlanQK)](https://platform.planqk.de/algorithms/e7413acf-c25e-4de8-ab78-75bfc836a839/)\n[HHL Algorithm (PlanQK)](https://platform.planqk.de/algorithms/8c6909bd-a258-4702-8356-6ef28321a826/)\n", "Related Patterns": "Patterns like [Basis Encoding](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/bcd4c7a1-3c92-4f8c-a530-72b8b95d3750) or [Quantum Associative Memory (QuAM)](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/482714a7-8409-4165-93fe-72b02c2ae99c) further refine [Initialization](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/312bc9d3-26c0-40ae-b90b-56effd136c0d).  \n[Uniform Superposition](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/2229a430-fe92-4411-9d72-d10dd1d8da14) is often used as an initial state.  \nAn initialized register may be used to compute a [Function Table](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/3f3fabf0-7fa7-4b43-a74a-46a7ac2c55ee)."}', 'https://quantumcomputingpatterns.org/assets/pattern-icons/initialization_icon.png', '{"Alias": "This pattern has also been referred to as State Preparation. ", "Intent": "Initialize the input of a quantum register, taking into account the prerequisites of the subsequent steps of the algorithm.", "Result": "More advanced states may be prepared which build on the previously described initialization techniques.\nFor example, in [(Cortese and Braje 2018)](https://arxiv.org/abs/1803.01958) various algorithms for loading classical bits into a quantum register are presented.  \nComplex vectors can be loaded as described in [(Nielsen and Chuang 2002)](https://doi.org/10.1119/1.1463744). \n[(Derovic et al. 2018)](https://arxiv.org/abs/1802.08227) describes how a real-valued vector can be loaded; therefore, it is also possible to load a matrix that is represented as a set of vectors [(Kerenidis and Prakash 2016)](https://arxiv.org/abs/1603.08675).", "Context": "Usually, the underlying problem to be solved by a quantum algorithm is represented by specific parameters. \nThese parameters must be given as input data to the algorithm in order to solve the problem.\nIn most algorithms, the process of loading the input data is part of the quantum algorithm itself,  which is defined as a unitary transformation $U$ and measurements.  \nIn this case, the overall algorithm $U = U_n \\circ \\ldots  \\circ U_{i}  \\circ U_{i-1} \\circ \\ldots  \\circ U_1,$  can be split up into two parts. \nThe operators of the first part  $U_1, \\ldots , U_{i-1}$ encode the input data into the quantum register according to a defined encoding,  whereas the operators of the second part $U_i, \\ldots , U_n$ are used to solve the problem.  \nSince $U_{i-1} \\circ  \\ldots  \\circ U_1$ set the register to an initial state, this step is referred to as state preparation.", "Solution": "Frequently, the unit vector $\\left| 0 \\ldots 0\\right>$ is used as initialization of a quantum register.  \nSome qubits of the register can be used as so-called ancilla bits (working qubits) which may be used for the storage of intermediate results or quantum error correction. \nFor example, to compute the function table of a Boolean function $f:\\{0, 1\\}^n \\rightarrow \\{0, 1\\}^m$, the overall register is initialized as $\\left| 0 \\right>^{\\otimes n}\\left| 0 \\right>^{\\otimes m}$ (including $m$ ancilla bits in the second part of the register).  \nTo expose membership in an indicator function-based set (e.g., in decision problems) often an initialization with $\\left| 0 \\right>^{\\otimes n}\\left| 1 \\right>$ is chosen.  \nThe membership to the set is then indicated by changing the sign of the qubits representing members of this set. ", "Variants": "", "Known Uses": "Initialization is the first step in every quantum algorithm.\n\n[Grover''s Algorithm (PlanQK)](https://platform.planqk.de/algorithms/86dfd279-db46-4adb-84a7-39bcf1d19d3a/)\n[Shor''s Algorithm (PlanQK)](https://platform.planqk.de/algorithms/e7413acf-c25e-4de8-ab78-75bfc836a839/)\n[HHL Algorithm (PlanQK)](https://platform.planqk.de/algorithms/8c6909bd-a258-4702-8356-6ef28321a826/)\n", "Related Patterns": "Patterns like [Basis Encoding](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/bcd4c7a1-3c92-4f8c-a530-72b8b95d3750) or [Quantum Associative Memory (QuAM)](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/482714a7-8409-4165-93fe-72b02c2ae99c) further refine [Initialization](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/312bc9d3-26c0-40ae-b90b-56effd136c0d).  \n[Uniform Superposition](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/2229a430-fe92-4411-9d72-d10dd1d8da14) is often used as an initial state.  \nAn initialized register may be used to compute a [Function Table](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/3f3fabf0-7fa7-4b43-a74a-46a7ac2c55ee)."}', 'af7780d5-1f97-4536-8da7-4194b093ab1d', 'https://link.springer.com/chapter/10.1007/978-3-030-14082-3_19', false, false, 'encoding');
INSERT INTO public.pattern (id, name, uri, content, icon_url, rendered_content, pattern_language_id, paper_ref, deployment_modeling_behavior_pattern, deployment_modeling_structure_pattern, tags) VALUES ('4437fb83-34c0-47a8-8c6f-1272a76b76bb', 'Schmidt Decomposition', 'https://patternpedia.org/patternLanguages/reformulatedQuantumComputingPatterns/schmidtDecomposition', '{"Alias": "", "Intent": "Prepare an arbitrary state", "Result": "The state $\\newcommand{\\state}[1]{{\\left| #1 \\right>}}\\state{s}$ is created in the register. For this state, the Schmidt coefficients $\\alpha_i$ are known which can be used to quantify entanglement [[Nielsen and Chuang 2002](https://doi.org/10.1119/1.1463744)]. The state $\\newcommand{\\state}[1]{{\\left| #1 \\right>}}\\state{s}$ is separable if and only if exactly one of the Schmidt coefficients is non-zero. \nIn the worst case, the depth of the circuit is exponential (more precisely: $\\frac{23}{48} 2^n$ [[Plesch and Brukner 2011](https://journals.aps.org/pra/abstract/10.1103/PhysRevA.83.032302)]).Note that arbitrary state preparation was shown to be of exponential complexity, i.e., a circuit of exponential depth will always be needed in the worst case. ", "Context": "A state $\\newcommand{\\state}[1]{{\\left| #1 \\right>}}\\state{s}$ has to be prepared on an empty $n$-qubit register. If no state preparation method is known that exploits the structure of this state to prepare it efficiently, a method for creating an arbitrary state can be used instead.", "Solution": "To generate a circuit for the creation of $\\newcommand{\\state}[1]{{\\left| #1 \\right>}}\\state{s}$, it first needs to be expressed in terms of two subspaces $V$ and $W$ that span $H^{\\otimes n}$. First, orthogonal basis $\\{f_1, \\ldots, f_k\\}\\in V$ and $\\{g_1, \\ldots, g_k\\}\\in W$ are chosen and $\\ket{s}$ is represented as a linear combination of these basis vectors:\n$$\\newcommand{\\state}[1]{{\\left| #1 \\right>}}\\state{s}=\\sum_{i, j} b_{ij} \\cdot f_i \\otimes g_j $$\nThen, the singular value decomposition (SVD) of the matrix ${M = \\{ b_{ij} \\}}$ is computed (see [[Olver et al. 2006](https://www.springer.com/gp/book/9783319910406)] for detailed instructions): \n $$M= \\left( \\begin{matrix}U_1 U_2 \\end{matrix} \\right)\n \\left( \\begin{matrix}A \\\\ 0 \\end{matrix} \\right) V^* $$\nwhere the matrix $U$ obtained by the SVD is rewritten by $U_1$ and $U_2$. The entries of the diagonal matrix $A$ build the set $\\{\\alpha_1, \\ldots \\alpha_m\\}$ which defines the _Schmidt decomposition_ of $\\newcommand{\\state}[1]{{\\left| #1 \\right>}}\\state{s}$: \n$$\\newcommand{\\state}[1]{{\\left| #1 \\right>}}\\state{s}=\\sum_{i=1}^{m} \\alpha_{i} \\cdot u_i \\otimes v_i, \\alpha_{i} \\in \\mathbb{R} \\geq 0, \\text{where} \\sum_{i=1}^{m} \\alpha_{i} = 1 $$\nwhere $\\alpha_{1}, \\ldots ,\\alpha_{m}$ are the _Schmidt coefficients_ for the _Schmidt basis_ $\\{u_i\\}$, $\\{v_i\\}$. \nThe circuit in the pattern sketch can be used to prepare $\\newcommand{\\state}[1]{{\\left| #1 \\right>}}\\state{s}$ on an empty register [[Abhijith et al. 2018](https://arxiv.org/abs/1804.03719v2)]: First, $B$ transforms the amplitude of the first register to the Schmidt coefficients. \nThen, a series of CNOT operations copies this state to the second register. Finally, $U_1$ and $V$ transform the computational basis states $\\{e_i\\}$ into the Schmidt basis states: \n$$(U_1 \\otimes V) \\sum_{i=1}^{m} \\alpha_i \\cdot e_i \\otimes$$\nFor the execution on a quantum computer, the unitary matrices must be further decomposed into one and two qubit gates.", "Variants": "", "Known Uses": "This pattern can be used to create random states with a controlled amount of entanglement [[Daskin et al.](https://www.worldscientific.com/doi/abs/10.1142/S0219749914500300)]. An implementation in Mathematica was provided in [Iten et al. 2019](https://arxiv.org/abs/1904.01072).", "Related Patterns": "This pattern refines [Initialization](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/312bc9d3-26c0-40ae-b90b-56effd136c0d), and can be used as a state preparation method for [Amplitude](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/502147ec-45fa-403f-8f52-e196b3359399) or [QRAM Encoding](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/d9c57511-1101-4707-99bf-36f43a12cb13)."}', 'https://quantumcomputingpatterns.org/assets/pattern-icons/schmidt_icon.png', '{"Alias": "", "Intent": "Prepare an arbitrary state", "Result": "The state $\\newcommand{\\state}[1]{{\\left| #1 \\right>}}\\state{s}$ is created in the register. For this state, the Schmidt coefficients $\\alpha_i$ are known which can be used to quantify entanglement [[Nielsen and Chuang 2002](https://doi.org/10.1119/1.1463744)]. The state $\\newcommand{\\state}[1]{{\\left| #1 \\right>}}\\state{s}$ is separable if and only if exactly one of the Schmidt coefficients is non-zero. \nIn the worst case, the depth of the circuit is exponential (more precisely: $\\frac{23}{48} 2^n$ [[Plesch and Brukner 2011](https://journals.aps.org/pra/abstract/10.1103/PhysRevA.83.032302)]).Note that arbitrary state preparation was shown to be of exponential complexity, i.e., a circuit of exponential depth will always be needed in the worst case. ", "Context": "A state $\\newcommand{\\state}[1]{{\\left| #1 \\right>}}\\state{s}$ has to be prepared on an empty $n$-qubit register. If no state preparation method is known that exploits the structure of this state to prepare it efficiently, a method for creating an arbitrary state can be used instead.", "Solution": "To generate a circuit for the creation of $\\newcommand{\\state}[1]{{\\left| #1 \\right>}}\\state{s}$, it first needs to be expressed in terms of two subspaces $V$ and $W$ that span $H^{\\otimes n}$. First, orthogonal basis $\\{f_1, \\ldots, f_k\\}\\in V$ and $\\{g_1, \\ldots, g_k\\}\\in W$ are chosen and $\\ket{s}$ is represented as a linear combination of these basis vectors:\n$$\\newcommand{\\state}[1]{{\\left| #1 \\right>}}\\state{s}=\\sum_{i, j} b_{ij} \\cdot f_i \\otimes g_j $$\nThen, the singular value decomposition (SVD) of the matrix ${M = \\{ b_{ij} \\}}$ is computed (see [[Olver et al. 2006](https://www.springer.com/gp/book/9783319910406)] for detailed instructions): \n $$M= \\left( \\begin{matrix}U_1 U_2 \\end{matrix} \\right)\n \\left( \\begin{matrix}A \\\\ 0 \\end{matrix} \\right) V^* $$\nwhere the matrix $U$ obtained by the SVD is rewritten by $U_1$ and $U_2$. The entries of the diagonal matrix $A$ build the set $\\{\\alpha_1, \\ldots \\alpha_m\\}$ which defines the _Schmidt decomposition_ of $\\newcommand{\\state}[1]{{\\left| #1 \\right>}}\\state{s}$: \n$$\\newcommand{\\state}[1]{{\\left| #1 \\right>}}\\state{s}=\\sum_{i=1}^{m} \\alpha_{i} \\cdot u_i \\otimes v_i, \\alpha_{i} \\in \\mathbb{R} \\geq 0, \\text{where} \\sum_{i=1}^{m} \\alpha_{i} = 1 $$\nwhere $\\alpha_{1}, \\ldots ,\\alpha_{m}$ are the _Schmidt coefficients_ for the _Schmidt basis_ $\\{u_i\\}$, $\\{v_i\\}$. \nThe circuit in the pattern sketch can be used to prepare $\\newcommand{\\state}[1]{{\\left| #1 \\right>}}\\state{s}$ on an empty register [[Abhijith et al. 2018](https://arxiv.org/abs/1804.03719v2)]: First, $B$ transforms the amplitude of the first register to the Schmidt coefficients. \nThen, a series of CNOT operations copies this state to the second register. Finally, $U_1$ and $V$ transform the computational basis states $\\{e_i\\}$ into the Schmidt basis states: \n$$(U_1 \\otimes V) \\sum_{i=1}^{m} \\alpha_i \\cdot e_i \\otimes$$\nFor the execution on a quantum computer, the unitary matrices must be further decomposed into one and two qubit gates.", "Variants": "", "Known Uses": "This pattern can be used to create random states with a controlled amount of entanglement [[Daskin et al.](https://www.worldscientific.com/doi/abs/10.1142/S0219749914500300)]. An implementation in Mathematica was provided in [Iten et al. 2019](https://arxiv.org/abs/1904.01072).", "Related Patterns": "This pattern refines [Initialization](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/312bc9d3-26c0-40ae-b90b-56effd136c0d), and can be used as a state preparation method for [Amplitude](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/502147ec-45fa-403f-8f52-e196b3359399) or [QRAM Encoding](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/d9c57511-1101-4707-99bf-36f43a12cb13)."}', 'af7780d5-1f97-4536-8da7-4194b093ab1d', 'Weigold, M., et al.: Encoding patterns for quantum algorithms. IET Quant. Comm. 1–12 (2021). https://doi.org/10.1049/qtc2.12032', false, false, 'encoding');
INSERT INTO public.pattern (id, name, uri, content, icon_url, rendered_content, pattern_language_id, paper_ref, deployment_modeling_behavior_pattern, deployment_modeling_structure_pattern, tags) VALUES ('d4f7c247-e2bb-4301-ad06-f758fa58f2dc', 'Uncompute', 'https://patternpedia.org/patternLanguages/reformulatedQuantumComputingPatterns/uncompute', '{"Alias": "This pattern has also been referred to as Unentangling or Copy-Uncompute.", "Intent": "Remove entanglement that resulted from a previous computation ", "Result": "The resulting register $\\newcommand{\\state}[1]{{\\left| #1 \\right>}} \\state{x} \\state{0} \\state{f(x)}$ contains the input $x$ and the computed function values $f(x)$.  \nThe previous entanglement (caused by the computation) is no longer present.", "Context": "Quantum algorithms often use ancilla qubits as temporary qubits for their computations. \nAfter a computation, these qubits are often still entangled with the computational basis of the quantum register.  \nThis prevents unrestricted access to the results of the computation.  \nThis is especially problematic if the performed calculations are only intermediate steps within a larger algorithm.\nFor example, assume a computation should produce a weighted superposition $\\newcommand{\\state}[1]{{\\left| #1 \\right>}} \\sum \\alpha_i \\state{\\phi_i}$, but produces $\\newcommand{\\state}[1]{{\\left| #1 \\right>}} \\sum \\alpha_i \\state{\\phi_i} \\state{\\psi_i}$ instead, where $\\newcommand{\\state}[1]{{\\left| #1 \\right>}} \\state{\\psi_i}$ denotes the state of the ancilla qubits. \nThe second part of the register containing the ancilla qubits cannot be discarded unless \n\n\n$$\n\\newcommand{\\colVec}[1]{% inline column vector\n\\bigl( \\begin{smallmatrix}#1\\end{smallmatrix}\\bigr)\n}\n\\newcommand{\\bigColVec}[1]{% inline column vector\n\\left( \\begin{matrix}#1\\end{matrix}\\right)\n}\n\\newcommand{\\state}[1]{{\\left| #1 \\right>}}\\sum \\alpha_i \\state{\\phi_i} \\state{\\psi_i} = \\left( \\sum \\alpha_i \\right) \\state{\\phi_i} \\state{\\psi_i}$$\nholds, i.e.,  unless the two parts of the register are separable.", "Solution": "When computing a function $f$, many algorithms map $\\newcommand{\\state}[1]{{\\left| #1 \\right>}} \\state{x}\\state{0}\\state{0}$ to $\\newcommand{\\state}[1]{{\\left| #1 \\right>}} \\state{x}\\state{g(x)}\\state{f(x)}$  [(Derovic et al. 2018)](https://arxiv.org/abs/1802.08227).  \nAs a result, the second part of the register represents a workspace containing the byproduct $g(x)$ of the computation of $f(x)$, which is not needed anymore.  \nThis garbage part of the register has to be reset, especially if the following parts of the algorithm expect a proper initialization of the workspace as $\\newcommand{\\state}[1]{{\\left| #1 \\right>}} \\state{0 \\ldots 0}$.  \nMore specifically,  assume the following state to be the result of the computation $U_f$:\n\n\n$$\n\\newcommand{\\colVec}[1]{% inline column vector\n\\bigl( \\begin{smallmatrix}#1\\end{smallmatrix}\\bigr)\n}\n\\newcommand{\\bigColVec}[1]{% inline column vector\n\\left( \\begin{matrix}#1\\end{matrix}\\right)\n}\n\\newcommand{\\state}[1]{{\\left| #1 \\right>}}\\state{x}\\state{0}\\state{0} \\xrightarrow{U_f} \\sum \\alpha_y \\state{x}\\state{y}\\state{f(x)}$$\n\n\nwith $\\newcommand{\\state}[1]{{\\left| #1 \\right>}} \\state{g(x)} = \\sum \\alpha_y \\state{y}$ being the garbage state.\nThen, a fourth register is added and initialized as $\\newcommand{\\state}[1]{{\\left| #1 \\right>}} \\state{0}$. \nThen, CNOT is applied (bitwise) to this fourth register controlled by the third register containing the actual results of the computation. \nThereby, $f(x)$ is copied to the fourth register which results in $\\newcommand{\\state}[1]{{\\left| #1 \\right>}} \\sum \\alpha_y \\state{x} \\state{y} \\state{f(x)} \\state{f(x)}$.  \nTo reset the potentially entangled first three registers, the inverse operator $U^{-1}_f$ is applied to them, resulting in $\\newcommand{\\state}[1]{{\\left| #1 \\right>}} \\state{x} \\state{0} \\state{0} \\state{f(x)}$.\nBy application of the SWAP operator,  the entries of the last two registers are swapped: $\\newcommand{\\state}[1]{{\\left| #1 \\right>}} \\state{x} \\state{0} \\state{f(x)} \\state{0}$. \nThe fourth register is in the state $\\newcommand{\\state}[1]{{\\left| #1 \\right>}} \\state{0}$ again and can be discarded, leaving $\\newcommand{\\state}[1]{{\\left| #1 \\right>}} \\state{x} \\state{0} \\state{f(x)}$ as final result (see [(Derovic et al. 2018)](https://arxiv.org/abs/1802.08227) for a more detailed description).\nHow a [Uncompute](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/d4f7c247-e2bb-4301-ad06-f758fa58f2dc) operation can be realized in several other situations is described in [(Proos and Zalka 2003)](https://www.researchgate.net/publication/2189624_Shor%27s_Discrete_Logarithm_Quantum_Algorithm_for_Elliptic_Curves).", "Variants": "", "Known Uses": "Several algorithms like the Deutsch-Joza,  the HHL algorithm [(Harrow, Hassidim and Lloyd 2009)](https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.103.150502), and quantum walks make use of [Uncompute](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/d4f7c247-e2bb-4301-ad06-f758fa58f2dc).\n\n[Grover''s Algorithm (PlanQK)](https://platform.planqk.de/algorithms/86dfd279-db46-4adb-84a7-39bcf1d19d3a/)\n[Shor''s Algorithm (PlanQK)](https://platform.planqk.de/algorithms/e7413acf-c25e-4de8-ab78-75bfc836a839/)\n[HHL Algorithm (PlanQK)](https://platform.planqk.de/algorithms/8c6909bd-a258-4702-8356-6ef28321a826/)\n", "Related Patterns": "Applying an [Oracle](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/1cc7e9d6-ab37-412e-8afa-604a25de296e) often results in a state where ancilla qubits are entangled with other qubits, and therefore, requires the application of [Uncompute](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/d4f7c247-e2bb-4301-ad06-f758fa58f2dc). \nA [Function Table](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/3f3fabf0-7fa7-4b43-a74a-46a7ac2c55ee) can show the same behavior as a special case of an oracle."}', 'https://quantumcomputingpatterns.org/assets/pattern-icons/uncompute_icon.png', '{"Alias": "This pattern has also been referred to as Unentangling or Copy-Uncompute.", "Intent": "Remove entanglement that resulted from a previous computation ", "Result": "The resulting register $\\newcommand{\\state}[1]{{\\left| #1 \\right>}} \\state{x} \\state{0} \\state{f(x)}$ contains the input $x$ and the computed function values $f(x)$.  \nThe previous entanglement (caused by the computation) is no longer present.", "Context": "Quantum algorithms often use ancilla qubits as temporary qubits for their computations. \nAfter a computation, these qubits are often still entangled with the computational basis of the quantum register.  \nThis prevents unrestricted access to the results of the computation.  \nThis is especially problematic if the performed calculations are only intermediate steps within a larger algorithm.\nFor example, assume a computation should produce a weighted superposition $\\newcommand{\\state}[1]{{\\left| #1 \\right>}} \\sum \\alpha_i \\state{\\phi_i}$, but produces $\\newcommand{\\state}[1]{{\\left| #1 \\right>}} \\sum \\alpha_i \\state{\\phi_i} \\state{\\psi_i}$ instead, where $\\newcommand{\\state}[1]{{\\left| #1 \\right>}} \\state{\\psi_i}$ denotes the state of the ancilla qubits. \nThe second part of the register containing the ancilla qubits cannot be discarded unless \n\n\n$$\n\\newcommand{\\colVec}[1]{% inline column vector\n\\bigl( \\begin{smallmatrix}#1\\end{smallmatrix}\\bigr)\n}\n\\newcommand{\\bigColVec}[1]{% inline column vector\n\\left( \\begin{matrix}#1\\end{matrix}\\right)\n}\n\\newcommand{\\state}[1]{{\\left| #1 \\right>}}\\sum \\alpha_i \\state{\\phi_i} \\state{\\psi_i} = \\left( \\sum \\alpha_i \\right) \\state{\\phi_i} \\state{\\psi_i}$$\nholds, i.e.,  unless the two parts of the register are separable.", "Solution": "When computing a function $f$, many algorithms map $\\newcommand{\\state}[1]{{\\left| #1 \\right>}} \\state{x}\\state{0}\\state{0}$ to $\\newcommand{\\state}[1]{{\\left| #1 \\right>}} \\state{x}\\state{g(x)}\\state{f(x)}$  [(Derovic et al. 2018)](https://arxiv.org/abs/1802.08227).  \nAs a result, the second part of the register represents a workspace containing the byproduct $g(x)$ of the computation of $f(x)$, which is not needed anymore.  \nThis garbage part of the register has to be reset, especially if the following parts of the algorithm expect a proper initialization of the workspace as $\\newcommand{\\state}[1]{{\\left| #1 \\right>}} \\state{0 \\ldots 0}$.  \nMore specifically,  assume the following state to be the result of the computation $U_f$:\n\n\n$$\n\\newcommand{\\colVec}[1]{% inline column vector\n\\bigl( \\begin{smallmatrix}#1\\end{smallmatrix}\\bigr)\n}\n\\newcommand{\\bigColVec}[1]{% inline column vector\n\\left( \\begin{matrix}#1\\end{matrix}\\right)\n}\n\\newcommand{\\state}[1]{{\\left| #1 \\right>}}\\state{x}\\state{0}\\state{0} \\xrightarrow{U_f} \\sum \\alpha_y \\state{x}\\state{y}\\state{f(x)}$$\n\n\nwith $\\newcommand{\\state}[1]{{\\left| #1 \\right>}} \\state{g(x)} = \\sum \\alpha_y \\state{y}$ being the garbage state.\nThen, a fourth register is added and initialized as $\\newcommand{\\state}[1]{{\\left| #1 \\right>}} \\state{0}$. \nThen, CNOT is applied (bitwise) to this fourth register controlled by the third register containing the actual results of the computation. \nThereby, $f(x)$ is copied to the fourth register which results in $\\newcommand{\\state}[1]{{\\left| #1 \\right>}} \\sum \\alpha_y \\state{x} \\state{y} \\state{f(x)} \\state{f(x)}$.  \nTo reset the potentially entangled first three registers, the inverse operator $U^{-1}_f$ is applied to them, resulting in $\\newcommand{\\state}[1]{{\\left| #1 \\right>}} \\state{x} \\state{0} \\state{0} \\state{f(x)}$.\nBy application of the SWAP operator,  the entries of the last two registers are swapped: $\\newcommand{\\state}[1]{{\\left| #1 \\right>}} \\state{x} \\state{0} \\state{f(x)} \\state{0}$. \nThe fourth register is in the state $\\newcommand{\\state}[1]{{\\left| #1 \\right>}} \\state{0}$ again and can be discarded, leaving $\\newcommand{\\state}[1]{{\\left| #1 \\right>}} \\state{x} \\state{0} \\state{f(x)}$ as final result (see [(Derovic et al. 2018)](https://arxiv.org/abs/1802.08227) for a more detailed description).\nHow a [Uncompute](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/d4f7c247-e2bb-4301-ad06-f758fa58f2dc) operation can be realized in several other situations is described in [(Proos and Zalka 2003)](https://www.researchgate.net/publication/2189624_Shor%27s_Discrete_Logarithm_Quantum_Algorithm_for_Elliptic_Curves).", "Variants": "", "Known Uses": "Several algorithms like the Deutsch-Joza,  the HHL algorithm [(Harrow, Hassidim and Lloyd 2009)](https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.103.150502), and quantum walks make use of [Uncompute](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/d4f7c247-e2bb-4301-ad06-f758fa58f2dc).\n\n[Grover''s Algorithm (PlanQK)](https://platform.planqk.de/algorithms/86dfd279-db46-4adb-84a7-39bcf1d19d3a/)\n[Shor''s Algorithm (PlanQK)](https://platform.planqk.de/algorithms/e7413acf-c25e-4de8-ab78-75bfc836a839/)\n[HHL Algorithm (PlanQK)](https://platform.planqk.de/algorithms/8c6909bd-a258-4702-8356-6ef28321a826/)\n", "Related Patterns": "Applying an [Oracle](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/1cc7e9d6-ab37-412e-8afa-604a25de296e) often results in a state where ancilla qubits are entangled with other qubits, and therefore, requires the application of [Uncompute](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/d4f7c247-e2bb-4301-ad06-f758fa58f2dc). \nA [Function Table](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/3f3fabf0-7fa7-4b43-a74a-46a7ac2c55ee) can show the same behavior as a special case of an oracle."}', 'af7780d5-1f97-4536-8da7-4194b093ab1d', 'https://link.springer.com/chapter/10.1007/978-3-030-14082-3_19', false, false, 'circuit-level');
INSERT INTO public.pattern (id, name, uri, content, icon_url, rendered_content, pattern_language_id, paper_ref, deployment_modeling_behavior_pattern, deployment_modeling_structure_pattern, tags) VALUES ('bcd4c7a1-3c92-4f8c-a530-72b8b95d3750', 'Basis Encoding', 'https://patternpedia.org/patternLanguages/reformulatedQuantumComputingPatterns/basisEncoding', '{"Alias": "Enter your input for this section here.", "Intent": "Represent data elements in a quantum computer in order to perform calculations", "Result": "This encoding can be categorized as digital encoding because it is suitable for arithmetic computations [Leymann and Barzen 2020](http://iopscience.iop.org/10.1088/2058-9565/abae7d). For input numbers which are approximated by $l$ digits, $l$ qubits are needed for its representation. To realize this encoding, the initial $|0\\rangle$ state of qubits that represent a ’1’ digit must be flipped into $|1\\rangle$. For one qubit, this can be done by a single operation, and thus, this encoding can be prepared in linear time.", "Context": "A quantum algorithm requires numerical input data $X$ for further calculations", "Solution": "The main idea for this encoding is to use the computational basis $|0...00\\rangle, |0...01\\rangle, \\ldots, |1...11\\rangle$ to encode the input data:  An input number $x$ is approximated by a binary format $x := b_{n-1}\\ldots b_1 b_0$ which is then turned into the corresponding basis vector $|x \\rangle:=|b_{n-1} \\ldots b_1 b_0\\rangle$.  For example, the number \\\"2\\\" is represented as $10$ which is then encoded by $|10\\rangle$ (see sketch). In general, this leads to the following encoding: $X \\approx \\sum_{i=-k}^m b_{i} 2^i \\mapsto | b_m \\ldots b_{-k} \\rangle$ where $X$ is first approximated  with a precision of $k$ significant digits and then represented by a basis vector. \n\n![](https://quantumcomputingpatterns.org/assets/sketches/basis_encoding_solution.png)  \n\nPattern sketch, taken from: Weigold, Manuela; Barzen, Johanna; Leymann, Frank; Salm, Marie: [Data Encoding Patterns for Quantum Algorithms.](https://hillside.net/plop/2020/papers/weigold.pdf) In: The Hillside Group (Hrsg): Proceedings of the 27th Conference on Pattern Languages of Programs (PLoP ''20).", "Variants": "Enter your input for this section here.", "Known Uses": "[(Vedral et al. 1996)](http://dx.doi.org/10.1103/PhysRevA.54.147) give multiple examples for algorithms that perform arithmetic operations on numbers in [Basis Encoding](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/bcd4c7a1-3c92-4f8c-a530-72b8b95d3750). A formal description of the solution above is also given in [(Leymann and Barzen 2020)](http://iopscience.iop.org/10.1088/2058-9565/abae7d) and [(Cortese and Braje 2018)](https://arxiv.org/abs/1803.01958). As only one quantum gate is needed to obtain this encoding, this state preparation routine can be implemented straightforwardly.", "Related Patterns": "This pattern is a refinement of [Initialization](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/312bc9d3-26c0-40ae-b90b-56effd136c0d). If an algorithm requires several numbers as input, each can be encoded in BASIC ENCODING which can be processed by the [Quantum Associative Memory (QuAM)](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/482714a7-8409-4165-93fe-72b02c2ae99c) pattern."}', 'https://quantumcomputingpatterns.org/assets/pattern-icons/basis_encoding_icon.png', '{"Alias": "Enter your input for this section here.", "Intent": "Represent data elements in a quantum computer in order to perform calculations", "Result": "This encoding can be categorized as digital encoding because it is suitable for arithmetic computations [Leymann and Barzen 2020](http://iopscience.iop.org/10.1088/2058-9565/abae7d). For input numbers which are approximated by $l$ digits, $l$ qubits are needed for its representation. To realize this encoding, the initial $|0\\rangle$ state of qubits that represent a ’1’ digit must be flipped into $|1\\rangle$. For one qubit, this can be done by a single operation, and thus, this encoding can be prepared in linear time.", "Context": "A quantum algorithm requires numerical input data $X$ for further calculations", "Solution": "The main idea for this encoding is to use the computational basis $|0...00\\rangle, |0...01\\rangle, \\ldots, |1...11\\rangle$ to encode the input data:  An input number $x$ is approximated by a binary format $x := b_{n-1}\\ldots b_1 b_0$ which is then turned into the corresponding basis vector $|x \\rangle:=|b_{n-1} \\ldots b_1 b_0\\rangle$.  For example, the number \\\"2\\\" is represented as $10$ which is then encoded by $|10\\rangle$ (see sketch). In general, this leads to the following encoding: $X \\approx \\sum_{i=-k}^m b_{i} 2^i \\mapsto | b_m \\ldots b_{-k} \\rangle$ where $X$ is first approximated  with a precision of $k$ significant digits and then represented by a basis vector. \n\n![](https://quantumcomputingpatterns.org/assets/sketches/basis_encoding_solution.png)  \n\nPattern sketch, taken from: Weigold, Manuela; Barzen, Johanna; Leymann, Frank; Salm, Marie: [Data Encoding Patterns for Quantum Algorithms.](https://hillside.net/plop/2020/papers/weigold.pdf) In: The Hillside Group (Hrsg): Proceedings of the 27th Conference on Pattern Languages of Programs (PLoP ''20).", "Variants": "Enter your input for this section here.", "Known Uses": "[(Vedral et al. 1996)](http://dx.doi.org/10.1103/PhysRevA.54.147) give multiple examples for algorithms that perform arithmetic operations on numbers in [Basis Encoding](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/bcd4c7a1-3c92-4f8c-a530-72b8b95d3750). A formal description of the solution above is also given in [(Leymann and Barzen 2020)](http://iopscience.iop.org/10.1088/2058-9565/abae7d) and [(Cortese and Braje 2018)](https://arxiv.org/abs/1803.01958). As only one quantum gate is needed to obtain this encoding, this state preparation routine can be implemented straightforwardly.", "Related Patterns": "This pattern is a refinement of [Initialization](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/312bc9d3-26c0-40ae-b90b-56effd136c0d). If an algorithm requires several numbers as input, each can be encoded in BASIC ENCODING which can be processed by the [Quantum Associative Memory (QuAM)](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/482714a7-8409-4165-93fe-72b02c2ae99c) pattern."}', 'af7780d5-1f97-4536-8da7-4194b093ab1d', 'Weigold, M.; Barzen, J.; Leymann, F.; Salm, M.: Data Encoding Patterns for Quantum Algorithms. In: The Hillside Group (Hrsg): Proceedings of the 27th Conference on Pattern Languages of Programs (PLoP ''20), https://hillside.net/plop/2020/papers/weigold.pdf', false, false, 'encoding');
INSERT INTO public.pattern (id, name, uri, content, icon_url, rendered_content, pattern_language_id, paper_ref, deployment_modeling_behavior_pattern, deployment_modeling_structure_pattern, tags) VALUES ('3d1f3991-df47-4d42-8f9a-e6dcf4e3ccec', 'Creating Entanglement', 'https://patternpedia.org/patternLanguages/reformulatedQuantumComputingPatterns/creatingEntanglement', '{"Alias": "", "Intent": "Enforce a strong correlation between qubits by entangling them.", "Result": "Unitary transformations that create entanglement must include multi-qubit operators such as CNOT.  \nSuch operators typically have a lower gate fidelity than single qubit operators and therefore increase the overall gate error.", "Context": "Entanglement is a unique characteristic of quantum mechanics and one of the causes for the power of quantum algorithms [(Bruß and Macchiavello 2011)](https://journals.aps.org/pra/abstract/10.1103/PhysRevA.83.052313). \nAlthough entanglement is not necessarily needed for a powerful quantum algorithm [(Biham et al. 2004)](https://www.sciencedirect.com/science/article/pii/S0304397504001926), it is required to achieve an exponential speedup over classical algorithms [(Jozsa and Linden 2003)](https://royalsocietypublishing.org/doi/abs/10.1098/rspa.2002.1097).  \nConsequently, a quantum register is often entangled for further processing after the [Initialization](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/312bc9d3-26c0-40ae-b90b-56effd136c0d).", "Solution": "There exist numerous approaches for the creation of an entangled state.\nFor example, entanglement can be created by a Boolean function $f:\\{0, 1\\}^n \\rightarrow \\{0, 1\\}^m$, a corresponding unitary operation\n\n\n$$\n\\newcommand{\\colVec}[1]{% inline column vector\n\\bigl( \\begin{smallmatrix}#1\\end{smallmatrix}\\bigr)\n}\n\\newcommand{\\bigColVec}[1]{% inline column vector\n\\left( \\begin{matrix}#1\\end{matrix}\\right)\n}\n\\newcommand{\\state}[1]{{\\left| #1 \\right>}}U_f: \\{0, 1\\}^{n+m} \\rightarrow \\{0, 1\\}^{n+m}, U_f \\left(\\left| x,y \\right> \\right) =  \\left| x,y\\oplus f(x) \\right>$$ \nand a [Uniform Superposition](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/2229a430-fe92-4411-9d72-d10dd1d8da14) in the first $n$ qubits of the quantum register:\n\n\n$$\n\\newcommand{\\colVec}[1]{% inline column vector\n\\bigl( \\begin{smallmatrix}#1\\end{smallmatrix}\\bigr)\n}\n\\newcommand{\\bigColVec}[1]{% inline column vector\n\\left( \\begin{matrix}#1\\end{matrix}\\right)\n}\n\\newcommand{\\state}[1]{{\\left| #1 \\right>}}U_f \\left(H^{\\otimes n} \\otimes I^{\\otimes m} \\right) \\left( \\left| 0 \\right>^{\\otimes n} \\otimes \\left|0 \\right> ^{\\otimes m} \\right) $$ \n\n\n$$\n\\newcommand{\\colVec}[1]{% inline column vector\n\\bigl( \\begin{smallmatrix}#1\\end{smallmatrix}\\bigr)\n}\n\\newcommand{\\bigColVec}[1]{% inline column vector\n\\left( \\begin{matrix}#1\\end{matrix}\\right)\n}\n\\newcommand{\\state}[1]{{\\left| #1 \\right>}}= U_f \\left( \\dfrac{1}{\\sqrt{2^n}} \\sum_{x=0}^{2^n-1} \\left|x \\right> \\otimes \\state{0}^{\\otimes m} \\right) $$\nThe resulting state is entangled.\nFor $f = id$, $U_{f}=CNOT$ and consequently $CNOT \\left(H \\otimes I \\right) \\left( \\left| 0 \\right> \\otimes \\left|0 \\right> \\right)$ is entangled.\n\n", "Variants": "", "Known Uses": "Most algorithms use entangled states.\nA [Function Table](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/3f3fabf0-7fa7-4b43-a74a-46a7ac2c55ee) may create an entangled state, by making use of the above-defined unitary operation $U_f$ of a Boolean function $f$.\n\n[Quantum Phase Estimation (PlanQK)](https://platform.planqk.de/algorithms/ba4c50e3-7429-4471-a250-1762ed4c556a/)\n[Grover''s Algorithm (PlanQK)](https://platform.planqk.de/algorithms/86dfd279-db46-4adb-84a7-39bcf1d19d3a/)\n[Deutsch algorithm (PlanQK)](https://platform.planqk.de/algorithms/533c90a5-5fbb-487b-b64d-a8f331aafb10/)\n", "Related Patterns": "A quantum register must make use of [Initialization](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/312bc9d3-26c0-40ae-b90b-56effd136c0d) before entanglement can be created.\nApplying $U_{f}$ as described above computes a [Function Table](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/3f3fabf0-7fa7-4b43-a74a-46a7ac2c55ee) and makes use of [Uniform Superposition](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/2229a430-fe92-4411-9d72-d10dd1d8da14)."}', 'https://quantumcomputingpatterns.org/assets/pattern-icons/entanglement_icon.png', '{"Alias": "", "Intent": "Enforce a strong correlation between qubits by entangling them.", "Result": "Unitary transformations that create entanglement must include multi-qubit operators such as CNOT.  \nSuch operators typically have a lower gate fidelity than single qubit operators and therefore increase the overall gate error.", "Context": "Entanglement is a unique characteristic of quantum mechanics and one of the causes for the power of quantum algorithms [(Bruß and Macchiavello 2011)](https://journals.aps.org/pra/abstract/10.1103/PhysRevA.83.052313). \nAlthough entanglement is not necessarily needed for a powerful quantum algorithm [(Biham et al. 2004)](https://www.sciencedirect.com/science/article/pii/S0304397504001926), it is required to achieve an exponential speedup over classical algorithms [(Jozsa and Linden 2003)](https://royalsocietypublishing.org/doi/abs/10.1098/rspa.2002.1097).  \nConsequently, a quantum register is often entangled for further processing after the [Initialization](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/312bc9d3-26c0-40ae-b90b-56effd136c0d).", "Solution": "There exist numerous approaches for the creation of an entangled state.\nFor example, entanglement can be created by a Boolean function $f:\\{0, 1\\}^n \\rightarrow \\{0, 1\\}^m$, a corresponding unitary operation\n\n\n$$\n\\newcommand{\\colVec}[1]{% inline column vector\n\\bigl( \\begin{smallmatrix}#1\\end{smallmatrix}\\bigr)\n}\n\\newcommand{\\bigColVec}[1]{% inline column vector\n\\left( \\begin{matrix}#1\\end{matrix}\\right)\n}\n\\newcommand{\\state}[1]{{\\left| #1 \\right>}}U_f: \\{0, 1\\}^{n+m} \\rightarrow \\{0, 1\\}^{n+m}, U_f \\left(\\left| x,y \\right> \\right) =  \\left| x,y\\oplus f(x) \\right>$$ \nand a [Uniform Superposition](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/2229a430-fe92-4411-9d72-d10dd1d8da14) in the first $n$ qubits of the quantum register:\n\n\n$$\n\\newcommand{\\colVec}[1]{% inline column vector\n\\bigl( \\begin{smallmatrix}#1\\end{smallmatrix}\\bigr)\n}\n\\newcommand{\\bigColVec}[1]{% inline column vector\n\\left( \\begin{matrix}#1\\end{matrix}\\right)\n}\n\\newcommand{\\state}[1]{{\\left| #1 \\right>}}U_f \\left(H^{\\otimes n} \\otimes I^{\\otimes m} \\right) \\left( \\left| 0 \\right>^{\\otimes n} \\otimes \\left|0 \\right> ^{\\otimes m} \\right) $$ \n\n\n$$\n\\newcommand{\\colVec}[1]{% inline column vector\n\\bigl( \\begin{smallmatrix}#1\\end{smallmatrix}\\bigr)\n}\n\\newcommand{\\bigColVec}[1]{% inline column vector\n\\left( \\begin{matrix}#1\\end{matrix}\\right)\n}\n\\newcommand{\\state}[1]{{\\left| #1 \\right>}}= U_f \\left( \\dfrac{1}{\\sqrt{2^n}} \\sum_{x=0}^{2^n-1} \\left|x \\right> \\otimes \\state{0}^{\\otimes m} \\right) $$\nThe resulting state is entangled.\nFor $f = id$, $U_{f}=CNOT$ and consequently $CNOT \\left(H \\otimes I \\right) \\left( \\left| 0 \\right> \\otimes \\left|0 \\right> \\right)$ is entangled.\n\n", "Variants": "", "Known Uses": "Most algorithms use entangled states.\nA [Function Table](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/3f3fabf0-7fa7-4b43-a74a-46a7ac2c55ee) may create an entangled state, by making use of the above-defined unitary operation $U_f$ of a Boolean function $f$.\n\n[Quantum Phase Estimation (PlanQK)](https://platform.planqk.de/algorithms/ba4c50e3-7429-4471-a250-1762ed4c556a/)\n[Grover''s Algorithm (PlanQK)](https://platform.planqk.de/algorithms/86dfd279-db46-4adb-84a7-39bcf1d19d3a/)\n[Deutsch algorithm (PlanQK)](https://platform.planqk.de/algorithms/533c90a5-5fbb-487b-b64d-a8f331aafb10/)\n", "Related Patterns": "A quantum register must make use of [Initialization](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/312bc9d3-26c0-40ae-b90b-56effd136c0d) before entanglement can be created.\nApplying $U_{f}$ as described above computes a [Function Table](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/3f3fabf0-7fa7-4b43-a74a-46a7ac2c55ee) and makes use of [Uniform Superposition](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/2229a430-fe92-4411-9d72-d10dd1d8da14)."}', 'af7780d5-1f97-4536-8da7-4194b093ab1d', 'https://link.springer.com/chapter/10.1007/978-3-030-14082-3_19', false, false, 'circuit-level');
INSERT INTO public.pattern (id, name, uri, content, icon_url, rendered_content, pattern_language_id, paper_ref, deployment_modeling_behavior_pattern, deployment_modeling_structure_pattern, tags) VALUES ('1a5e3708-da39-4356-ab3f-115264da6390', 'Error Correction', 'https://patternpedia.org/patternLanguages/quantumAlgorithmPatterns/errorCorrectionPattern', '{"Alias": "Enter your input for this section here.", "Forces": "Quantum devices unavoidably cause a certain amount of errors due to the fragility of coherent quantum states [[Devitt et al. 2013](https://iopscience.iop.org/article/10.1088/0034-4885/76/7/076001/meta)]. Furthermore, contrary to classical bits, qubits can not be copied. Hence, classical error correction can\nnot be used for quantum computers and new quantum-specific methods need to be developed. However, these methods can be costly in terms of quantum resources, as they require a large number of additional qubits and quantum gates.\nTo enable scalable quantum computing for real-world problems, all kinds of errors occurring in quantum devices need to be detected and corrected. In general, the correction of errors is preferred over their mitigation, since even minor remaining post-mitigation errors slowly stack up during the computation and ultimately lead to an imprecise result.", "Intent": "How to detect and correct errors occurring during the execution of a quantum circuit?", "Result": "When applying quantum error correction, computational errors can be prevented, enabling error-free systems of logical qubits. Thus, error correction is making fault-tolerant quantum computation feasible. The good scalability of error correction, enables the accurate execution of large algorithms", "Context": "A quantum algorithm needs to be run on a quantum device. The quantum device’s performance is limited by various error sources, such as gate errors and crosstalk. The prevention of these errors enables the execution of large-scale quantum algorithms for real-world problems.", "Examples": "The figure below illustrates the application of a 3-qubit variant of the aforementioned error code for multiple qubits. Each of the physical qubits P1 to P4 is transformed into a logical qubit consisting of five physical qubits. Three of these five physical qubits are being used as data qubits and two of them are being used for the detection and recovery process. Further, the 1- and 2-qubit gates G1 to G4 need to be realized by the subroutines S1 to S4, which prepare the data qubits. The resulting errors can then be corrected by individually applying error correction routines for each of the logical qubits.\n![](https://quantumcomputingpatterns.org/assets/sketches/error-correction-example-1.svg)", "Solution": "Detect and correct quantum errors using quantum error correction codes [[Devitt et al. 2013](https://iopscience.iop.org/article/10.1088/0034-4885/76/7/076001/meta)]., which are added to the executed circuit. With these correction codes, many physical qubits are combined into one logical qubit. As a result of\nthis bundling, errors in the original qubit can be first detected and then corrected. The figure below depicts a solution sketch showcasing the general building blocks of a quantum error correction procedure. The shown instance applies an error correction code that can detect and fix bit-flip errors in the computational basis. For the correction of errors from other sources, similar processes can be applied. First, the ancilla coupling is created, by encoding the state $\\ket{\\psi}$ of a single physical qubit into multiple ancilla qubits. These qubits now hold the logical qubit’s data and are called data qubits in the following. Next, some unitary transformation is applied to the logical qubit, possibly resulting in an error. In order to detect an error, additional ancilla qubits are employed to check the parity of the data qubits. Based on the discovered syndrome, the error-free state can be recovered in the recovery phase. Note that the process is assumed to only have errors at the unitary transformation step, which is denoted by the error indicator. Further, the number and type of detectable errors depends on the applied error correction code.\n![](https://quantumcomputingpatterns.org/assets/sketches/error-correction-solution-sketch.svg)", "Known Uses": "Known Uses: [Laflamme et al.](https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.77.198) show a 5-qubit error correction code that can protect a qubit against general 1-qubit errors. Shor’s 9-qubit code can protect a qubit against single bit-flip and phase-flip errors [[Shor 1995]](https://journals.aps.org/pra/abstract/10.1103/PhysRevA.52.R2493). Further, a variety of different quantum error correction codes have been presented in the literature [[Devitt et al. 2013](https://iopscience.iop.org/article/10.1088/0034-4885/76/7/076001/meta)], [[Cai et al. 2021]](https://www.sciencedirect.com/science/article/pii/S2667325820300145), [[Gottesman et al. 1997]](https://arxiv.org/pdf/quant-ph/9705052.pdf), [[Roffe 2019]](https://www.tandfonline.com/doi/full/10.1080/00107514.2019.1667078)", "Related Pattern": "Enter your input for this section here."}', 'https://quantumcomputingpatterns.org/assets/pattern-icons/error_correction_icon.png', '{"Alias": "Enter your input for this section here.", "Forces": "Quantum devices unavoidably cause a certain amount of errors due to the fragility of coherent quantum states [[Devitt et al. 2013](https://iopscience.iop.org/article/10.1088/0034-4885/76/7/076001/meta)]. Furthermore, contrary to classical bits, qubits can not be copied. Hence, classical error correction can\nnot be used for quantum computers and new quantum-specific methods need to be developed. However, these methods can be costly in terms of quantum resources, as they require a large number of additional qubits and quantum gates.\nTo enable scalable quantum computing for real-world problems, all kinds of errors occurring in quantum devices need to be detected and corrected. In general, the correction of errors is preferred over their mitigation, since even minor remaining post-mitigation errors slowly stack up during the computation and ultimately lead to an imprecise result.", "Intent": "How to detect and correct errors occurring during the execution of a quantum circuit?", "Result": "When applying quantum error correction, computational errors can be prevented, enabling error-free systems of logical qubits. Thus, error correction is making fault-tolerant quantum computation feasible. The good scalability of error correction, enables the accurate execution of large algorithms", "Context": "A quantum algorithm needs to be run on a quantum device. The quantum device’s performance is limited by various error sources, such as gate errors and crosstalk. The prevention of these errors enables the execution of large-scale quantum algorithms for real-world problems.", "Examples": "The figure below illustrates the application of a 3-qubit variant of the aforementioned error code for multiple qubits. Each of the physical qubits P1 to P4 is transformed into a logical qubit consisting of five physical qubits. Three of these five physical qubits are being used as data qubits and two of them are being used for the detection and recovery process. Further, the 1- and 2-qubit gates G1 to G4 need to be realized by the subroutines S1 to S4, which prepare the data qubits. The resulting errors can then be corrected by individually applying error correction routines for each of the logical qubits.\n![](https://quantumcomputingpatterns.org/assets/sketches/error-correction-example-1.svg)", "Solution": "Detect and correct quantum errors using quantum error correction codes [[Devitt et al. 2013](https://iopscience.iop.org/article/10.1088/0034-4885/76/7/076001/meta)]., which are added to the executed circuit. With these correction codes, many physical qubits are combined into one logical qubit. As a result of\nthis bundling, errors in the original qubit can be first detected and then corrected. The figure below depicts a solution sketch showcasing the general building blocks of a quantum error correction procedure. The shown instance applies an error correction code that can detect and fix bit-flip errors in the computational basis. For the correction of errors from other sources, similar processes can be applied. First, the ancilla coupling is created, by encoding the state $\\ket{\\psi}$ of a single physical qubit into multiple ancilla qubits. These qubits now hold the logical qubit’s data and are called data qubits in the following. Next, some unitary transformation is applied to the logical qubit, possibly resulting in an error. In order to detect an error, additional ancilla qubits are employed to check the parity of the data qubits. Based on the discovered syndrome, the error-free state can be recovered in the recovery phase. Note that the process is assumed to only have errors at the unitary transformation step, which is denoted by the error indicator. Further, the number and type of detectable errors depends on the applied error correction code.\n![](https://quantumcomputingpatterns.org/assets/sketches/error-correction-solution-sketch.svg)", "Known Uses": "Known Uses: [Laflamme et al.](https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.77.198) show a 5-qubit error correction code that can protect a qubit against general 1-qubit errors. Shor’s 9-qubit code can protect a qubit against single bit-flip and phase-flip errors [[Shor 1995]](https://journals.aps.org/pra/abstract/10.1103/PhysRevA.52.R2493). Further, a variety of different quantum error correction codes have been presented in the literature [[Devitt et al. 2013](https://iopscience.iop.org/article/10.1088/0034-4885/76/7/076001/meta)], [[Cai et al. 2021]](https://www.sciencedirect.com/science/article/pii/S2667325820300145), [[Gottesman et al. 1997]](https://arxiv.org/pdf/quant-ph/9705052.pdf), [[Roffe 2019]](https://www.tandfonline.com/doi/full/10.1080/00107514.2019.1667078)", "Related Pattern": "Enter your input for this section here."}', 'af7780d5-1f97-4536-8da7-4194b093ab1d', 'https://www.thinkmind.org/index.php?view=article&articleid=patterns_2022_2_10_70007', false, false, 'augmentation');
INSERT INTO public.pattern (id, name, uri, content, icon_url, rendered_content, pattern_language_id, paper_ref, deployment_modeling_behavior_pattern, deployment_modeling_structure_pattern, tags) VALUES ('5479acf4-0588-49af-a6a9-4956b7ee32af', 'Quantum Kernel Estimator (QKE)', 'https://patternpedia.org/patternLanguages/reformulatedQuantumComputingPatterns/quantumKernelEstimator(qke)', '{"Alias": "", "Intent": " Use a quantum routine to estimate a kernel for a classical SVM.\n\n", "Result": "Both the training as well as the classification is efficient, given that the evaluation of the inner products can be done in an efficient manner. \nThe main advantage of this setup is that the quantum computer has the potential to compute inner products in a feature space that cannot be evaluated efficiently on a classical computer.\nStill, a key open question regarding this setup remains how to choose a feature map for a given data set. \n\n", "Context": "A support vector machine (SVM) must be found to classify a set of data points $\\{x_i\\}\\subseteq \\mathcal{R}^d$ according to their labels. \nTherefore, a hyperplane must be found that (i) separates the data points of the different classes and (ii) maintains a maximal distance to the data points. \nA large margin between the hyperplane and the data points ensures that unseen data points are classified correctly with a high probability.\nThe given data set is not guaranteed to be linearly separable, and thus, it may not be possible to find such a separating hyperplane in the original space.\nIf this is the case, a hyperplane in a higher dimensional feature space to which the data points are mapped (implicitly) can be used instead. \n\n", "Solution": "To find a separating hyperplane, a quantum computer is used to estimate the kernel function $K(x,x'')=|\\left<\\phi(x)|\\phi(x'')\\right>|^2$: \nA pair of data points $(x,x'')$ is encoded into the Hilbert Space according to a quantum feature map $\\phi$ (see solution sketch). \nThis allows to use, e.g., a SWAP test routine to estimate the inner product $\\left<\\phi(x)|\\phi(x'')\\right>$ of the two points [(Schuld and Killoran)](https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.122.040504)\nThe result can then be used to compute the kernel function for this pair of data points, based on which the SVM is optimized on a classical computer. \n\n\n![Sketch](https://quantumcomputingpatterns.org/assets/sketches/qke_solution.png)\n\nPattern sketch, taken from: Weigold, Manuela; Barzen, Johanna; Leymann, Frank; and Vietz, Daniel: [Patterns For Hybrid Quantum Algorithms.](https://doi.org/10.1007/978-3-030-87568-8_2) In: Proceedings of the 15th Symposium and Summer School on Service-Oriented Computing (SummerSOC 2021).", "Variants": "", "Known Uses": "The solution above was first proposed in [(Havlíček et al. 2019)](https://www.nature.com/articles/s41586-019-0980-2) where it was also demonstrated in an experiment involving two qubits. \nIndependently, the same solution was developed in [(Schuld and Killoran 2019)](https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.122.040504) which additionally presents a feature map targeted for quantum devices based on continuous-variable qubits. \nAnother proof-of-principle demonstration was conducted by [(Bartkiewicz et al. 2020)](https://www.nature.com/articles/s41598-020-68911-5) using photonic qubits. \nThis approach was also further investigated in [(Ghobadi, Oberoi and Zahedinejad 2019)](https://www.researchgate.net/publication/332897448_The_Power_of_One_Qubit_in_Machine_Learning).\nIn our [QHAna](https://github.com/UST-QuAntiL/qhana) project [(Barzen 2021)](https://arxiv.org/abs/2103.11825), we also provide an implementation of this pattern along with a user interface to select one of various quantum feature maps.", "Related Patterns": "This pattern is a refinement of the [Quantum-Classic Split](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/dd15032b-ce2b-40b6-80ac-97623255b531). \nHere, the quantum computer is only used to estimate a single function, while the rest of the computations are left to the classical computer.\n\n"}', 'https://quantumcomputingpatterns.org/assets/pattern-icons/qke_icon.png', '{"Alias": "", "Intent": " Use a quantum routine to estimate a kernel for a classical SVM.\n\n", "Result": "Both the training as well as the classification is efficient, given that the evaluation of the inner products can be done in an efficient manner. \nThe main advantage of this setup is that the quantum computer has the potential to compute inner products in a feature space that cannot be evaluated efficiently on a classical computer.\nStill, a key open question regarding this setup remains how to choose a feature map for a given data set. \n\n", "Context": "A support vector machine (SVM) must be found to classify a set of data points $\\{x_i\\}\\subseteq \\mathcal{R}^d$ according to their labels. \nTherefore, a hyperplane must be found that (i) separates the data points of the different classes and (ii) maintains a maximal distance to the data points. \nA large margin between the hyperplane and the data points ensures that unseen data points are classified correctly with a high probability.\nThe given data set is not guaranteed to be linearly separable, and thus, it may not be possible to find such a separating hyperplane in the original space.\nIf this is the case, a hyperplane in a higher dimensional feature space to which the data points are mapped (implicitly) can be used instead. \n\n", "Solution": "To find a separating hyperplane, a quantum computer is used to estimate the kernel function $K(x,x'')=|\\left<\\phi(x)|\\phi(x'')\\right>|^2$: \nA pair of data points $(x,x'')$ is encoded into the Hilbert Space according to a quantum feature map $\\phi$ (see solution sketch). \nThis allows to use, e.g., a SWAP test routine to estimate the inner product $\\left<\\phi(x)|\\phi(x'')\\right>$ of the two points [(Schuld and Killoran)](https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.122.040504)\nThe result can then be used to compute the kernel function for this pair of data points, based on which the SVM is optimized on a classical computer. \n\n\n![Sketch](https://quantumcomputingpatterns.org/assets/sketches/qke_solution.png)\n\nPattern sketch, taken from: Weigold, Manuela; Barzen, Johanna; Leymann, Frank; and Vietz, Daniel: [Patterns For Hybrid Quantum Algorithms.](https://doi.org/10.1007/978-3-030-87568-8_2) In: Proceedings of the 15th Symposium and Summer School on Service-Oriented Computing (SummerSOC 2021).", "Variants": "", "Known Uses": "The solution above was first proposed in [(Havlíček et al. 2019)](https://www.nature.com/articles/s41586-019-0980-2) where it was also demonstrated in an experiment involving two qubits. \nIndependently, the same solution was developed in [(Schuld and Killoran 2019)](https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.122.040504) which additionally presents a feature map targeted for quantum devices based on continuous-variable qubits. \nAnother proof-of-principle demonstration was conducted by [(Bartkiewicz et al. 2020)](https://www.nature.com/articles/s41598-020-68911-5) using photonic qubits. \nThis approach was also further investigated in [(Ghobadi, Oberoi and Zahedinejad 2019)](https://www.researchgate.net/publication/332897448_The_Power_of_One_Qubit_in_Machine_Learning).\nIn our [QHAna](https://github.com/UST-QuAntiL/qhana) project [(Barzen 2021)](https://arxiv.org/abs/2103.11825), we also provide an implementation of this pattern along with a user interface to select one of various quantum feature maps.", "Related Patterns": "This pattern is a refinement of the [Quantum-Classic Split](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/dd15032b-ce2b-40b6-80ac-97623255b531). \nHere, the quantum computer is only used to estimate a single function, while the rest of the computations are left to the classical computer.\n\n"}', 'af7780d5-1f97-4536-8da7-4194b093ab1d', 'Weigold, M.; Barzen, J.; Leymann, F.; and Vietz, D: Patterns For Hybrid Quantum Algorithms. In: Proceedings of the 15th Symposium and Summer School on Service-Oriented Computing (SummerSOC 2021), https://doi.org/10.1007/978-3-030-87568-8_2', false, false, 'algorithm');
INSERT INTO public.pattern (id, name, uri, content, icon_url, rendered_content, pattern_language_id, paper_ref, deployment_modeling_behavior_pattern, deployment_modeling_structure_pattern, tags) VALUES ('ed3af509-904e-4732-8113-215d65a7d53d', 'Readout Error Mitigation', 'https://patternpedia.org/patternLanguages/quantumAlgorithmPatterns/readoutErrorMitigation', '{"Alias": "Enter your input for this section here.", "Forces": "The measurement times of quantum computers in the NISQ era are significant in comparison to their decoherence times. Therefore, the measurements are highly error-prone and often are among the main error sources. Due to the limited capabilities of current NISQ devices, a minimal number of additional qubits and quantum gates shall be used for the mitigation of readout errors. Further, a quantum device’s measurement error rates change over time, thus the Readout Error Mitigation (REM) needs to be adaptive.", "Intent": "How to reduce the impact of erroneous measurements such that the measured result is closer to the intended quantum state?", "Result": "REM can reduce the impact of errors caused by measurement operations. The resulting, more precise probability distributions make NISQ devices more suitable for real-world use cases. However, additional classical processing is necessary, which can significantly increase the runtime and classical resource requirements, as not all mitigation methods scale well with the number of qubits. Generally, data provenance can be employed to increase the efficiency of frequently occurring REM tasks, e.g., when executing a VQA.", "Context": "A NISQ-compatible quantum algorithm, e.g., QAOA or VQE, needs to be run on a quantum device. The device’s decoherence times are short and the measurement operations are error-prone. Hence, the measured probability distribution is inaccurate, even when the measured quantum state is accurate. Thus, the negative impact of readout errors needs to be mitigated to obtain a precise measurement result.", "Examples": "The figure below illustrates the steps of the Static Invert-and-Measure (SIM) technique[[Tannu et al.]](https://dl.acm.org/doi/abs/10.1145/3352460.3358265). First, multiple slightly adapted instances of the circuit are created. Thereby, bit-flips are added right before the circuit’s measurement operations. This helps to detect erroneous measurements because readout error rates are typically higher when measuring a qubit in the $\\ket{1}$ state than when measuring it in the $\\ket{0}$ state. Once all circuits are executed, the measurement results are processed, returning the mitigated probability distribution.\n![](https://quantumcomputingpatterns.org/assets/sketches/readout-error-mitigation-example1.svg) \n\n\nThe figure below shows the typical process of a calibration matrix-based mitigation method. Multiple shallow calibration circuits are generated and executed. The resulting probability distributions give information about the device’s readout error rates. These error rates are then incorporated into a so-called calibration matrix, which can be used to mitigate readout errors. For example, this can be done by multiplying the inverse of the calibration matrix with the circuit’s measurement result.\n![](https://quantumcomputingpatterns.org/assets/sketches/readout-error-mitigation-example2.svg) ", "Solution": "Mitigate the impact of readout errors by applying a REM method. The mitigation method is performed after the circuit execution and adjusts the measured probability distribution. The resulting mitigated probability distribution is a more accurate representation of the intended quantum state. A solution sketch for the application of REM is shown in figure below. First, the quantum circuit is implemented and executed. Then the resulting probability distribution is improved based on measurement characteristics collected for the quantum device. These characteristics are typically obtained by separately running so-called calibration circuits. Alternatively, adapted instances of the implemented circuit can be run to obtain additional information about the measurement properties.\n![](https://quantumcomputingpatterns.org/assets/sketches/readout-error-mitigation-solution-sketch.svg)", "Known Uses": "Various REM methods, e.g., calibration matrix-based [[Bravyi et al.]](https://journals.aps.org/pra/abstract/10.1103/PhysRevA.103.042605)[[Nachman et al.]](https://www.nature.com/articles/s41534-020-00309-7)[[Maciejewski et al.]](https://quantum-journal.org/papers/q-2020-04-24-257/)[[Nation et al.]](https://journals.aps.org/prxquantum/abstract/10.1103/PRXQuantum.2.040326) or bit-flip-based [[Tannu et al.]](https://dl.acm.org/doi/abs/10.1145/3352460.3358265)[[Smith et al.]](https://www.science.org/doi/full/10.1126/sciadv.abi8009),have been introduced in the literature. Moreover, recent work introduces a deep learning-based REM method [[Kim et al.]](https://iopscience.iop.org/article/10.1088/1367-2630/ac7b3d/pdf).", "Related Pattern": "Enter your input for this section here."}', 'https://quantumcomputingpatterns.org/assets/pattern-icons/readout_error_mitigation_icon.png', '{"Alias": "Enter your input for this section here.", "Forces": "The measurement times of quantum computers in the NISQ era are significant in comparison to their decoherence times. Therefore, the measurements are highly error-prone and often are among the main error sources. Due to the limited capabilities of current NISQ devices, a minimal number of additional qubits and quantum gates shall be used for the mitigation of readout errors. Further, a quantum device’s measurement error rates change over time, thus the Readout Error Mitigation (REM) needs to be adaptive.", "Intent": "How to reduce the impact of erroneous measurements such that the measured result is closer to the intended quantum state?", "Result": "REM can reduce the impact of errors caused by measurement operations. The resulting, more precise probability distributions make NISQ devices more suitable for real-world use cases. However, additional classical processing is necessary, which can significantly increase the runtime and classical resource requirements, as not all mitigation methods scale well with the number of qubits. Generally, data provenance can be employed to increase the efficiency of frequently occurring REM tasks, e.g., when executing a VQA.", "Context": "A NISQ-compatible quantum algorithm, e.g., QAOA or VQE, needs to be run on a quantum device. The device’s decoherence times are short and the measurement operations are error-prone. Hence, the measured probability distribution is inaccurate, even when the measured quantum state is accurate. Thus, the negative impact of readout errors needs to be mitigated to obtain a precise measurement result.", "Examples": "The figure below illustrates the steps of the Static Invert-and-Measure (SIM) technique[[Tannu et al.]](https://dl.acm.org/doi/abs/10.1145/3352460.3358265). First, multiple slightly adapted instances of the circuit are created. Thereby, bit-flips are added right before the circuit’s measurement operations. This helps to detect erroneous measurements because readout error rates are typically higher when measuring a qubit in the $\\ket{1}$ state than when measuring it in the $\\ket{0}$ state. Once all circuits are executed, the measurement results are processed, returning the mitigated probability distribution.\n![](https://quantumcomputingpatterns.org/assets/sketches/readout-error-mitigation-example1.svg) \n\n\nThe figure below shows the typical process of a calibration matrix-based mitigation method. Multiple shallow calibration circuits are generated and executed. The resulting probability distributions give information about the device’s readout error rates. These error rates are then incorporated into a so-called calibration matrix, which can be used to mitigate readout errors. For example, this can be done by multiplying the inverse of the calibration matrix with the circuit’s measurement result.\n![](https://quantumcomputingpatterns.org/assets/sketches/readout-error-mitigation-example2.svg) ", "Solution": "Mitigate the impact of readout errors by applying a REM method. The mitigation method is performed after the circuit execution and adjusts the measured probability distribution. The resulting mitigated probability distribution is a more accurate representation of the intended quantum state. A solution sketch for the application of REM is shown in figure below. First, the quantum circuit is implemented and executed. Then the resulting probability distribution is improved based on measurement characteristics collected for the quantum device. These characteristics are typically obtained by separately running so-called calibration circuits. Alternatively, adapted instances of the implemented circuit can be run to obtain additional information about the measurement properties.\n![](https://quantumcomputingpatterns.org/assets/sketches/readout-error-mitigation-solution-sketch.svg)", "Known Uses": "Various REM methods, e.g., calibration matrix-based [[Bravyi et al.]](https://journals.aps.org/pra/abstract/10.1103/PhysRevA.103.042605)[[Nachman et al.]](https://www.nature.com/articles/s41534-020-00309-7)[[Maciejewski et al.]](https://quantum-journal.org/papers/q-2020-04-24-257/)[[Nation et al.]](https://journals.aps.org/prxquantum/abstract/10.1103/PRXQuantum.2.040326) or bit-flip-based [[Tannu et al.]](https://dl.acm.org/doi/abs/10.1145/3352460.3358265)[[Smith et al.]](https://www.science.org/doi/full/10.1126/sciadv.abi8009),have been introduced in the literature. Moreover, recent work introduces a deep learning-based REM method [[Kim et al.]](https://iopscience.iop.org/article/10.1088/1367-2630/ac7b3d/pdf).", "Related Pattern": "Enter your input for this section here."}', 'af7780d5-1f97-4536-8da7-4194b093ab1d', 'https://www.thinkmind.org/index.php?view=article&articleid=patterns_2022_2_10_70007', false, false, 'augmentation');
INSERT INTO public.pattern (id, name, uri, content, icon_url, rendered_content, pattern_language_id, paper_ref, deployment_modeling_behavior_pattern, deployment_modeling_structure_pattern, tags) VALUES ('70adfd6f-0648-47cf-88ff-0212b882a262', 'Prioritized Execution', 'https://patternpedia.org/patternLanguages/quantumAlgorithmPatterns/prioritizedExecution', '{"Alias": "–", "Forces": "Quantum devices are usually accessed via queues, ensuring their fair utilization. Thus, the queuing times sum up when executing multiple quantum circuits independently of each other. One approach is to use batch processing, i.e., combining various quantum circuits into one job, which is then executed at once [[Vietz et al., 2021]](http://ceur-ws.org/Vol-3008/paper1.pdf). However, this approach is not possible when quantum circuits depend on the results of previous executions, e.g., for VQAs.", "Intent": "How to execute multiple quantum circuits in succession while keeping the queuing time low?", "Result": "By applying this pattern, the time spent waiting inside highly occupied job queues is minimized. The choice between the two options is a trade-off between runtime and cost. In the reserved time-slice scenario, runtime is the highest priority since the reservation of a quantum device incurs higher costs than other forms of access. When using sessions for the execution, there can still be competing executions in the job queue from other users.", "Context": "Quantum applications often require executing multiple quantum circuits. This is especially the case when utilizing VQAs on contemporary NISQ devices. Thus, these quantum circuits should be executed efficiently by minimizing the queuing times.", "Examples": "–", "Solution": "Use quantum offerings that enable prioritized access to quantum devices to reduce or completely avoid queuing times, as shown in the solutions sketch in Figure 5. For this, prioritized access to quantum devices is obtained in Step 1. In Step 2, the quantum device can then be reused via this prioritized access, which restricts the number of users to reduce queuing times for multiple circuit executions.\n\n![Solution Sketch for Prioritized Execution](https://raw.githubusercontent.com/PatternAtlas/pattern-atlas-content/main/sketches/quantum_computing_patterns/session-based-single-column.svg)", "Known Uses": "The Session Reuse variant is currently supported by IBM [[Qiskit, 2023a]](https://qiskit.org/documentation/) and AWS [[AWS, 2023]](https://docs.aws.amazon.com/braket/latest/developerguide/braket-using.html). Further, the Dedicated Access variant is offered by vendors such as AWS [[AWS, 2023]](https://docs.aws.amazon.com/braket/latest/developerguide/braket-using.html), Azure [[Microsoft, 2023]](https://azure.microsoft.com/en-us/services/quantum/), or IBM [[IBM, 2023b]](https://quantum-computing.ibm.com/lab/docs/iql/). A concrete example of a prioritized execution using Qiskit  [[Qiskit, 2023b]](https://qiskit.org/documentation/partners/qiskit_ibm_runtime/how_to/run_session.html) highlights which options for the session are available and shows the details like the session time limit.", "Related Pattern": "When using the VQA, VQE, or QAOA patterns [[Weigold et al., 2021b]](https://doi.org/10.1007/978-3-030-87568-8_2), prioritization is highly advised because of the amount of sequential quantum circuit executions. In these cases, it can be combined with the PRE-DEPLOYED EXECUTION pattern to address custom deployment requirements."}', 'https://raw.githubusercontent.com/PatternAtlas/pattern-atlas-content/main/icons/quantum_computing_patterns/priortized-execution-thin.svg', '{"Alias": "–", "Forces": "Quantum devices are usually accessed via queues, ensuring their fair utilization. Thus, the queuing times sum up when executing multiple quantum circuits independently of each other. One approach is to use batch processing, i.e., combining various quantum circuits into one job, which is then executed at once [[Vietz et al., 2021]](http://ceur-ws.org/Vol-3008/paper1.pdf). However, this approach is not possible when quantum circuits depend on the results of previous executions, e.g., for VQAs.", "Intent": "How to execute multiple quantum circuits in succession while keeping the queuing time low?", "Result": "By applying this pattern, the time spent waiting inside highly occupied job queues is minimized. The choice between the two options is a trade-off between runtime and cost. In the reserved time-slice scenario, runtime is the highest priority since the reservation of a quantum device incurs higher costs than other forms of access. When using sessions for the execution, there can still be competing executions in the job queue from other users.", "Context": "Quantum applications often require executing multiple quantum circuits. This is especially the case when utilizing VQAs on contemporary NISQ devices. Thus, these quantum circuits should be executed efficiently by minimizing the queuing times.", "Examples": "–", "Solution": "Use quantum offerings that enable prioritized access to quantum devices to reduce or completely avoid queuing times, as shown in the solutions sketch in Figure 5. For this, prioritized access to quantum devices is obtained in Step 1. In Step 2, the quantum device can then be reused via this prioritized access, which restricts the number of users to reduce queuing times for multiple circuit executions.\n\n![Solution Sketch for Prioritized Execution](https://raw.githubusercontent.com/PatternAtlas/pattern-atlas-content/main/sketches/quantum_computing_patterns/session-based-single-column.svg)", "Known Uses": "The Session Reuse variant is currently supported by IBM [[Qiskit, 2023a]](https://qiskit.org/documentation/) and AWS [[AWS, 2023]](https://docs.aws.amazon.com/braket/latest/developerguide/braket-using.html). Further, the Dedicated Access variant is offered by vendors such as AWS [[AWS, 2023]](https://docs.aws.amazon.com/braket/latest/developerguide/braket-using.html), Azure [[Microsoft, 2023]](https://azure.microsoft.com/en-us/services/quantum/), or IBM [[IBM, 2023b]](https://quantum-computing.ibm.com/lab/docs/iql/). A concrete example of a prioritized execution using Qiskit  [[Qiskit, 2023b]](https://qiskit.org/documentation/partners/qiskit_ibm_runtime/how_to/run_session.html) highlights which options for the session are available and shows the details like the session time limit.", "Related Pattern": "When using the VQA, VQE, or QAOA patterns [[Weigold et al., 2021b]](https://doi.org/10.1007/978-3-030-87568-8_2), prioritization is highly advised because of the amount of sequential quantum circuit executions. In these cases, it can be combined with the PRE-DEPLOYED EXECUTION pattern to address custom deployment requirements."}', 'af7780d5-1f97-4536-8da7-4194b093ab1d', 'https://www.scitepress.org/Link.aspx?doi=10.5220/0012057700003538', NULL, NULL, 'behavioral');
INSERT INTO public.pattern (id, name, uri, content, icon_url, rendered_content, pattern_language_id, paper_ref, deployment_modeling_behavior_pattern, deployment_modeling_structure_pattern, tags) VALUES ('da93f915-7f4c-49df-99d0-80d91f26a337', 'Quantum Approximate Optimization Algorithm (QAOA)', 'https://patternpedia.org/patternLanguages/reformulatedQuantumComputingPatterns/quantumApproximateOptimizationAlgorithm(qaoa)', '{"Alias": "", "Intent": "Approximate the solution of an optimization problem [Weigold et al. 2021](https://www.springer.com/de/book/9783030648459)\n\n", "Result": "The depth of the overall circuit is at most $mp + p$ [(Farhi and Goldstone 2014)](http://arxiv.org/pdf/1411.4028v1) which is rather shallow. \nThis is one reason why this algorithm is considered a promising candidate for NISQ devices. \nFrom a theoretical point of view, it can be noticed that the algorithm approximates the best solution if suitable small values for the parameters $\\gamma, \\beta$ are chosen with  $p\\rightarrow \\infty$. \nNevertheless, note that the performance of the algorithm also depends on the objective function and the optimization strategy. \n\n", "Context": "To solve a combinatorial optimization problem, a bit string $z=z_1\\ldots z_n$ must be found which assigns each binary variable $z_i$ to either 0 or 1 and fulfills a maximum number of $m$ clauses. \nHereby, each clause involves a subset of the variables.\nIn contrast to the potentially constrained domain of solutions in [Alternating Operator Ansatz (AOA)](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/b657ea73-63c0-4800-a69d-a91925e19ac6), every bit string $z=z_1\\ldots z_n$ of length $n$ is a solution to the problem. \n\n", "Solution": "The overall structure of the *Quantum Approximate Optimization Algorithm (QAOA)* [(Farhi and Goldstone 2014)](http://arxiv.org/pdf/1411.4028v1) approach is depicted in the solution sketch.\n\nFirst, a [Uniform Superposition](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/2229a430-fe92-4411-9d72-d10dd1d8da14) realizing all possible solutions in [Basis Encoding](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/de5b0951-2b66-4312-bf06-7082d3232e6e) is prepared.\nE.g., the solution with all binary values assigned to 0 is represented by $\\newcommand{\\state}[1]{{\\left| #1 \\right>}} \\state{0 \\ldots 0 0}$ and is contained in the superposition. \n\n\nThen, an ansatz circuit is applied that is constructed based on the two operators $U(C,\\gamma)$ and $U(B,\\beta)$:\n\n\n$$\n\\newcommand{\\colVec}[1]{% inline column vector\n\\bigl( \\begin{smallmatrix}#1\\end{smallmatrix}\\bigr)\n}\n\\newcommand{\\bigColVec}[1]{% inline column vector\n\\left( \\begin{matrix}#1\\end{matrix}\\right)\n}\n\\newcommand{\\state}[1]{{\\left| #1 \\right>}}\n    U(C,\\gamma) = e^{i\\gamma C} = \\prod_{\\alpha=1}^{m} e^{-i\\gamma C_\\alpha}; \n    \\ U(B,\\beta) = e^{-i\\beta B} = \\prod_{j=1}^{n}e^{-i\\beta \\sigma_x^{j}}\n$$  \n\n\nThe first operator is a phase shift $e^{-i\\gamma}$ on every computational basis state for every clause that is fulfilled. \nHowever, this marks but does not change the amplitude of computational basis states (which each represent a solution), thus, the second operator $U(B,\\gamma)$ is required. \n$U(B,\\gamma)$ defines a rotation around the $X$-axis for every qubit whereby the angle for the rotation depends on $\\gamma$. \nBased on the structure defined in [Alternating Operator Ansatz (AOA)](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/b657ea73-63c0-4800-a69d-a91925e19ac6), a trial state $\\newcommand{\\state}[1]{{\\left| #1 \\right>}} \\state{\\gamma,\\beta}$ is prepared. \nMeasuring this state results in a single bitstring, i.e., a solution that can be evaluated by the objective function. \nThe parameters $\\beta$ and $\\gamma$ which are initialized randomly for the first iteration can then be adjusted. \nThis iterative process continues until the termination condition is satisfied. \n\n![](https://quantumcomputingpatterns.org/assets/sketches/variational_solution_qaoa.png)\nPattern sketch, taken from: Weigold, Manuela; Barzen, Johanna; Leymann, Frank; and Vietz, Daniel: [Patterns For Hybrid Quantum Algorithms.](https://doi.org/10.1007/978-3-030-87568-8_2 ) In: Proceedings of the 15th Symposium and Summer School on Service-Oriented Computing (SummerSOC 2021).", "Variants": "", "Known Uses": "This algorithm was first proposed by Farhi, Goldstone, and Gutmann [(Farhi and Goldstone 2014)](http://arxiv.org/pdf/1411.4028v1) and applied to the problem of finding a maximum cut of a graph (MaxCut). \nIn a follow-up paper, an advantage over classical algorithms for the *bounded occurrence problem* [(Farhi, Goldstone and Gutmann 2015)](https://arxiv.org/abs/1412.6062) was shown. \nShortly afterward, a classical algorithm [(Barak et al. 2015)](http://arxiv.org/abs/1505.03424) was published from which even better results can be expected for this particular problem instance. \n\n[Quantum approximate optimization algorithm (PlanQK)](https://platform.planqk.de/algorithms/fae60bca-d2b6-4aa2-88b7-58caace34179/)", "Related Patterns": "In this pattern [Uniform Superposition](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/2229a430-fe92-4411-9d72-d10dd1d8da14) is used to represent the bitstrings of solutions in [Basis Encoding](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/bcd4c7a1-3c92-4f8c-a530-72b8b95d3750).\nThe higher-level structure of this pattern is described by [Alternating Operator Ansatz (AOA)](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/b657ea73-63c0-4800-a69d-a91925e19ac6) which also uses [Phase Shift](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/c6560c51-d2e3-4595-b9c3-b609c75c0b82) . \n\n"}', 'https://quantumcomputingpatterns.org/assets/pattern-icons/qaoa_icon.png', '{"Alias": "", "Intent": "Approximate the solution of an optimization problem [Weigold et al. 2021](https://www.springer.com/de/book/9783030648459)\n\n", "Result": "The depth of the overall circuit is at most $mp + p$ [(Farhi and Goldstone 2014)](http://arxiv.org/pdf/1411.4028v1) which is rather shallow. \nThis is one reason why this algorithm is considered a promising candidate for NISQ devices. \nFrom a theoretical point of view, it can be noticed that the algorithm approximates the best solution if suitable small values for the parameters $\\gamma, \\beta$ are chosen with  $p\\rightarrow \\infty$. \nNevertheless, note that the performance of the algorithm also depends on the objective function and the optimization strategy. \n\n", "Context": "To solve a combinatorial optimization problem, a bit string $z=z_1\\ldots z_n$ must be found which assigns each binary variable $z_i$ to either 0 or 1 and fulfills a maximum number of $m$ clauses. \nHereby, each clause involves a subset of the variables.\nIn contrast to the potentially constrained domain of solutions in [Alternating Operator Ansatz (AOA)](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/b657ea73-63c0-4800-a69d-a91925e19ac6), every bit string $z=z_1\\ldots z_n$ of length $n$ is a solution to the problem. \n\n", "Solution": "The overall structure of the *Quantum Approximate Optimization Algorithm (QAOA)* [(Farhi and Goldstone 2014)](http://arxiv.org/pdf/1411.4028v1) approach is depicted in the solution sketch.\n\nFirst, a [Uniform Superposition](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/2229a430-fe92-4411-9d72-d10dd1d8da14) realizing all possible solutions in [Basis Encoding](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/de5b0951-2b66-4312-bf06-7082d3232e6e) is prepared.\nE.g., the solution with all binary values assigned to 0 is represented by $\\newcommand{\\state}[1]{{\\left| #1 \\right>}} \\state{0 \\ldots 0 0}$ and is contained in the superposition. \n\n\nThen, an ansatz circuit is applied that is constructed based on the two operators $U(C,\\gamma)$ and $U(B,\\beta)$:\n\n\n$$\n\\newcommand{\\colVec}[1]{% inline column vector\n\\bigl( \\begin{smallmatrix}#1\\end{smallmatrix}\\bigr)\n}\n\\newcommand{\\bigColVec}[1]{% inline column vector\n\\left( \\begin{matrix}#1\\end{matrix}\\right)\n}\n\\newcommand{\\state}[1]{{\\left| #1 \\right>}}\n    U(C,\\gamma) = e^{i\\gamma C} = \\prod_{\\alpha=1}^{m} e^{-i\\gamma C_\\alpha}; \n    \\ U(B,\\beta) = e^{-i\\beta B} = \\prod_{j=1}^{n}e^{-i\\beta \\sigma_x^{j}}\n$$  \n\n\nThe first operator is a phase shift $e^{-i\\gamma}$ on every computational basis state for every clause that is fulfilled. \nHowever, this marks but does not change the amplitude of computational basis states (which each represent a solution), thus, the second operator $U(B,\\gamma)$ is required. \n$U(B,\\gamma)$ defines a rotation around the $X$-axis for every qubit whereby the angle for the rotation depends on $\\gamma$. \nBased on the structure defined in [Alternating Operator Ansatz (AOA)](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/b657ea73-63c0-4800-a69d-a91925e19ac6), a trial state $\\newcommand{\\state}[1]{{\\left| #1 \\right>}} \\state{\\gamma,\\beta}$ is prepared. \nMeasuring this state results in a single bitstring, i.e., a solution that can be evaluated by the objective function. \nThe parameters $\\beta$ and $\\gamma$ which are initialized randomly for the first iteration can then be adjusted. \nThis iterative process continues until the termination condition is satisfied. \n\n![](https://quantumcomputingpatterns.org/assets/sketches/variational_solution_qaoa.png)\nPattern sketch, taken from: Weigold, Manuela; Barzen, Johanna; Leymann, Frank; and Vietz, Daniel: [Patterns For Hybrid Quantum Algorithms.](https://doi.org/10.1007/978-3-030-87568-8_2 ) In: Proceedings of the 15th Symposium and Summer School on Service-Oriented Computing (SummerSOC 2021).", "Variants": "", "Known Uses": "This algorithm was first proposed by Farhi, Goldstone, and Gutmann [(Farhi and Goldstone 2014)](http://arxiv.org/pdf/1411.4028v1) and applied to the problem of finding a maximum cut of a graph (MaxCut). \nIn a follow-up paper, an advantage over classical algorithms for the *bounded occurrence problem* [(Farhi, Goldstone and Gutmann 2015)](https://arxiv.org/abs/1412.6062) was shown. \nShortly afterward, a classical algorithm [(Barak et al. 2015)](http://arxiv.org/abs/1505.03424) was published from which even better results can be expected for this particular problem instance. \n\n[Quantum approximate optimization algorithm (PlanQK)](https://platform.planqk.de/algorithms/fae60bca-d2b6-4aa2-88b7-58caace34179/)", "Related Patterns": "In this pattern [Uniform Superposition](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/2229a430-fe92-4411-9d72-d10dd1d8da14) is used to represent the bitstrings of solutions in [Basis Encoding](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/bcd4c7a1-3c92-4f8c-a530-72b8b95d3750).\nThe higher-level structure of this pattern is described by [Alternating Operator Ansatz (AOA)](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/b657ea73-63c0-4800-a69d-a91925e19ac6) which also uses [Phase Shift](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/c6560c51-d2e3-4595-b9c3-b609c75c0b82) . \n\n"}', 'af7780d5-1f97-4536-8da7-4194b093ab1d', 'Weigold, M.; Barzen, J.; Leymann, F.; and Vietz, D: Patterns For Hybrid Quantum Algorithms. In: Proceedings of the 15th Symposium and Summer School on Service-Oriented Computing (SummerSOC 2021), https://doi.org/10.1007/978-3-030-87568-8_2', false, false, 'algorithm');
INSERT INTO public.pattern (id, name, uri, content, icon_url, rendered_content, pattern_language_id, paper_ref, deployment_modeling_behavior_pattern, deployment_modeling_structure_pattern, tags) VALUES ('8fcca2dc-fca0-47cf-9bd4-038cd2fe8fb8', 'Classical-Quantum Interface', 'https://patternpedia.org/patternLanguages/quantumAlgorithmPatterns/classical-quantumInterface', '{"Alias": "–", "Forces": "To integrate a quantum algorithm implementation into an application, a compatible interface is required. A [Hybrid Module](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/4074490a-4236-49ed-83d1-625ce58e2dbd) already provides an interface enabling its integration into applications, however, using this interface may still require considerable quantum computing knowledge. For example, it may require the problem instance to be provided in the form of a behavior input to the quantum part of an algorithm, or it may have parameters that otherwise influence the quantum part, e.g., by enabling certain error mitigation methods. The effects of the changes, e.g., on resource requirements or runtime, are difficult to estimate without knowledge of quantum computers. Thus, to facilitate the integration of quantum algorithms by problem-domain experts without quantum computing knowledge, such an interface is not sufficient.", "Intent": "How can a quantum algorithm implementation be used by developers without quantum computing knowledge?", "Result": "The quantum algorithm implementation can be utilized using a Classical-Quantum Interface. Problem domain experts can make use of this quantum algorithm implementation through the Classical-Quantum Interface created for their domain. The knowledge required to utilize the algorithm implementation is presented in the interface documentation, and the format of input parameters is familiar to problem-domain experts.", "Context": "Using a quantum algorithm implementation often requires in depth quantum computing knowledge. For example, the Grover search algorithm requires that the user provides a quantum circuit for the missing oracle [[Grover 1996]](https://doi.org/10.1145/237814.237866). Other algorithms, like QAOA, require choosing an ansatz, which also requires quantum computing knowledge [[Cerezo et al. 2021]](https://doi.org/10.1038/s42254-021-00348-9)[[Weigold et al. 2021]](https://doi.org/10.1007/978-3-030-87568-8_2). However, software developers who want to integrate a quantum algorithm implementation into an application have a deep understanding of the problem domain rather than deep knowledge of quantum computing.", "Examples": "–", "Solution": "Use a Classical-Quantum Interface that hides the quantum implementation details. Inputs can be provided to the interface in formats specific to the problem domain. These problem domain-specific inputs are internally converted into inputs in the formats required by the implementation of the quantum part.\n\n\nThe documentation of interface inputs that affect the quantum part requires special consideration, since understanding their impact on algorithm execution is important information when integrating the quantum algorithm implementation. Thus, the impact of these inputs on the algorithm should be documented in a comprehensible and easily understandable manner by the interface developer. For example, a parameter that increases the accuracy of the result, but also increases the number of gates in the generated circuits, which can result in increased errors with current quantum computers, could be documented as follows:\n\n\n> “Increasing this parameter can increase the accuracy of the result. However, it also increases the probability of computation errors accumulating, which can negate any improvement in accuracy.“\n\n![Solution sketch classical-quantum interface](https://raw.githubusercontent.com/PatternAtlas/pattern-atlas-content/86db502508692e2de1af9a3dfbb2e5ff28e03201/sketches/quantum_computing_patterns/classical-quantum-interface.svg)\n\nThe sketch shows the interaction of a classical program with a quantum algorithm implemented as a [Hybrid Module](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/4074490a-4236-49ed-83d1-625ce58e2dbd) through a ClassicalL-Quantum Interface. It transforms the problem domain-specific input of the classical program into the inputs required by the quantum algorithm. This interface can also be integrated directly into the [Hybrid Module](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/4074490a-4236-49ed-83d1-625ce58e2dbd).", "Known Uses": "Domain-specific libraries for quantum computing are among the first having implemented this pattern. Examples for already implemented Classical-Quantum Interfaces can be found in the chemistry domain in [Qiskit Nature](https://qiskit.org/ecosystem/nature/index.html), [Amazon Braket](https://github.com/aws/amazon-braket-examples/blob/main/examples/hybrid_quantum_algorithms/VQE_Chemistry/VQE_chemistry_braket.ipynb), and [Q#](https://learn.microsoft.com/en-us/azure/quantum/user-guide/libraries/chemistry/). They offer transformation modules that map the electronic structure of molecules to qubits. Furthermore, [Qiskit](https://qiskit.org/documentation) provides a finance module enabling portfolio optimization by implementing a transformer that takes a generic optimization problem as input and outputs a cost operator that can be used in a quantum algorithm. As many classical problems can be formulated as such an optimization problem, this can be used as a Classical-Quantum Interface for different problem domains.", "Related Pattern": "The Classical-Quantum Interface enables the integration of quantum algorithm implementations into applications. It can be used as an interface for a quantum algorithm implemented as a [Hybrid Module](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/4074490a-4236-49ed-83d1-625ce58e2dbd). This interface provides a bridge between the different programming paradigms separated by the [Quantum-Classic Split](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/dd15032b-ce2b-40b6-80ac-97623255b531). It is a special kind of Facade [Gamma et al. 1994] for quantum algorithms that not only hides the complexity of the algorithm, but also translates between the quantum computing domain and the problem domain.\n\n---\n\n[Gamma et al. 1994] E. Gamma, R. Helm, R. Johnson, and J. Vlissides, Design Patterns: Elements of Reusable Object-oriented Software. Addison-Wesley, 1994."}', 'https://raw.githubusercontent.com/PatternAtlas/pattern-atlas-content/7870b15afcae629bfbc0d0022fcb758832b3b8eb/icons/quantum_computing_patterns/classical-quantum-interface.svg', '{"Alias": "–", "Forces": "To integrate a quantum algorithm implementation into an application, a compatible interface is required. A [Hybrid Module](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/4074490a-4236-49ed-83d1-625ce58e2dbd) already provides an interface enabling its integration into applications, however, using this interface may still require considerable quantum computing knowledge. For example, it may require the problem instance to be provided in the form of a behavior input to the quantum part of an algorithm, or it may have parameters that otherwise influence the quantum part, e.g., by enabling certain error mitigation methods. The effects of the changes, e.g., on resource requirements or runtime, are difficult to estimate without knowledge of quantum computers. Thus, to facilitate the integration of quantum algorithms by problem-domain experts without quantum computing knowledge, such an interface is not sufficient.", "Intent": "How can a quantum algorithm implementation be used by developers without quantum computing knowledge?", "Result": "The quantum algorithm implementation can be utilized using a Classical-Quantum Interface. Problem domain experts can make use of this quantum algorithm implementation through the Classical-Quantum Interface created for their domain. The knowledge required to utilize the algorithm implementation is presented in the interface documentation, and the format of input parameters is familiar to problem-domain experts.", "Context": "Using a quantum algorithm implementation often requires in depth quantum computing knowledge. For example, the Grover search algorithm requires that the user provides a quantum circuit for the missing oracle [[Grover 1996]](https://doi.org/10.1145/237814.237866). Other algorithms, like QAOA, require choosing an ansatz, which also requires quantum computing knowledge [[Cerezo et al. 2021]](https://doi.org/10.1038/s42254-021-00348-9)[[Weigold et al. 2021]](https://doi.org/10.1007/978-3-030-87568-8_2). However, software developers who want to integrate a quantum algorithm implementation into an application have a deep understanding of the problem domain rather than deep knowledge of quantum computing.", "Examples": "–", "Solution": "Use a Classical-Quantum Interface that hides the quantum implementation details. Inputs can be provided to the interface in formats specific to the problem domain. These problem domain-specific inputs are internally converted into inputs in the formats required by the implementation of the quantum part.\n\n\nThe documentation of interface inputs that affect the quantum part requires special consideration, since understanding their impact on algorithm execution is important information when integrating the quantum algorithm implementation. Thus, the impact of these inputs on the algorithm should be documented in a comprehensible and easily understandable manner by the interface developer. For example, a parameter that increases the accuracy of the result, but also increases the number of gates in the generated circuits, which can result in increased errors with current quantum computers, could be documented as follows:\n\n\n> “Increasing this parameter can increase the accuracy of the result. However, it also increases the probability of computation errors accumulating, which can negate any improvement in accuracy.“\n\n![Solution sketch classical-quantum interface](https://raw.githubusercontent.com/PatternAtlas/pattern-atlas-content/86db502508692e2de1af9a3dfbb2e5ff28e03201/sketches/quantum_computing_patterns/classical-quantum-interface.svg)\n\nThe sketch shows the interaction of a classical program with a quantum algorithm implemented as a [Hybrid Module](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/4074490a-4236-49ed-83d1-625ce58e2dbd) through a ClassicalL-Quantum Interface. It transforms the problem domain-specific input of the classical program into the inputs required by the quantum algorithm. This interface can also be integrated directly into the [Hybrid Module](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/4074490a-4236-49ed-83d1-625ce58e2dbd).", "Known Uses": "Domain-specific libraries for quantum computing are among the first having implemented this pattern. Examples for already implemented Classical-Quantum Interfaces can be found in the chemistry domain in [Qiskit Nature](https://qiskit.org/ecosystem/nature/index.html), [Amazon Braket](https://github.com/aws/amazon-braket-examples/blob/main/examples/hybrid_quantum_algorithms/VQE_Chemistry/VQE_chemistry_braket.ipynb), and [Q#](https://learn.microsoft.com/en-us/azure/quantum/user-guide/libraries/chemistry/). They offer transformation modules that map the electronic structure of molecules to qubits. Furthermore, [Qiskit](https://qiskit.org/documentation) provides a finance module enabling portfolio optimization by implementing a transformer that takes a generic optimization problem as input and outputs a cost operator that can be used in a quantum algorithm. As many classical problems can be formulated as such an optimization problem, this can be used as a Classical-Quantum Interface for different problem domains.", "Related Pattern": "The Classical-Quantum Interface enables the integration of quantum algorithm implementations into applications. It can be used as an interface for a quantum algorithm implemented as a [Hybrid Module](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/4074490a-4236-49ed-83d1-625ce58e2dbd). This interface provides a bridge between the different programming paradigms separated by the [Quantum-Classic Split](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/dd15032b-ce2b-40b6-80ac-97623255b531). It is a special kind of Facade [Gamma et al. 1994] for quantum algorithms that not only hides the complexity of the algorithm, but also translates between the quantum computing domain and the problem domain.\n\n---\n\n[Gamma et al. 1994] E. Gamma, R. Helm, R. Johnson, and J. Vlissides, Design Patterns: Elements of Reusable Object-oriented Software. Addison-Wesley, 1994."}', 'af7780d5-1f97-4536-8da7-4194b093ab1d', 'IARIA, 2023', NULL, NULL, 'design');
INSERT INTO public.pattern (id, name, uri, content, icon_url, rendered_content, pattern_language_id, paper_ref, deployment_modeling_behavior_pattern, deployment_modeling_structure_pattern, tags) VALUES ('482714a7-8409-4165-93fe-72b02c2ae99c', 'Quantum Associative Memory (QuAM)', 'https://patternpedia.org/patternLanguages/reformulatedQuantumComputingPatterns/quantumAssociativeMemory(quam)', '{"Alias": "Enter your input for this section here.", "Intent": "Encode data in a compact manner that do not require calculations", "Result": "The resulting encoding is a digital encoding and therefore suitable for arithmetic computations [(Leymann and Barzen 2020)](http://iopscience.iop.org/10.1088/2058-9565/abae7d). For input $n$ numbers that are approximated by $l$ digits, $l$ qubits are needed for this representation. Each of then encoded input values is represented by a basis vector with an amplitude of1√n.All other $2^{l−n}$ amplitudes of the register are zero - in our example, $|000\\rangle$, $|001\\rangle$,$|100\\rangle$,$|101\\rangle$, and $|111\\rangle$. The amplitude vector is therefore often sparse for this encoding [(Schuld and Petruccione 2018)](http://dx.doi.org/10.1007/978-3-319-96424-9). ", "Context": "A quantum algorithm requires multiple numerical values $X$ as input for further calculations.", "Solution": "Use a quantum associative memory (QuAM) to prepare a superposition of basis encoded values inthe same qubit register [(Leymann and Barzen 2020a)](http://iopscience.iop.org/10.1088/2058-9565/abae7d).  Note that the quantum register is an equally weighted superposition of the basis encoded values.\nBoth branches have a load and a storage part (see sketch). An additional element is first prepared into the loadpart of both branches. Next, the processing branch is split in such a manner, that the new element gets a properamplitude such that it can be brought into superposition with the already added elements. Finally, an [Uncompute](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/d4f7c247-e2bb-4301-ad06-f758fa58f2dc) cleans the processing branch to be ready for the next iteration (see [(Ventura and Martinez 2000)](https://www.sciencedirect.com/science/article/pii/S0020025599001012) for details. )\n\n![](https://quantumcomputingpatterns.org/assets/sketches/quam_solution.png)\nPattern sketch, taken from: Weigold, Manuela; Barzen, Johanna; Leymann, Frank; Salm, Marie: [Data Encoding Patterns for Quantum Algorithms.](https://hillside.net/plop/2020/papers/weigold.pdf) In: The Hillside Group (Hrsg): Proceedings of the 27th Conference on Pattern Languages of Programs (PLoP ''20).", "Variants": "Enter your input for this section here.", "Known Uses": "The presented state preparation routine based on [(Ventura and Martinez 2000)](https://www.sciencedirect.com/science/article/pii/S0020025599001012) can be used whenever multiple data values need to be represented in  [Basis Encoding](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/bcd4c7a1-3c92-4f8c-a530-72b8b95d3750). Shor’s algorithm [(Shor 1999)](https://epubs.siam.org/doi/abs/10.1137/S0036144598347011) for the factorization of prime numbers, a quantum version of the Fourier transform [(Coppersmith 2002)](http://arxiv.org/abs/quant-ph/0201067), and Grover’s algorithm [(Grover 1996)](http://dx.doi.org/10.1145/237814.237866) for unstructured search rely on this encoding. Various algorithms extend or use Grover’s algorithm and therefore also make use of this encoding.\n\n[Shor''s Algorithm (PlanQK)](https://platform.planqk.de/algorithms/e7413acf-c25e-4de8-ab78-75bfc836a839/)\n[Grover''s Algorithm (PlanQK)](https://platform.planqk.de/algorithms/86dfd279-db46-4adb-84a7-39bcf1d19d3a/)", "Related Patterns": "This pattern refines [Initialization](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/312bc9d3-26c0-40ae-b90b-56effd136c0d) and makes use of [Uncompute](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/d4f7c247-e2bb-4301-ad06-f758fa58f2dc).  [Uniform Superposition](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/2229a430-fe92-4411-9d72-d10dd1d8da14) creates a superposition of all computational basis states. Each of the computational basis states also represents a value in [Basis Encoding](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/bcd4c7a1-3c92-4f8c-a530-72b8b95d3750)."}', 'https://quantumcomputingpatterns.org/assets/pattern-icons/quam_icon.png', '{"Alias": "Enter your input for this section here.", "Intent": "Encode data in a compact manner that do not require calculations", "Result": "The resulting encoding is a digital encoding and therefore suitable for arithmetic computations [(Leymann and Barzen 2020)](http://iopscience.iop.org/10.1088/2058-9565/abae7d). For input $n$ numbers that are approximated by $l$ digits, $l$ qubits are needed for this representation. Each of then encoded input values is represented by a basis vector with an amplitude of1√n.All other $2^{l−n}$ amplitudes of the register are zero - in our example, $|000\\rangle$, $|001\\rangle$,$|100\\rangle$,$|101\\rangle$, and $|111\\rangle$. The amplitude vector is therefore often sparse for this encoding [(Schuld and Petruccione 2018)](http://dx.doi.org/10.1007/978-3-319-96424-9). ", "Context": "A quantum algorithm requires multiple numerical values $X$ as input for further calculations.", "Solution": "Use a quantum associative memory (QuAM) to prepare a superposition of basis encoded values inthe same qubit register [(Leymann and Barzen 2020a)](http://iopscience.iop.org/10.1088/2058-9565/abae7d).  Note that the quantum register is an equally weighted superposition of the basis encoded values.\nBoth branches have a load and a storage part (see sketch). An additional element is first prepared into the loadpart of both branches. Next, the processing branch is split in such a manner, that the new element gets a properamplitude such that it can be brought into superposition with the already added elements. Finally, an [Uncompute](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/d4f7c247-e2bb-4301-ad06-f758fa58f2dc) cleans the processing branch to be ready for the next iteration (see [(Ventura and Martinez 2000)](https://www.sciencedirect.com/science/article/pii/S0020025599001012) for details. )\n\n![](https://quantumcomputingpatterns.org/assets/sketches/quam_solution.png)\nPattern sketch, taken from: Weigold, Manuela; Barzen, Johanna; Leymann, Frank; Salm, Marie: [Data Encoding Patterns for Quantum Algorithms.](https://hillside.net/plop/2020/papers/weigold.pdf) In: The Hillside Group (Hrsg): Proceedings of the 27th Conference on Pattern Languages of Programs (PLoP ''20).", "Variants": "Enter your input for this section here.", "Known Uses": "The presented state preparation routine based on [(Ventura and Martinez 2000)](https://www.sciencedirect.com/science/article/pii/S0020025599001012) can be used whenever multiple data values need to be represented in  [Basis Encoding](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/bcd4c7a1-3c92-4f8c-a530-72b8b95d3750). Shor’s algorithm [(Shor 1999)](https://epubs.siam.org/doi/abs/10.1137/S0036144598347011) for the factorization of prime numbers, a quantum version of the Fourier transform [(Coppersmith 2002)](http://arxiv.org/abs/quant-ph/0201067), and Grover’s algorithm [(Grover 1996)](http://dx.doi.org/10.1145/237814.237866) for unstructured search rely on this encoding. Various algorithms extend or use Grover’s algorithm and therefore also make use of this encoding.\n\n[Shor''s Algorithm (PlanQK)](https://platform.planqk.de/algorithms/e7413acf-c25e-4de8-ab78-75bfc836a839/)\n[Grover''s Algorithm (PlanQK)](https://platform.planqk.de/algorithms/86dfd279-db46-4adb-84a7-39bcf1d19d3a/)", "Related Patterns": "This pattern refines [Initialization](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/312bc9d3-26c0-40ae-b90b-56effd136c0d) and makes use of [Uncompute](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/d4f7c247-e2bb-4301-ad06-f758fa58f2dc).  [Uniform Superposition](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/2229a430-fe92-4411-9d72-d10dd1d8da14) creates a superposition of all computational basis states. Each of the computational basis states also represents a value in [Basis Encoding](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/bcd4c7a1-3c92-4f8c-a530-72b8b95d3750)."}', 'af7780d5-1f97-4536-8da7-4194b093ab1d', 'Weigold, M.; Barzen, J.; Leymann, F.; Salm, M.: Data Encoding Patterns for Quantum Algorithms. In: The Hillside Group (Hrsg): Proceedings of the 27th Conference on Pattern Languages of Programs (PLoP ''20), https://hillside.net/plop/2020/papers/weigold.pdf', false, false, 'encoding');
INSERT INTO public.pattern (id, name, uri, content, icon_url, rendered_content, pattern_language_id, paper_ref, deployment_modeling_behavior_pattern, deployment_modeling_structure_pattern, tags) VALUES ('3f3fabf0-7fa7-4b43-a74a-46a7ac2c55ee', 'Function Table', 'https://patternpedia.org/patternLanguages/reformulatedQuantumComputingPatterns/functionTable', '{"Alias": "Enter your input for this section here.", "Intent": "Compute a function table of a finite Boolean function", "Result": "For the general case of $m>1$, the register is in a superposition of all data values in the first register and their corresponding data values in the second register. \nIn the special case of a one-dimensional decision function $f$, the register contains a superposition of all computational bases, where the sign indicates the outcome of the decision function: \nA minus sign indicates an outcome of 0 whereas a plus sign indicates an outcome of 1 - this is also referred to as \"phase kickback\".", "Context": "A classical algorithm must evaluate a given function $f:\\{0, 1\\}^n \\rightarrow \\{0, 1\\}^m$ for each value of the domain for computing a function table. \nBy exploiting quantum parallelism, a quantum algorithm is able to compute all values of such a finite Boolean function in a single step. \nThis is useful to speed-up algorithms that reveal global properties of a respective function $f$. \nNote that for $m=1$, a Boolean function $f:\\{0, 1\\}^n \\rightarrow \\{0, 1\\}$ is often an indicator function which can be used to solve a decision problem.", "Solution": "For the computation of the function table, the quantum register is split into two parts: \nThe first part consists of $n$ qubits $x$ which represent the domain of the Boolean function $f$ in the computational basis.  \nThe second part of the register contains $m$ qubits $y$ which will be used to represent the values of $f$.\nThe unitary operator implementing the computation of the function table is then defined as:\n\n\n$$\n\\newcommand{\\colVec}[1]{% inline column vector\n\\bigl( \\begin{smallmatrix}#1\\end{smallmatrix}\\bigr)\n}\n\\newcommand{\\bigColVec}[1]{% inline column vector\n\\left( \\begin{matrix}#1\\end{matrix}\\right)\n}\n\\newcommand{\\state}[1]{{\\left| #1 \\right>}}U_f \\left| x,y\\right>=\\left| x, y\\oplus f(x) \\right> $$\nAs described in [Uniform Superposition](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/2229a430-fe92-4411-9d72-d10dd1d8da14), the register is first brought in uniform superposition by initializing it as $\\newcommand{\\state}[1]{{\\left| #1 \\right>}} \\state{0}^{\\otimes n} \\otimes \\left| 0 \\right>^{\\otimes m}$, and applying the Hadamard transformation  $H^{\\otimes n}$ on the first part, leaving the second part of the register in the $\\newcommand{\\state}[1]{{\\left| #1 \\right>}} \\left| 0 \\right>^{\\otimes m}$ state.  \nThen, the operator $U_f$ is applied only once to the complete register generating the following function table:\n\n\n$$\n\\newcommand{\\colVec}[1]{% inline column vector\n\\bigl( \\begin{smallmatrix}#1\\end{smallmatrix}\\bigr)\n}\n\\newcommand{\\bigColVec}[1]{% inline column vector\n\\left( \\begin{matrix}#1\\end{matrix}\\right)\n}\n\\newcommand{\\state}[1]{{\\left| #1 \\right>}} \\state{0}^{\\otimes n}  \\state{0}^{\\otimes m}  \\xrightarrow{H^{\\otimes n} \\otimes I} \\left(  \\frac{1}{\\sqrt{2^n}} \\sum_x \\state{x} \\right) \\otimes \\state{0}^{\\otimes m} $$\n\n\n$$\n\\newcommand{\\colVec}[1]{% inline column vector\n\\bigl( \\begin{smallmatrix}#1\\end{smallmatrix}\\bigr)\n}\n\\newcommand{\\bigColVec}[1]{% inline column vector\n\\left( \\begin{matrix}#1\\end{matrix}\\right)\n}\n\\newcommand{\\state}[1]{{\\left| #1 \\right>}}\\xrightarrow{U_f} \\frac{1}{\\sqrt{2^n}} \\sum_x \\state{x}\\state{f(x)} $$\nIf $f$ is an one-dimensional function (e.g., for solving a decision problem), the register is initialized as $\\newcommand{\\state}[1]{{\\left| #1 \\right>}} \\state{0}^{\\otimes n} \\state{1}$.  \nAfterward, the Hadamard operation is performed on the complete register, i.e. the operator $H^{\\otimes n+1}$ is used.  \nApplication of $U_f$ results in the following state:\n\n\n$$\n\\newcommand{\\colVec}[1]{% inline column vector\n\\bigl( \\begin{smallmatrix}#1\\end{smallmatrix}\\bigr)\n}\n\\newcommand{\\bigColVec}[1]{% inline column vector\n\\left( \\begin{matrix}#1\\end{matrix}\\right)\n}\n\\newcommand{\\state}[1]{{\\left| #1 \\right>}}  \\state{0}^{\\otimes n}  \\state{1}  \\xrightarrow{H^{\\otimes n} \\otimes H} \\left(  \\frac{1}{\\sqrt{2^n}} \\sum_x \\state{x} \\right) \\otimes \\state{-}$$\n\n\n$$\n\\newcommand{\\colVec}[1]{% inline column vector\n\\bigl( \\begin{smallmatrix}#1\\end{smallmatrix}\\bigr)\n}\n\\newcommand{\\bigColVec}[1]{% inline column vector\n\\left( \\begin{matrix}#1\\end{matrix}\\right)\n}\n\\newcommand{\\state}[1]{{\\left| #1 \\right>}}\\xrightarrow{U_f} \\left(  \\frac{1}{\\sqrt{2^n}} \\sum_{x=0}^{2^n-1} (-1)^{f(x)} \\state{x}  \\right) \\otimes \\state{-} $$", "Variants": "Enter your input for this section here.", "Known Uses": "Many algorithms, including the algorithms of Deutsch, Deutsch-Jozsa, Grover, and Shor make use of function tables.\n\n[Deutsch algorithm (PlanQK)](https://platform.planqk.de/algorithms/533c90a5-5fbb-487b-b64d-a8f331aafb10/)\n[Grover''s Algorithm (PlanQK)](https://platform.planqk.de/algorithms/86dfd279-db46-4adb-84a7-39bcf1d19d3a/)\n[Shor''s Algorithm (PlanQK)](https://platform.planqk.de/algorithms/e7413acf-c25e-4de8-ab78-75bfc836a839/)\n", "Related Patterns": "This pattern uses [Initialization](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/312bc9d3-26c0-40ae-b90b-56effd136c0d) and [Uniform Superposition](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/2229a430-fe92-4411-9d72-d10dd1d8da14) to prepare the initial state of the quantum register. \nFunction tables can be further generalized as [Amplitude Amplification](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/96b4d28a-a5ce-4c96-85df-d42587b13c57). \nThe computation of the function table is done by an [Oracle](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/1cc7e9d6-ab37-412e-8afa-604a25de296e). \nOften, [Uncompute](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/d4f7c247-e2bb-4301-ad06-f758fa58f2dc) is required to dissolve the created entanglement for subsequent steps of the algorithm."}', 'https://quantumcomputingpatterns.org/assets/pattern-icons/function_table_icon.png', '{"Alias": "Enter your input for this section here.", "Intent": "Compute a function table of a finite Boolean function", "Result": "For the general case of $m>1$, the register is in a superposition of all data values in the first register and their corresponding data values in the second register. \nIn the special case of a one-dimensional decision function $f$, the register contains a superposition of all computational bases, where the sign indicates the outcome of the decision function: \nA minus sign indicates an outcome of 0 whereas a plus sign indicates an outcome of 1 - this is also referred to as \"phase kickback\".", "Context": "A classical algorithm must evaluate a given function $f:\\{0, 1\\}^n \\rightarrow \\{0, 1\\}^m$ for each value of the domain for computing a function table. \nBy exploiting quantum parallelism, a quantum algorithm is able to compute all values of such a finite Boolean function in a single step. \nThis is useful to speed-up algorithms that reveal global properties of a respective function $f$. \nNote that for $m=1$, a Boolean function $f:\\{0, 1\\}^n \\rightarrow \\{0, 1\\}$ is often an indicator function which can be used to solve a decision problem.", "Solution": "For the computation of the function table, the quantum register is split into two parts: \nThe first part consists of $n$ qubits $x$ which represent the domain of the Boolean function $f$ in the computational basis.  \nThe second part of the register contains $m$ qubits $y$ which will be used to represent the values of $f$.\nThe unitary operator implementing the computation of the function table is then defined as:\n\n\n$$\n\\newcommand{\\colVec}[1]{% inline column vector\n\\bigl( \\begin{smallmatrix}#1\\end{smallmatrix}\\bigr)\n}\n\\newcommand{\\bigColVec}[1]{% inline column vector\n\\left( \\begin{matrix}#1\\end{matrix}\\right)\n}\n\\newcommand{\\state}[1]{{\\left| #1 \\right>}}U_f \\left| x,y\\right>=\\left| x, y\\oplus f(x) \\right> $$\nAs described in [Uniform Superposition](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/2229a430-fe92-4411-9d72-d10dd1d8da14), the register is first brought in uniform superposition by initializing it as $\\newcommand{\\state}[1]{{\\left| #1 \\right>}} \\state{0}^{\\otimes n} \\otimes \\left| 0 \\right>^{\\otimes m}$, and applying the Hadamard transformation  $H^{\\otimes n}$ on the first part, leaving the second part of the register in the $\\newcommand{\\state}[1]{{\\left| #1 \\right>}} \\left| 0 \\right>^{\\otimes m}$ state.  \nThen, the operator $U_f$ is applied only once to the complete register generating the following function table:\n\n\n$$\n\\newcommand{\\colVec}[1]{% inline column vector\n\\bigl( \\begin{smallmatrix}#1\\end{smallmatrix}\\bigr)\n}\n\\newcommand{\\bigColVec}[1]{% inline column vector\n\\left( \\begin{matrix}#1\\end{matrix}\\right)\n}\n\\newcommand{\\state}[1]{{\\left| #1 \\right>}} \\state{0}^{\\otimes n}  \\state{0}^{\\otimes m}  \\xrightarrow{H^{\\otimes n} \\otimes I} \\left(  \\frac{1}{\\sqrt{2^n}} \\sum_x \\state{x} \\right) \\otimes \\state{0}^{\\otimes m} $$\n\n\n$$\n\\newcommand{\\colVec}[1]{% inline column vector\n\\bigl( \\begin{smallmatrix}#1\\end{smallmatrix}\\bigr)\n}\n\\newcommand{\\bigColVec}[1]{% inline column vector\n\\left( \\begin{matrix}#1\\end{matrix}\\right)\n}\n\\newcommand{\\state}[1]{{\\left| #1 \\right>}}\\xrightarrow{U_f} \\frac{1}{\\sqrt{2^n}} \\sum_x \\state{x}\\state{f(x)} $$\nIf $f$ is an one-dimensional function (e.g., for solving a decision problem), the register is initialized as $\\newcommand{\\state}[1]{{\\left| #1 \\right>}} \\state{0}^{\\otimes n} \\state{1}$.  \nAfterward, the Hadamard operation is performed on the complete register, i.e. the operator $H^{\\otimes n+1}$ is used.  \nApplication of $U_f$ results in the following state:\n\n\n$$\n\\newcommand{\\colVec}[1]{% inline column vector\n\\bigl( \\begin{smallmatrix}#1\\end{smallmatrix}\\bigr)\n}\n\\newcommand{\\bigColVec}[1]{% inline column vector\n\\left( \\begin{matrix}#1\\end{matrix}\\right)\n}\n\\newcommand{\\state}[1]{{\\left| #1 \\right>}}  \\state{0}^{\\otimes n}  \\state{1}  \\xrightarrow{H^{\\otimes n} \\otimes H} \\left(  \\frac{1}{\\sqrt{2^n}} \\sum_x \\state{x} \\right) \\otimes \\state{-}$$\n\n\n$$\n\\newcommand{\\colVec}[1]{% inline column vector\n\\bigl( \\begin{smallmatrix}#1\\end{smallmatrix}\\bigr)\n}\n\\newcommand{\\bigColVec}[1]{% inline column vector\n\\left( \\begin{matrix}#1\\end{matrix}\\right)\n}\n\\newcommand{\\state}[1]{{\\left| #1 \\right>}}\\xrightarrow{U_f} \\left(  \\frac{1}{\\sqrt{2^n}} \\sum_{x=0}^{2^n-1} (-1)^{f(x)} \\state{x}  \\right) \\otimes \\state{-} $$", "Variants": "Enter your input for this section here.", "Known Uses": "Many algorithms, including the algorithms of Deutsch, Deutsch-Jozsa, Grover, and Shor make use of function tables.\n\n[Deutsch algorithm (PlanQK)](https://platform.planqk.de/algorithms/533c90a5-5fbb-487b-b64d-a8f331aafb10/)\n[Grover''s Algorithm (PlanQK)](https://platform.planqk.de/algorithms/86dfd279-db46-4adb-84a7-39bcf1d19d3a/)\n[Shor''s Algorithm (PlanQK)](https://platform.planqk.de/algorithms/e7413acf-c25e-4de8-ab78-75bfc836a839/)\n", "Related Patterns": "This pattern uses [Initialization](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/312bc9d3-26c0-40ae-b90b-56effd136c0d) and [Uniform Superposition](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/2229a430-fe92-4411-9d72-d10dd1d8da14) to prepare the initial state of the quantum register. \nFunction tables can be further generalized as [Amplitude Amplification](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/96b4d28a-a5ce-4c96-85df-d42587b13c57). \nThe computation of the function table is done by an [Oracle](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/1cc7e9d6-ab37-412e-8afa-604a25de296e). \nOften, [Uncompute](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/d4f7c247-e2bb-4301-ad06-f758fa58f2dc) is required to dissolve the created entanglement for subsequent steps of the algorithm."}', 'af7780d5-1f97-4536-8da7-4194b093ab1d', 'https://link.springer.com/chapter/10.1007/978-3-030-14082-3_19', false, false, 'circuit-level');
INSERT INTO public.pattern (id, name, uri, content, icon_url, rendered_content, pattern_language_id, paper_ref, deployment_modeling_behavior_pattern, deployment_modeling_structure_pattern, tags) VALUES ('c450e0ce-c55f-4b72-afe9-e9e2c7e4c091', 'Ad-hoc Hybrid Code Execution', 'https://patternpedia.org/patternLanguages/quantumAlgorithmPatterns/ad-hocHybridCodeExecution', '{"Alias": "–", "Forces": "Similar to STANDALONE CIRCUIT EXECUTION. However, using this pattern prevents integrating the classical pre- and post-processing steps. Using local or provider-managed development environments reduces management efforts, e.g., execution of quantum and classical code via single commands.", "Intent": "How to execute quantum circuits with classical pre- and post-processing steps with no additional deployment or integration requirements?", "Result": "This pattern offers developers more control over the execution of quantum and classical parts, e.g., token management or request construction via SDKs, than the STANDALONE CIRCUIT EXECUTION pattern. However, integration with external applications is often limited, which makes it unsuitable for designing larger applications or running several distinct computations. After a successful ad-hoc execution of quantum circuits and their classical pre- and post-processing steps, all artifacts can be packaged and deployed to a compatible offering or published via application marketplaces to simplify their reuse.", "Context": "Often it is necessary to execute standalone quantum circuits with their classical pre- and post-processing steps without incurring extra overhead to deploy, run, and manage them in the cloud.", "Examples": "–", "Solution": "Use provider-managed code editors or local editors with manually-added token-based authentication. Figure 3 shows the execution of quantum circuits and classical code using AD-HOC HYBRID CODE EXECUTION. The classical pre- and post-processing steps run in a local or remote code editor. The quantum circuits are executed via function calls, often provided by the programming language or quantum SDK, transmitting the quantum circuit to the quantum cloud offering.\n\n![Solution Sketch for Ad-hoc Hybrid Code Execution](https://raw.githubusercontent.com/PatternAtlas/pattern-atlas-content/main/sketches/quantum_computing_patterns/ad-hoc-code.svg)", "Known Uses": "This pattern is supported by various vendors. For example, iPython notebooks are provided as remote code editors by Amazon with Braket [[AWS, 2023]](https://docs.aws.amazon.com/braket/latest/developerguide/braket-using.html), IBM with Qiskit [[IBM, 2023b]](https://quantum-computing.ibm.com/lab/docs/iql/), and Google with Cirq [[Google, 2020]](https://colab.research.google.com/github/quantumlib/Cirq/blob/master/docs/tutorials/google/start.ipynb). Local code editors support different languages via dedicated packages, e.g., Rigettis pyQuil and Forest SDK [[Rigetti, 2023a]](https://pyquil-docs.rigetti.com/en/v3.3.3/). Authentication to quantum services is then performed via manual configuration of access tokens.", "Related Pattern": "Classical pre-processing steps include STATE PREPARATION, which can be done using, e.g., BASIS ENCODING or ANGLE ENCODING [[Weigold et al., 2020]](https://hillside.net/plop/2020/papers/weigold.pdf). Post-processing steps comprise, e.g., READOUT ERROR MITIGATION [[Beisel et al., 2022]](https://www.thinkmind.org/index.php?view=article&articleid=patterns_2022_2_10_70007). If multiple quantum circuits must be executed, PRIORITIZED EXECUTION can be used to increase efficiency."}', 'https://raw.githubusercontent.com/PatternAtlas/pattern-atlas-content/main/icons/quantum_computing_patterns/ad-hoc-code-thin.svg', '{"Alias": "–", "Forces": "Similar to STANDALONE CIRCUIT EXECUTION. However, using this pattern prevents integrating the classical pre- and post-processing steps. Using local or provider-managed development environments reduces management efforts, e.g., execution of quantum and classical code via single commands.", "Intent": "How to execute quantum circuits with classical pre- and post-processing steps with no additional deployment or integration requirements?", "Result": "This pattern offers developers more control over the execution of quantum and classical parts, e.g., token management or request construction via SDKs, than the STANDALONE CIRCUIT EXECUTION pattern. However, integration with external applications is often limited, which makes it unsuitable for designing larger applications or running several distinct computations. After a successful ad-hoc execution of quantum circuits and their classical pre- and post-processing steps, all artifacts can be packaged and deployed to a compatible offering or published via application marketplaces to simplify their reuse.", "Context": "Often it is necessary to execute standalone quantum circuits with their classical pre- and post-processing steps without incurring extra overhead to deploy, run, and manage them in the cloud.", "Examples": "–", "Solution": "Use provider-managed code editors or local editors with manually-added token-based authentication. Figure 3 shows the execution of quantum circuits and classical code using AD-HOC HYBRID CODE EXECUTION. The classical pre- and post-processing steps run in a local or remote code editor. The quantum circuits are executed via function calls, often provided by the programming language or quantum SDK, transmitting the quantum circuit to the quantum cloud offering.\n\n![Solution Sketch for Ad-hoc Hybrid Code Execution](https://raw.githubusercontent.com/PatternAtlas/pattern-atlas-content/main/sketches/quantum_computing_patterns/ad-hoc-code.svg)", "Known Uses": "This pattern is supported by various vendors. For example, iPython notebooks are provided as remote code editors by Amazon with Braket [[AWS, 2023]](https://docs.aws.amazon.com/braket/latest/developerguide/braket-using.html), IBM with Qiskit [[IBM, 2023b]](https://quantum-computing.ibm.com/lab/docs/iql/), and Google with Cirq [[Google, 2020]](https://colab.research.google.com/github/quantumlib/Cirq/blob/master/docs/tutorials/google/start.ipynb). Local code editors support different languages via dedicated packages, e.g., Rigettis pyQuil and Forest SDK [[Rigetti, 2023a]](https://pyquil-docs.rigetti.com/en/v3.3.3/). Authentication to quantum services is then performed via manual configuration of access tokens.", "Related Pattern": "Classical pre-processing steps include STATE PREPARATION, which can be done using, e.g., BASIS ENCODING or ANGLE ENCODING [[Weigold et al., 2020]](https://hillside.net/plop/2020/papers/weigold.pdf). Post-processing steps comprise, e.g., READOUT ERROR MITIGATION [[Beisel et al., 2022]](https://www.thinkmind.org/index.php?view=article&articleid=patterns_2022_2_10_70007). If multiple quantum circuits must be executed, PRIORITIZED EXECUTION can be used to increase efficiency."}', 'af7780d5-1f97-4536-8da7-4194b093ab1d', 'https://www.scitepress.org/Link.aspx?doi=10.5220/0012057700003538', NULL, NULL, 'design');
INSERT INTO public.pattern (id, name, uri, content, icon_url, rendered_content, pattern_language_id, paper_ref, deployment_modeling_behavior_pattern, deployment_modeling_structure_pattern, tags) VALUES ('b657ea73-63c0-4800-a69d-a91925e19ac6', 'Alternating Operator Ansatz (AOA)', 'https://patternpedia.org/patternLanguages/reformulatedQuantumComputingPatterns/alternatingOperatorAnsatz(aoa)', '{"Alias": "", "Intent": "\"Approximate the solution of an optimization problem\" [(Weigold et al. 2021)](https://www.springer.com/de/book/9783030648459)\n", "Result": "This approach is applicable for NISQ devices and can be adjusted for a particular problem domain. \nSince NISQ devices are limited by their hardware, only small values for $p$ can be chosen as this hyperparameter determines the width of the circuit.\nNevertheless, choosing suitable mixing and phase-separating operators is not trivial for a problem at hand and, currently, an open research question. The convergence of the solution depends on the chosen operators (based on which the ansatz is constructed), the objective function, and the optimization strategy for updating the parameters. \n\n", "Context": "To solve a combinatorial optimization problem, a bit string $z=z_1\\ldots z_n$ must be found that fulfills a maximum number of $m$ clauses by assigning every binary variable $z_i$ to either 0 or 1. \nEach of the $m$ clauses involves a subset of these variables. \nThe domain, e.g., all feasible solutions, is either every possible bit string $z$ of length $n$ or a subset of the bit strings. \nFor a bit string $z$, the value of the objective function $C(z)$ equals the number of clauses that it fulfills: \n\n\n$$\n\\newcommand{\\colVec}[1]{% inline column vector\n\\bigl( \\begin{smallmatrix}#1\\end{smallmatrix}\\bigr)\n}\n\\newcommand{\\bigColVec}[1]{% inline column vector\n\\left( \\begin{matrix}#1\\end{matrix}\\right)\n}\n\\newcommand{\\state}[1]{{\\left| #1 \\right>}}\n    C(z)=\\sum_{j=1}^m C_{j}(z) \\text{ where }  \n    C_{\\alpha}(z) = \n    \\begin{cases}\n    1,& \\text{if }C_{\\alpha}\\text{ is fulfilled by z}\\\\\n    0,              & \\text{otherwise}\n\\end{cases}\n\n\n$$\n\n\nFor larger problem instances, a brute force approach (which evaluates the objective function of every solution to find the best solution) is computationally too expensive. \nTherefore, a heuristic approach that approximates the best solution is also acceptable. \n\n", "Solution": "An [Variational Quantum Algorithm (VQA)](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/bc795a9b-7977-4e01-b513-f9f5aba38aa7) approach is used to solve the problem: \nAs a first step, the quantum register is initialized with $\\newcommand{\\state}[1]{{\\left| #1 \\right>}} \\state{s}$ (see solution sketch) which is either a single solution or a superposition of multiple solutions. \nPreparing the state $\\newcommand{\\state}[1]{{\\left| #1 \\right>}} \\state{s}$ is assumed to be efficient, i.e., in constant or at most logarithmic depth. \nNote that this assumption does not hold for all quantum states. \nAfter the [Initialization](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/312bc9d3-26c0-40ae-b90b-56effd136c0d), an ansatz is applied. \nTo construct the circuit of the ansatz, a *phase-separating operator* $U(C,\\gamma)$ as well as a *mixing operator* $U(B,\\beta)$ are used where $\\gamma$ and $\\beta$ are the parameter sets.\nThe phase-separating operator applies a [Phase Shift](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/c6560c51-d2e3-4595-b9c3-b609c75c0b82) where the phase of a computational basis state $\\newcommand{\\state}[1]{{\\left| #1 \\right>}} \\state{y}$ is changed according to its value of the objective function $C(y)$:\n\n\n$$\n\\newcommand{\\colVec}[1]{% inline column vector\n\\bigl( \\begin{smallmatrix}#1\\end{smallmatrix}\\bigr)\n}\n\\newcommand{\\bigColVec}[1]{% inline column vector\n\\left( \\begin{matrix}#1\\end{matrix}\\right)\n}\n\\newcommand{\\state}[1]{{\\left| #1 \\right>}}\n     U(C,\\gamma) \\state{y} = f(y)\\state{y}\n$$  \n\n\nE.g., an operator $U(C,\\gamma)$ can be defined that applies a shift for every clause fulfilled by a solution $\\newcommand{\\state}[1]{{\\left| #1 \\right>}} \\state{y}$.  \n\n\nThe second operator is the mixing operator which alters the amplitude of the solutions. \nThereby, it provides transitions between solutions and especially allows to transition between an arbitrary pair of solutions within the problem domain for some well-chosen parameter $\\beta^*$. \nAs a result, this operator \nreflects the domain''s structure. \n\n\nEach iteration on the quantum computer starts with an [Initialization](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/312bc9d3-26c0-40ae-b90b-56effd136c0d) of the state $\\newcommand{\\state}[1]{{\\left| #1 \\right>}} \\state{s}$ and, then, applies an ansatz circuit which is based on $C(\\gamma)$ and $B(\\beta)$. \nThe ansatz circuit consists of $p$ alternating unitaries which are drawn from the operators and lead to the following state: \n\n\n$$\n\\newcommand{\\colVec}[1]{% inline column vector\n\\bigl( \\begin{smallmatrix}#1\\end{smallmatrix}\\bigr)\n}\n\\newcommand{\\bigColVec}[1]{% inline column vector\n\\left( \\begin{matrix}#1\\end{matrix}\\right)\n}\n\\newcommand{\\state}[1]{{\\left| #1 \\right>}}\n\\state{\\gamma, \\beta} = U(B,\\beta_p)U(C,\\gamma_p) \\ldots U(B,\\beta_1)U(C,\\gamma_1) \\state{s}\n$$  \n\n\nIn the first iteration, the parameter sets $\\gamma, \\beta$ are chosen randomly and $p\\in \\mathbb{N}$ defines a hyperparameter.  \nMeasuring this state gives $z$ as a single solution which can be evaluated by the objective function $C$. \nSampling this state allows to determine the expectation values for $\\gamma$ and $\\beta$ which is by definition smaller or equal to the maximum of the objective function:  \n\n\n$$\n\\newcommand{\\state}[1]{{\\left| #1 \\right>}}\n    \\left< C\\right>_{\\state{\\gamma, \\beta}} =\n    \\left< \\gamma, \\beta |C |\\gamma, \\beta \\right>\n    = \\bigg \\langle \\sum x_z \\state{z} \\bigg  |  \\sum x_z f(z)\\state{z} \\bigg \\rangle \\\\\n    = \\sum |x_z|^2 f(z) \\leq \\sum |x_z|^2 f(z'') = f(z'') = C_{max}\n$$\n\n\nBased on the expectation values, the parameters $\\gamma$ and $\\beta$ can be optimized until the termination condition is satisfied. \n", "Variants": "", "Known Uses": "In the original publication [Hadfield et al. 2019](https://www.mdpi.com/1999-4893/12/2/34), various applications of this approach are discussed for different optimization problems. \nUse-cases of this pattern can be found in [Wang et al. 2020](https://link.aps.org/doi/10.1103/PhysRevA.101.012320) and [Fingerhuth, Babej and Ing 2018](https://arxiv.org/abs/1810.13411).\n\n[Quantum approximate optimization algorithm (PlanQK)](https://platform.planqk.de/algorithms/fae60bca-d2b6-4aa2-88b7-58caace34179/)", "Related Patterns": "This pattern is a refinement of [Variational Quantum Algorithm (VQA)](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/bc795a9b-7977-4e01-b513-f9f5aba38aa7); the varied parameters for the ansatz are $\\beta$ and $\\gamma$. \nNote that [Phase Shift](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/c6560c51-d2e3-4595-b9c3-b609c75c0b82) [Leymann 2019](https://www.iaas.uni-stuttgart.de/publications/INPROC-2019-05-Towards_a_Pattern_Language_for_Quantum_Algorithms.pdf) is used within the ansatz to mark solutions based on their value of the objective function. \nTo encode solutions, [Basis Encoding](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/bcd4c7a1-3c92-4f8c-a530-72b8b95d3750) [Weigold et al. 2020](https://hillside.net/plop/2020/papers/weigold.pdf) is used. \nThis pattern can be combined with [Warm Start](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/3ea9e187-e91b-4852-84eb-b35b5c480892).  \n\n"}', 'https://quantumcomputingpatterns.org/assets/pattern-icons/aoa_icon.png', '{"Alias": "", "Intent": "\"Approximate the solution of an optimization problem\" [(Weigold et al. 2021)](https://www.springer.com/de/book/9783030648459)\n", "Result": "This approach is applicable for NISQ devices and can be adjusted for a particular problem domain. \nSince NISQ devices are limited by their hardware, only small values for $p$ can be chosen as this hyperparameter determines the width of the circuit.\nNevertheless, choosing suitable mixing and phase-separating operators is not trivial for a problem at hand and, currently, an open research question. The convergence of the solution depends on the chosen operators (based on which the ansatz is constructed), the objective function, and the optimization strategy for updating the parameters. \n\n", "Context": "To solve a combinatorial optimization problem, a bit string $z=z_1\\ldots z_n$ must be found that fulfills a maximum number of $m$ clauses by assigning every binary variable $z_i$ to either 0 or 1. \nEach of the $m$ clauses involves a subset of these variables. \nThe domain, e.g., all feasible solutions, is either every possible bit string $z$ of length $n$ or a subset of the bit strings. \nFor a bit string $z$, the value of the objective function $C(z)$ equals the number of clauses that it fulfills: \n\n\n$$\n\\newcommand{\\colVec}[1]{% inline column vector\n\\bigl( \\begin{smallmatrix}#1\\end{smallmatrix}\\bigr)\n}\n\\newcommand{\\bigColVec}[1]{% inline column vector\n\\left( \\begin{matrix}#1\\end{matrix}\\right)\n}\n\\newcommand{\\state}[1]{{\\left| #1 \\right>}}\n    C(z)=\\sum_{j=1}^m C_{j}(z) \\text{ where }  \n    C_{\\alpha}(z) = \n    \\begin{cases}\n    1,& \\text{if }C_{\\alpha}\\text{ is fulfilled by z}\\\\\n    0,              & \\text{otherwise}\n\\end{cases}\n\n\n$$\n\n\nFor larger problem instances, a brute force approach (which evaluates the objective function of every solution to find the best solution) is computationally too expensive. \nTherefore, a heuristic approach that approximates the best solution is also acceptable. \n\n", "Solution": "An [Variational Quantum Algorithm (VQA)](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/bc795a9b-7977-4e01-b513-f9f5aba38aa7) approach is used to solve the problem: \nAs a first step, the quantum register is initialized with $\\newcommand{\\state}[1]{{\\left| #1 \\right>}} \\state{s}$ (see solution sketch) which is either a single solution or a superposition of multiple solutions. \nPreparing the state $\\newcommand{\\state}[1]{{\\left| #1 \\right>}} \\state{s}$ is assumed to be efficient, i.e., in constant or at most logarithmic depth. \nNote that this assumption does not hold for all quantum states. \nAfter the [Initialization](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/312bc9d3-26c0-40ae-b90b-56effd136c0d), an ansatz is applied. \nTo construct the circuit of the ansatz, a *phase-separating operator* $U(C,\\gamma)$ as well as a *mixing operator* $U(B,\\beta)$ are used where $\\gamma$ and $\\beta$ are the parameter sets.\nThe phase-separating operator applies a [Phase Shift](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/c6560c51-d2e3-4595-b9c3-b609c75c0b82) where the phase of a computational basis state $\\newcommand{\\state}[1]{{\\left| #1 \\right>}} \\state{y}$ is changed according to its value of the objective function $C(y)$:\n\n\n$$\n\\newcommand{\\colVec}[1]{% inline column vector\n\\bigl( \\begin{smallmatrix}#1\\end{smallmatrix}\\bigr)\n}\n\\newcommand{\\bigColVec}[1]{% inline column vector\n\\left( \\begin{matrix}#1\\end{matrix}\\right)\n}\n\\newcommand{\\state}[1]{{\\left| #1 \\right>}}\n     U(C,\\gamma) \\state{y} = f(y)\\state{y}\n$$  \n\n\nE.g., an operator $U(C,\\gamma)$ can be defined that applies a shift for every clause fulfilled by a solution $\\newcommand{\\state}[1]{{\\left| #1 \\right>}} \\state{y}$.  \n\n\nThe second operator is the mixing operator which alters the amplitude of the solutions. \nThereby, it provides transitions between solutions and especially allows to transition between an arbitrary pair of solutions within the problem domain for some well-chosen parameter $\\beta^*$. \nAs a result, this operator \nreflects the domain''s structure. \n\n\nEach iteration on the quantum computer starts with an [Initialization](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/312bc9d3-26c0-40ae-b90b-56effd136c0d) of the state $\\newcommand{\\state}[1]{{\\left| #1 \\right>}} \\state{s}$ and, then, applies an ansatz circuit which is based on $C(\\gamma)$ and $B(\\beta)$. \nThe ansatz circuit consists of $p$ alternating unitaries which are drawn from the operators and lead to the following state: \n\n\n$$\n\\newcommand{\\colVec}[1]{% inline column vector\n\\bigl( \\begin{smallmatrix}#1\\end{smallmatrix}\\bigr)\n}\n\\newcommand{\\bigColVec}[1]{% inline column vector\n\\left( \\begin{matrix}#1\\end{matrix}\\right)\n}\n\\newcommand{\\state}[1]{{\\left| #1 \\right>}}\n\\state{\\gamma, \\beta} = U(B,\\beta_p)U(C,\\gamma_p) \\ldots U(B,\\beta_1)U(C,\\gamma_1) \\state{s}\n$$  \n\n\nIn the first iteration, the parameter sets $\\gamma, \\beta$ are chosen randomly and $p\\in \\mathbb{N}$ defines a hyperparameter.  \nMeasuring this state gives $z$ as a single solution which can be evaluated by the objective function $C$. \nSampling this state allows to determine the expectation values for $\\gamma$ and $\\beta$ which is by definition smaller or equal to the maximum of the objective function:  \n\n\n$$\n\\newcommand{\\state}[1]{{\\left| #1 \\right>}}\n    \\left< C\\right>_{\\state{\\gamma, \\beta}} =\n    \\left< \\gamma, \\beta |C |\\gamma, \\beta \\right>\n    = \\bigg \\langle \\sum x_z \\state{z} \\bigg  |  \\sum x_z f(z)\\state{z} \\bigg \\rangle \\\\\n    = \\sum |x_z|^2 f(z) \\leq \\sum |x_z|^2 f(z'') = f(z'') = C_{max}\n$$\n\n\nBased on the expectation values, the parameters $\\gamma$ and $\\beta$ can be optimized until the termination condition is satisfied. \n", "Variants": "", "Known Uses": "In the original publication [Hadfield et al. 2019](https://www.mdpi.com/1999-4893/12/2/34), various applications of this approach are discussed for different optimization problems. \nUse-cases of this pattern can be found in [Wang et al. 2020](https://link.aps.org/doi/10.1103/PhysRevA.101.012320) and [Fingerhuth, Babej and Ing 2018](https://arxiv.org/abs/1810.13411).\n\n[Quantum approximate optimization algorithm (PlanQK)](https://platform.planqk.de/algorithms/fae60bca-d2b6-4aa2-88b7-58caace34179/)", "Related Patterns": "This pattern is a refinement of [Variational Quantum Algorithm (VQA)](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/bc795a9b-7977-4e01-b513-f9f5aba38aa7); the varied parameters for the ansatz are $\\beta$ and $\\gamma$. \nNote that [Phase Shift](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/c6560c51-d2e3-4595-b9c3-b609c75c0b82) [Leymann 2019](https://www.iaas.uni-stuttgart.de/publications/INPROC-2019-05-Towards_a_Pattern_Language_for_Quantum_Algorithms.pdf) is used within the ansatz to mark solutions based on their value of the objective function. \nTo encode solutions, [Basis Encoding](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/bcd4c7a1-3c92-4f8c-a530-72b8b95d3750) [Weigold et al. 2020](https://hillside.net/plop/2020/papers/weigold.pdf) is used. \nThis pattern can be combined with [Warm Start](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/3ea9e187-e91b-4852-84eb-b35b5c480892).  \n\n"}', 'af7780d5-1f97-4536-8da7-4194b093ab1d', 'Weigold, M.; Barzen, J.; Leymann, F.; and Vietz, D: Patterns For Hybrid Quantum Algorithms. In: Proceedings of the 15th Symposium and Summer School on Service-Oriented Computing (SummerSOC 2021), https://doi.org/10.1007/978-3-030-87568-8_2', false, false, 'algorithm');
INSERT INTO public.pattern (id, name, uri, content, icon_url, rendered_content, pattern_language_id, paper_ref, deployment_modeling_behavior_pattern, deployment_modeling_structure_pattern, tags) VALUES ('96b4d28a-a5ce-4c96-85df-d42587b13c57', 'Amplitude Amplification', 'https://patternpedia.org/patternLanguages/reformulatedQuantumComputingPatterns/amplitudeAmplification', '{"Alias": "", "Intent": "Increase the probability of finding a solution", "Result": "The probability of measuring a solution is increased.", "Context": "For a specific indicator function $f$ the corresponding function table may list all possible solutions of a problem, i.e.  $f(x)=1 \\Leftrightarrow x$ is a solution to the problem.  \nWhen the corresponding state is measured, a solution can be found with a certain probability.\nSince measuring destroys the state, the computation has to be repeated if no solution is found by the measurement in order to be able to do another measurement of the state.\nTo keep computational costs low, a mechanism without measurements is required. ", "Solution": "The overall state is transformed such that the probability of measuring certain values of interest increases with every iteration by modifying their amplitude [(Brassard et al. 2002)](https://arxiv.org/abs/quant-ph/0005055).\nThis is done via the help of a phase shift $S_G^\\pi$, which changes the sign of the phase of elements in the set of solutions $G$ while all other elements remain unchanged.\nAnother phase shift that is used is $S_0^\\pi$ which changes only the sign of the zero state $\\newcommand{\\state}[1]{{\\left| #1 \\right>}} \\state{0}$.\nSuppose there is an algorithm $U$ for computing approximate solutions (without any measurements).\nThe following unitary operation can be defined: \n\n\n$$\n\\newcommand{\\colVec}[1]{% inline column vector\n\\bigl( \\begin{smallmatrix}#1\\end{smallmatrix}\\bigr)\n}\n\\newcommand{\\bigColVec}[1]{% inline column vector\n\\left( \\begin{matrix}#1\\end{matrix}\\right)\n}\n\\newcommand{\\state}[1]{{\\left| #1 \\right>}}Q = -U S_0^\\pi U^{-1} S_G^\\pi$$\nIf the success probability of the algorithm $U$ is $t$, the average amount of iterations required to find a solution is $1/t$.\nIt is assumed that $\\newcommand{\\state}[1]{{\\left| #1 \\right>}}U\\state{0}$ has a non-zero amplitude in $G$, otherwise, there cannot be a speedup.\nIf U indeed has this property, the above-defined unitary operation $Q$ will create a solution within $O(\\sqrt{1/t})$ iterations, i.e., a quadratic speedup can be achieved.\nThe amount of iterations to be realized by $Q$ is about $\\newcommand{\\state}[1]{{\\left| #1 \\right>}} \\frac{\\pi}{4} \\frac{1}{P_G U \\state{0}}$,\nwhere $P_G$ is the projection onto the subspace spanned by $G$.\n\n", "Variants": "", "Known Uses": "Examples of algorithms that use amplitude amplification are the algorithms of Grover and Simon, as well as the HHL algorithm [(Harrow, Hassidim and Lloyd 2009)](https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.103.150502).\nAmplitude amplification is also used in the state preparation algorithm of [(Sanders et al. 2019)](https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.122.020502).\nIn [(Brassard et al. 2002)](https://arxiv.org/abs/quant-ph/0005055), more algorithms making use of amplitude amplification are discussed.\n\n[Grover''s Algorithm (PlanQK)](https://platform.planqk.de/algorithms/86dfd279-db46-4adb-84a7-39bcf1d19d3a/)\n[HHL Algorithm (PlanQK)](https://platform.planqk.de/algorithms/8c6909bd-a258-4702-8356-6ef28321a826/)\n", "Related Patterns": "A [Function Table](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/3f3fabf0-7fa7-4b43-a74a-46a7ac2c55ee) $S_G^\\pi$ which is also a special case of a [Phase Shift](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/c6560c51-d2e3-4595-b9c3-b609c75c0b82) is used within the unitary operation $Q$.\nA unitary operation that implements amplitude amplifications can be provided as an [Oracle](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/1cc7e9d6-ab37-412e-8afa-604a25de296e).\n\n"}', 'https://quantumcomputingpatterns.org/assets/pattern-icons/amplitude_amplification_icon.png', '{"Alias": "", "Intent": "Increase the probability of finding a solution", "Result": "The probability of measuring a solution is increased.", "Context": "For a specific indicator function $f$ the corresponding function table may list all possible solutions of a problem, i.e.  $f(x)=1 \\Leftrightarrow x$ is a solution to the problem.  \nWhen the corresponding state is measured, a solution can be found with a certain probability.\nSince measuring destroys the state, the computation has to be repeated if no solution is found by the measurement in order to be able to do another measurement of the state.\nTo keep computational costs low, a mechanism without measurements is required. ", "Solution": "The overall state is transformed such that the probability of measuring certain values of interest increases with every iteration by modifying their amplitude [(Brassard et al. 2002)](https://arxiv.org/abs/quant-ph/0005055).\nThis is done via the help of a phase shift $S_G^\\pi$, which changes the sign of the phase of elements in the set of solutions $G$ while all other elements remain unchanged.\nAnother phase shift that is used is $S_0^\\pi$ which changes only the sign of the zero state $\\newcommand{\\state}[1]{{\\left| #1 \\right>}} \\state{0}$.\nSuppose there is an algorithm $U$ for computing approximate solutions (without any measurements).\nThe following unitary operation can be defined: \n\n\n$$\n\\newcommand{\\colVec}[1]{% inline column vector\n\\bigl( \\begin{smallmatrix}#1\\end{smallmatrix}\\bigr)\n}\n\\newcommand{\\bigColVec}[1]{% inline column vector\n\\left( \\begin{matrix}#1\\end{matrix}\\right)\n}\n\\newcommand{\\state}[1]{{\\left| #1 \\right>}}Q = -U S_0^\\pi U^{-1} S_G^\\pi$$\nIf the success probability of the algorithm $U$ is $t$, the average amount of iterations required to find a solution is $1/t$.\nIt is assumed that $\\newcommand{\\state}[1]{{\\left| #1 \\right>}}U\\state{0}$ has a non-zero amplitude in $G$, otherwise, there cannot be a speedup.\nIf U indeed has this property, the above-defined unitary operation $Q$ will create a solution within $O(\\sqrt{1/t})$ iterations, i.e., a quadratic speedup can be achieved.\nThe amount of iterations to be realized by $Q$ is about $\\newcommand{\\state}[1]{{\\left| #1 \\right>}} \\frac{\\pi}{4} \\frac{1}{P_G U \\state{0}}$,\nwhere $P_G$ is the projection onto the subspace spanned by $G$.\n\n", "Variants": "", "Known Uses": "Examples of algorithms that use amplitude amplification are the algorithms of Grover and Simon, as well as the HHL algorithm [(Harrow, Hassidim and Lloyd 2009)](https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.103.150502).\nAmplitude amplification is also used in the state preparation algorithm of [(Sanders et al. 2019)](https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.122.020502).\nIn [(Brassard et al. 2002)](https://arxiv.org/abs/quant-ph/0005055), more algorithms making use of amplitude amplification are discussed.\n\n[Grover''s Algorithm (PlanQK)](https://platform.planqk.de/algorithms/86dfd279-db46-4adb-84a7-39bcf1d19d3a/)\n[HHL Algorithm (PlanQK)](https://platform.planqk.de/algorithms/8c6909bd-a258-4702-8356-6ef28321a826/)\n", "Related Patterns": "A [Function Table](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/3f3fabf0-7fa7-4b43-a74a-46a7ac2c55ee) $S_G^\\pi$ which is also a special case of a [Phase Shift](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/c6560c51-d2e3-4595-b9c3-b609c75c0b82) is used within the unitary operation $Q$.\nA unitary operation that implements amplitude amplifications can be provided as an [Oracle](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/1cc7e9d6-ab37-412e-8afa-604a25de296e).\n\n"}', 'af7780d5-1f97-4536-8da7-4194b093ab1d', 'https://link.springer.com/chapter/10.1007/978-3-030-14082-3_19', false, false, 'circuit-level');
INSERT INTO public.pattern (id, name, uri, content, icon_url, rendered_content, pattern_language_id, paper_ref, deployment_modeling_behavior_pattern, deployment_modeling_structure_pattern, tags) VALUES ('502147ec-45fa-403f-8f52-e196b3359399', 'Amplitude Encoding', 'https://patternpedia.org/patternLanguages/reformulatedQuantumComputingPatterns/amplitudeEncoding', '{"Alias": "This encoding has also been referred to as Wavefunction Encoding by [(LaRose and Coyle 2020)](https://journals.aps.org/pra/abstract/10.1103/PhysRevA.102.032420). Every quantum system is described by its wavefunction $\\psi$ which also defines the measurement probabilities. By expressing that the wavefunction is used to encode data, it is therefore implied that amplitudes of the quantum system are used to represent data values.", "Intent": "Encode data in a compact manner that do not require calculations", "Result": "A data input vector of length $l$ can be represented by $\\lceil log_2(l)\\rceil$ qubits - this is indeed a very compact representation. For an arbitrary state represented by $n$ qubits (which represents $2^n$ data values), it is known that at least $2^n$ parallel operations are needed [(Schuld and Petruccione 2018)](https://www.springer.com/gp/book/9783319964232). Current state preparation routines perform slightly better than $2^n$ operations [(Schuld and Petruccione 2018)](https://www.springer.com/gp/book/9783319964232). However, depending on the data it maystill be possible to realize an encoding in a logarithmic runtime. For example, a [Uniform Superposition](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/2229a430-fe92-4411-9d72-d10dd1d8da14) can be created by applying a Hadamard gate to each of the $n$ qubits - which can be done in parallel and thus in a single step. This represents a $2^n$-dimensional vector in which all data entries are $\\frac{1}{\\sqrt{n}}$. Similarly, sparse data vectors can also be prepared more efficiently [(Schuld and Petruccione 2018)](https://www.springer.com/gp/book/9783319964232).It must be noted that if the output is also encoded in the amplitude, multiple measurements must be taken toobtain a good estimate of the output result. The number of measurements scales with the number of amplitudes -as $n$ qubits contain $2^n$ amplitudes, this is costly [(Schuld and Petruccione 2018)](https://www.springer.com/gp/book/9783319964232).", "Context": "A numerical input data vector $(x_0, \\ldots, x_{n-1})^T$ must be encoded for an algorithm.", "Solution": "Use amplitudes to encode the data. As the squared moduli of the amplitudes of a quantum state must sum up to 1, the input vector needs to be normalized to length 1. This is illustrated in Fig. 5 for a 2-dimensional input vector that contains 2 data points. To associate each amplitude with a component of the input vector, the dimension of the vector must be equal to a power of two because the vector space of an $n$ qubit register has dimension $2^n$. If this is not the case, the input vector can be padded with additional zeros to increase the dimension of it. Using a suitable state preparation routine (see Known Uses), the input vector is encoded in the amplitudes of the quantum state as follows: \n$| \\psi \\rangle  = \\sum_{i=0}^{n-1} x_i | i \\rangle$.\nAs the amplitudes depend on the data, the process of encoding the data (but not the encoding itself) is often referred to as arbitrary state preparation.\n\n![](https://quantumcomputingpatterns.org/assets/sketches/amplitude_encoding_solution.png)\n\nPattern sketch, taken from: Weigold, Manuela; Barzen, Johanna; Leymann, Frank; Salm, Marie: [Data Encoding Patterns for Quantum Algorithms.](https://hillside.net/plop/2020/papers/weigold.pdf) In: The Hillside Group (Hrsg): Proceedings of the 27th Conference on Pattern Languages of Programs (PLoP ''20).\n", "Variants": "Enter your input for this section here.", "Known Uses": "[Amplitude Encoding](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/502147ec-45fa-403f-8f52-e196b3359399) is required by many quantum machine learning algorithms [(LaRose and Coyle 2020)](https://journals.aps.org/pra/abstract/10.1103/PhysRevA.102.032420). Another example is the algorithm of Harrow, Hassidim and Lloyd [(Harrow, Hassidim and Lloyd 2009)](https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.103.150502) (often referred to as HHL algorithm) for solving linear equations. The pre-condition that the data values can be normalized is a common assumption in machine learning [(Schuld et al. 2017)](http://dx.doi.org/10.1209/0295-5075/119/60002), e.g. in support vector machine.There are various ways to construct a state preparation routine for this encoding. For example, [(Plesch and Brukner 2011)](http://dx.doi.org/10.1103/PhysRevA.83.032302) and [(Iten et al. 2016)](http://dx.doi.org/10.1103/PhysRevA.93.032318) use the Schmidt Decomposition. For the latter, an implementation in Mathematica was presented [(Iten et al. 2019)](https://arxiv.org/abs/1904.01072). [(Shende et al. 2006)](https://ieeexplore.ieee.org/document/1629135) presented an alternative way to construct an arbitrary quantum state which was implemented by Qiskit [(Qis 2020)](https://qiskit.org/documentation/tutorials/circuits/3_summary_of_quantum_operations). PennyLane offers a loading routine for [Amplitude Encoding](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/502147ec-45fa-403f-8f52-e196b3359399) [Pen 2020](https://pennylane.readthedocs.io/en/stable/introduction/templates.html). The library also includes an arbitrary state preparation routine that uses the algorithm proposed by [(Möttönen and Vartiainen 2005)](https://arxiv.org/abs/quant-ph/0504100). The state preparation routine by [(Möttönen and Vartiainen 2005)](https://arxiv.org/abs/quant-ph/0504100) requires an exponential number of operations to encode $2^n$ data values. Q# provides functionality to compute a state preparation routine that approximates the desired amplitude encoding [(QSh 2020)](https://docs.microsoft.com/en-us/qsharp/api/).\n\n[Hybrid Transfer Learning (PlanQK)](https://platform.planqk.de/algorithms/2803f6d4-094e-4aa9-b09d-5847fba03d21/)\n[HHL Algorithm (PlanQK)](https://platform.planqk.de/algorithms/8c6909bd-a258-4702-8356-6ef28321a826/)", "Related Patterns": "This pattern refines [Initialization](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/312bc9d3-26c0-40ae-b90b-56effd136c0d). The encoding is more compact (in terms of qubits) than [Basis Encoding](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/bcd4c7a1-3c92-4f8c-a530-72b8b95d3750), [Angle Encoding](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/e595558d-bfea-4b82-9f47-a38a2097b245) or  [Quantum Random Access Memory (QRAM) Encoding](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/d9c57511-1101-4707-99bf-36f43a12cb13)."}', 'https://quantumcomputingpatterns.org/assets/pattern-icons/amplitude_encoding_icon.png', '{"Alias": "This encoding has also been referred to as Wavefunction Encoding by [(LaRose and Coyle 2020)](https://journals.aps.org/pra/abstract/10.1103/PhysRevA.102.032420). Every quantum system is described by its wavefunction $\\psi$ which also defines the measurement probabilities. By expressing that the wavefunction is used to encode data, it is therefore implied that amplitudes of the quantum system are used to represent data values.", "Intent": "Encode data in a compact manner that do not require calculations", "Result": "A data input vector of length $l$ can be represented by $\\lceil log_2(l)\\rceil$ qubits - this is indeed a very compact representation. For an arbitrary state represented by $n$ qubits (which represents $2^n$ data values), it is known that at least $2^n$ parallel operations are needed [(Schuld and Petruccione 2018)](https://www.springer.com/gp/book/9783319964232). Current state preparation routines perform slightly better than $2^n$ operations [(Schuld and Petruccione 2018)](https://www.springer.com/gp/book/9783319964232). However, depending on the data it maystill be possible to realize an encoding in a logarithmic runtime. For example, a [Uniform Superposition](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/2229a430-fe92-4411-9d72-d10dd1d8da14) can be created by applying a Hadamard gate to each of the $n$ qubits - which can be done in parallel and thus in a single step. This represents a $2^n$-dimensional vector in which all data entries are $\\frac{1}{\\sqrt{n}}$. Similarly, sparse data vectors can also be prepared more efficiently [(Schuld and Petruccione 2018)](https://www.springer.com/gp/book/9783319964232).It must be noted that if the output is also encoded in the amplitude, multiple measurements must be taken toobtain a good estimate of the output result. The number of measurements scales with the number of amplitudes -as $n$ qubits contain $2^n$ amplitudes, this is costly [(Schuld and Petruccione 2018)](https://www.springer.com/gp/book/9783319964232).", "Context": "A numerical input data vector $(x_0, \\ldots, x_{n-1})^T$ must be encoded for an algorithm.", "Solution": "Use amplitudes to encode the data. As the squared moduli of the amplitudes of a quantum state must sum up to 1, the input vector needs to be normalized to length 1. This is illustrated in Fig. 5 for a 2-dimensional input vector that contains 2 data points. To associate each amplitude with a component of the input vector, the dimension of the vector must be equal to a power of two because the vector space of an $n$ qubit register has dimension $2^n$. If this is not the case, the input vector can be padded with additional zeros to increase the dimension of it. Using a suitable state preparation routine (see Known Uses), the input vector is encoded in the amplitudes of the quantum state as follows: \n$| \\psi \\rangle  = \\sum_{i=0}^{n-1} x_i | i \\rangle$.\nAs the amplitudes depend on the data, the process of encoding the data (but not the encoding itself) is often referred to as arbitrary state preparation.\n\n![](https://quantumcomputingpatterns.org/assets/sketches/amplitude_encoding_solution.png)\n\nPattern sketch, taken from: Weigold, Manuela; Barzen, Johanna; Leymann, Frank; Salm, Marie: [Data Encoding Patterns for Quantum Algorithms.](https://hillside.net/plop/2020/papers/weigold.pdf) In: The Hillside Group (Hrsg): Proceedings of the 27th Conference on Pattern Languages of Programs (PLoP ''20).\n", "Variants": "Enter your input for this section here.", "Known Uses": "[Amplitude Encoding](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/502147ec-45fa-403f-8f52-e196b3359399) is required by many quantum machine learning algorithms [(LaRose and Coyle 2020)](https://journals.aps.org/pra/abstract/10.1103/PhysRevA.102.032420). Another example is the algorithm of Harrow, Hassidim and Lloyd [(Harrow, Hassidim and Lloyd 2009)](https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.103.150502) (often referred to as HHL algorithm) for solving linear equations. The pre-condition that the data values can be normalized is a common assumption in machine learning [(Schuld et al. 2017)](http://dx.doi.org/10.1209/0295-5075/119/60002), e.g. in support vector machine.There are various ways to construct a state preparation routine for this encoding. For example, [(Plesch and Brukner 2011)](http://dx.doi.org/10.1103/PhysRevA.83.032302) and [(Iten et al. 2016)](http://dx.doi.org/10.1103/PhysRevA.93.032318) use the Schmidt Decomposition. For the latter, an implementation in Mathematica was presented [(Iten et al. 2019)](https://arxiv.org/abs/1904.01072). [(Shende et al. 2006)](https://ieeexplore.ieee.org/document/1629135) presented an alternative way to construct an arbitrary quantum state which was implemented by Qiskit [(Qis 2020)](https://qiskit.org/documentation/tutorials/circuits/3_summary_of_quantum_operations). PennyLane offers a loading routine for [Amplitude Encoding](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/502147ec-45fa-403f-8f52-e196b3359399) [Pen 2020](https://pennylane.readthedocs.io/en/stable/introduction/templates.html). The library also includes an arbitrary state preparation routine that uses the algorithm proposed by [(Möttönen and Vartiainen 2005)](https://arxiv.org/abs/quant-ph/0504100). The state preparation routine by [(Möttönen and Vartiainen 2005)](https://arxiv.org/abs/quant-ph/0504100) requires an exponential number of operations to encode $2^n$ data values. Q# provides functionality to compute a state preparation routine that approximates the desired amplitude encoding [(QSh 2020)](https://docs.microsoft.com/en-us/qsharp/api/).\n\n[Hybrid Transfer Learning (PlanQK)](https://platform.planqk.de/algorithms/2803f6d4-094e-4aa9-b09d-5847fba03d21/)\n[HHL Algorithm (PlanQK)](https://platform.planqk.de/algorithms/8c6909bd-a258-4702-8356-6ef28321a826/)", "Related Patterns": "This pattern refines [Initialization](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/312bc9d3-26c0-40ae-b90b-56effd136c0d). The encoding is more compact (in terms of qubits) than [Basis Encoding](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/bcd4c7a1-3c92-4f8c-a530-72b8b95d3750), [Angle Encoding](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/e595558d-bfea-4b82-9f47-a38a2097b245) or  [Quantum Random Access Memory (QRAM) Encoding](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/d9c57511-1101-4707-99bf-36f43a12cb13)."}', 'af7780d5-1f97-4536-8da7-4194b093ab1d', 'Weigold, M.; Barzen, J.; Leymann, F.; Salm, M.: Data Encoding Patterns for Quantum Algorithms. In: The Hillside Group (Hrsg): Proceedings of the 27th Conference on Pattern Languages of Programs (PLoP ''20), https://hillside.net/plop/2020/papers/weigold.pdf', false, false, 'encoding');
INSERT INTO public.pattern (id, name, uri, content, icon_url, rendered_content, pattern_language_id, paper_ref, deployment_modeling_behavior_pattern, deployment_modeling_structure_pattern, tags) VALUES ('1cc7e9d6-ab37-412e-8afa-604a25de296e', 'Oracle', 'https://patternpedia.org/patternLanguages/reformulatedQuantumComputingPatterns/oracle', '{"Alias": "This pattern has also been referred to as Black Box.", "Intent": "Re-use a computation of a quantum algorithm without necessarily knowing the implementation.", "Result": "Concrete implementations of oracles add to the overall depth to the overall quantum algorithm but are often neglected in the runtime of an oracle-based algorithm.  ", "Context": "A Divide-and-Conquer approach is a commonly used method that simplifies solving a  complex problem.   \nIn such an approach, an oracle can be used as an reusable part of a quantum algorithm - a black blox with hidden internals.\nMultiple oracles can be used as building blocks to compose larger algorithms.", "Solution": "The concrete implementation of an oracle is highly problem-specific.\nAs a consequence, there are many different types of oracles, of which several are discussed in [(Gilyen et al. 2019)](https://epubs.siam.org/doi/abs/10.1137/1.9781611975482.87). ", "Variants": "Enter your input for this section here.", "Known Uses": "Oracles are used in the algorithms of Deutsch, Deutsch-Jozsa, Bernstein-Vazirani,  Simon,  Grover, and many others. In [(Mosca 2008)](https://arxiv.org/abs/0808.0369), further usages are given.   \n\n[Shor''s Algorithm (PlanQK)](https://platform.planqk.de/algorithms/e7413acf-c25e-4de8-ab78-75bfc836a839/)\n[Grover''s Algorithm (PlanQK)](https://platform.planqk.de/algorithms/86dfd279-db46-4adb-84a7-39bcf1d19d3a/)\n[Dürr-Høyer Quantum Minimization Algorithm (PlanQK)](https://platform.planqk.de/algorithms/061f4eb3-d9ee-4f47-befc-9e242bf801ce/)\n[Deutsch algorithm (PlanQK)](https://platform.planqk.de/algorithms/533c90a5-5fbb-487b-b64d-a8f331aafb10/)\n[HHL Algorithm (PlanQK)](https://platform.planqk.de/algorithms/8c6909bd-a258-4702-8356-6ef28321a826/)", "Related Patterns": "An oracle requires correct [Initialization](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/312bc9d3-26c0-40ae-b90b-56effd136c0d) of the problem-specific input. \nTypically, an [Uncompute](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/d4f7c247-e2bb-4301-ad06-f758fa58f2dc) is used after an oracle was applied."}', 'https://quantumcomputingpatterns.org/assets/pattern-icons/oracle_icon.png', '{"Alias": "This pattern has also been referred to as Black Box.", "Intent": "Re-use a computation of a quantum algorithm without necessarily knowing the implementation.", "Result": "Concrete implementations of oracles add to the overall depth to the overall quantum algorithm but are often neglected in the runtime of an oracle-based algorithm.  ", "Context": "A Divide-and-Conquer approach is a commonly used method that simplifies solving a  complex problem.   \nIn such an approach, an oracle can be used as an reusable part of a quantum algorithm - a black blox with hidden internals.\nMultiple oracles can be used as building blocks to compose larger algorithms.", "Solution": "The concrete implementation of an oracle is highly problem-specific.\nAs a consequence, there are many different types of oracles, of which several are discussed in [(Gilyen et al. 2019)](https://epubs.siam.org/doi/abs/10.1137/1.9781611975482.87). ", "Variants": "Enter your input for this section here.", "Known Uses": "Oracles are used in the algorithms of Deutsch, Deutsch-Jozsa, Bernstein-Vazirani,  Simon,  Grover, and many others. In [(Mosca 2008)](https://arxiv.org/abs/0808.0369), further usages are given.   \n\n[Shor''s Algorithm (PlanQK)](https://platform.planqk.de/algorithms/e7413acf-c25e-4de8-ab78-75bfc836a839/)\n[Grover''s Algorithm (PlanQK)](https://platform.planqk.de/algorithms/86dfd279-db46-4adb-84a7-39bcf1d19d3a/)\n[Dürr-Høyer Quantum Minimization Algorithm (PlanQK)](https://platform.planqk.de/algorithms/061f4eb3-d9ee-4f47-befc-9e242bf801ce/)\n[Deutsch algorithm (PlanQK)](https://platform.planqk.de/algorithms/533c90a5-5fbb-487b-b64d-a8f331aafb10/)\n[HHL Algorithm (PlanQK)](https://platform.planqk.de/algorithms/8c6909bd-a258-4702-8356-6ef28321a826/)", "Related Patterns": "An oracle requires correct [Initialization](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/312bc9d3-26c0-40ae-b90b-56effd136c0d) of the problem-specific input. \nTypically, an [Uncompute](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/d4f7c247-e2bb-4301-ad06-f758fa58f2dc) is used after an oracle was applied."}', 'af7780d5-1f97-4536-8da7-4194b093ab1d', 'https://link.springer.com/chapter/10.1007/978-3-030-14082-3_19', false, false, 'circuit-level');
INSERT INTO public.pattern (id, name, uri, content, icon_url, rendered_content, pattern_language_id, paper_ref, deployment_modeling_behavior_pattern, deployment_modeling_structure_pattern, tags) VALUES ('3f3d5582-1af9-4a23-93f5-5d0474b2b42c', 'Orchestrated Execution', 'https://patternpedia.org/patternLanguages/quantumAlgorithmPatterns/orchestratedExecution', '{"Alias": "–", "Forces": "Quantum devices and the corresponding quantum cloud offerings vary strongly in characteristics, such as the number of available qubits, incurred costs for the execution, or queuing times [[Tannu and Qureshi, 2019]](https://dl.acm.org/doi/10.1145/3297858.3304007), [[Vietz et al., 2021]](http://ceur-ws.org/Vol-3008/paper1.pdf). The orchestration of parts running in heterogeneous environments can get unmanageable without external orchestration tools, e.g., as there could be long invocation chains, complex data transfers, data format transformations, and interactions with various heterogeneous APIs.", "Intent": "How to ensure the control and data flow for quantum applications comprising one or more quantum circuits with corresponding classical pre- and post-processing steps?", "Result": "The classical code as well as the quantum circuits required to realize a quantum application are separated from the workflow model defining how they are integrated. This increases modularity and enables the reuse of existing code, decreasing development time and cost. Furthermore, by using workflows, quantum applications can benefit from the reliability, scalability, and robustness of workflow engines [[Leymann and Barzen, 2021a]](https://arxiv.org/abs/2103.04320). Finally, also the usage of various heterogeneous quantum and classical cloud offerings with different functionalities is supported. However, the need to model orchestrations to enact them on specialized middleware requires additional expertise and may result in overhead for simple use cases such as circuit design and testing.", "Context": "Most quantum algorithms are hybrid, i.e., parts are executed on quantum devices, and others run on classical hardware [[Leymann and Barzen, 2020]](https://arxiv.org/abs/2103.04320). Furthermore, quantum applications can involve multiple quantum algorithms and additional classical parts, e.g., interacting with the user or loading data from a database. These parts must be orchestrated, i.e., the control and data flow between them must be ensured.", "Examples": "–", "Solution": "Utilize a workflow language to model the quantum and classical parts as tasks within a workflow model [[Weder et al., 2020b]](https://ieeexplore.ieee.org/abstract/document/9302814) as shown in Figure 6. The workflow model can then be deployed to a workflow engine, which orchestrates the quantum and classical parts by invoking them in the specified order and ensuring the required data flow (Ellis, 1999). Thereby, the invocation of heterogeneous offerings, as well as features such as data format transformation is provided by the workflow engine [[Leymann and Roller, 2000]](https://www.econbiz.de/Record/production-workflow-concepts-and-techniques-leymann-frank/10001377705). While there exist workflow offerings specifically targeting the quantum computing domain, e.g., providing some pre-implemented quantum algorithms, standardized workflow languages and corresponding workflow engines can also be employed to benefit from their maturity and rich feature sets.\n\n![Solution Sketch for Orchestrated Execution](https://raw.githubusercontent.com/PatternAtlas/pattern-atlas-content/main/sketches/quantum_computing_patterns/orchestrated.svg)", "Known Uses": "Examples of standardized workflow languages are Business Process Model and Notation (BPMN) [[Object Management Group, 2010]](https://www.omg.org/spec/BPMN/2.0/PDF) or Business Process Execution Language (BPEL) (OASIS, 2007). For the execution of these workflow models, different workflow engines are available, e.g., the Camunda BPMN engine [[Camunda Services, 2023]](https://docs.camunda.io). Furthermore, there exists a quantum-specific modeling extension to ease the modeling of workflows in the quantum computing domain [[Weder et al., 2020b]](https://ieeexplore.ieee.org/abstract/document/9302814). Quantum-specific orchestration tools comprise Orquestra by Zapata [[Zapata, 2022]](https://www.zapatacomputing.com/orquestra), which uses a custom YAML-based language, and Covalent by Agnostiq [[Agnostiq, 2023]](https://agnostiq.ai/covalent/), a quantum orchestration platform that requires specifying control flow via a Python-based domain-specific language.", "Related Pattern": "If multiple quantum circuits have to be executed by the workflow, the PRIORITIZED EXECUTION pattern can be used to reduce waiting times. Further, this pattern can be applied to integrate several distinct quantum applications made available using the PRE-DEPLOYED EXECUTION pattern."}', 'https://raw.githubusercontent.com/PatternAtlas/pattern-atlas-content/main/icons/quantum_computing_patterns/orchestrated-execution-thin.svg', '{"Alias": "–", "Forces": "Quantum devices and the corresponding quantum cloud offerings vary strongly in characteristics, such as the number of available qubits, incurred costs for the execution, or queuing times [[Tannu and Qureshi, 2019]](https://dl.acm.org/doi/10.1145/3297858.3304007), [[Vietz et al., 2021]](http://ceur-ws.org/Vol-3008/paper1.pdf). The orchestration of parts running in heterogeneous environments can get unmanageable without external orchestration tools, e.g., as there could be long invocation chains, complex data transfers, data format transformations, and interactions with various heterogeneous APIs.", "Intent": "How to ensure the control and data flow for quantum applications comprising one or more quantum circuits with corresponding classical pre- and post-processing steps?", "Result": "The classical code as well as the quantum circuits required to realize a quantum application are separated from the workflow model defining how they are integrated. This increases modularity and enables the reuse of existing code, decreasing development time and cost. Furthermore, by using workflows, quantum applications can benefit from the reliability, scalability, and robustness of workflow engines [[Leymann and Barzen, 2021a]](https://arxiv.org/abs/2103.04320). Finally, also the usage of various heterogeneous quantum and classical cloud offerings with different functionalities is supported. However, the need to model orchestrations to enact them on specialized middleware requires additional expertise and may result in overhead for simple use cases such as circuit design and testing.", "Context": "Most quantum algorithms are hybrid, i.e., parts are executed on quantum devices, and others run on classical hardware [[Leymann and Barzen, 2020]](https://arxiv.org/abs/2103.04320). Furthermore, quantum applications can involve multiple quantum algorithms and additional classical parts, e.g., interacting with the user or loading data from a database. These parts must be orchestrated, i.e., the control and data flow between them must be ensured.", "Examples": "–", "Solution": "Utilize a workflow language to model the quantum and classical parts as tasks within a workflow model [[Weder et al., 2020b]](https://ieeexplore.ieee.org/abstract/document/9302814) as shown in Figure 6. The workflow model can then be deployed to a workflow engine, which orchestrates the quantum and classical parts by invoking them in the specified order and ensuring the required data flow (Ellis, 1999). Thereby, the invocation of heterogeneous offerings, as well as features such as data format transformation is provided by the workflow engine [[Leymann and Roller, 2000]](https://www.econbiz.de/Record/production-workflow-concepts-and-techniques-leymann-frank/10001377705). While there exist workflow offerings specifically targeting the quantum computing domain, e.g., providing some pre-implemented quantum algorithms, standardized workflow languages and corresponding workflow engines can also be employed to benefit from their maturity and rich feature sets.\n\n![Solution Sketch for Orchestrated Execution](https://raw.githubusercontent.com/PatternAtlas/pattern-atlas-content/main/sketches/quantum_computing_patterns/orchestrated.svg)", "Known Uses": "Examples of standardized workflow languages are Business Process Model and Notation (BPMN) [[Object Management Group, 2010]](https://www.omg.org/spec/BPMN/2.0/PDF) or Business Process Execution Language (BPEL) (OASIS, 2007). For the execution of these workflow models, different workflow engines are available, e.g., the Camunda BPMN engine [[Camunda Services, 2023]](https://docs.camunda.io). Furthermore, there exists a quantum-specific modeling extension to ease the modeling of workflows in the quantum computing domain [[Weder et al., 2020b]](https://ieeexplore.ieee.org/abstract/document/9302814). Quantum-specific orchestration tools comprise Orquestra by Zapata [[Zapata, 2022]](https://www.zapatacomputing.com/orquestra), which uses a custom YAML-based language, and Covalent by Agnostiq [[Agnostiq, 2023]](https://agnostiq.ai/covalent/), a quantum orchestration platform that requires specifying control flow via a Python-based domain-specific language.", "Related Pattern": "If multiple quantum circuits have to be executed by the workflow, the PRIORITIZED EXECUTION pattern can be used to reduce waiting times. Further, this pattern can be applied to integrate several distinct quantum applications made available using the PRE-DEPLOYED EXECUTION pattern."}', 'af7780d5-1f97-4536-8da7-4194b093ab1d', 'https://www.scitepress.org/Link.aspx?doi=10.5220/0012057700003538', NULL, NULL, 'behavioral');
INSERT INTO public.pattern (id, name, uri, content, icon_url, rendered_content, pattern_language_id, paper_ref, deployment_modeling_behavior_pattern, deployment_modeling_structure_pattern, tags) VALUES ('c6560c51-d2e3-4595-b9c3-b609c75c0b82', 'Phase Shift', 'https://patternpedia.org/patternLanguages/reformulatedQuantumComputingPatterns/phaseShift', '{"Alias": "", "Intent": "Distinguish the important aspects of a state in an efficient manner\n\n", "Result": "A phase shift of some states in $G$ cannot be detected by measurement, since the amplitudes of the states do not change.  \nBut the phase-shifted states can be used for further computations to increase the probability to measure a \"good\" solution. Since only the phase and not the measurable amplitude of the states is changed, this operation has no classical equivalent.\n\n", "Context": "In an iterative algorithm wherein each iteration the solution shall be improved, the parts of the computational basis improving the solution should be indicated. One possible indication is a phase shift.\n\n", "Solution": "According to [(Rieffel and Polak 2014)](https://mitpress.mit.edu/books/quantum-computing) the subsequent operator $S_G^\\phi$ can be implemented efficiently regarding the number of applied gates:\n\n\n$$\n\\newcommand{\\colVec}[1]{% inline column vector\n\\bigl( \\begin{smallmatrix}#1\\end{smallmatrix}\\bigr)\n}\n\\newcommand{\\bigColVec}[1]{% inline column vector\n\\left( \\begin{matrix}#1\\end{matrix}\\right)\n}\n\\newcommand{\\state}[1]{{\\left| #1 \\right>}}\\sum_{x=0}^{N-1} \\alpha_x \\state{x}  \\xrightarrow{S_G^\\phi}  \\sum_{x\\in G}e^{i\\phi} \\alpha_x \\state{x} + \\sum_{x\\notin G} \\alpha_x \\state{x}$$\nThis operator marks the qubits which are improving the solution (and, thus, are in the ``good'''' subset $G \\subseteq \\{0, ..., N - 1\\})$ by a phase shift with a phase $\\phi$, while leaving the remaining qubits untouched. ", "Variants": "Another variant of this solution is to modify the operator such that it applies a phase shift on the qubits in $G$ with a different phase, i.e. $\\phi = \\phi (x)$.\n\n", "Known Uses": "For example, in the prominent algorithms of Grover and Deutsch-Jozsa, a phase shift is used.\n\n[Grover''s Algorithm (PlanQK)](https://platform.planqk.de/algorithms/86dfd279-db46-4adb-84a7-39bcf1d19d3a/)\n[Dürr-Høyer Quantum Minimization Algorithm (PlanQK)](https://platform.planqk.de/algorithms/061f4eb3-d9ee-4f47-befc-9e242bf801ce/)\n[Quantum approximate optimization algorithm (PlanQK)](https://platform.planqk.de/algorithms/fae60bca-d2b6-4aa2-88b7-58caace34179/)", "Related Patterns": "For a specific indicator function $f$ specifying a set of \"good\" states in $G$, a [Function Table](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/3f3fabf0-7fa7-4b43-a74a-46a7ac2c55ee) based on this indicator function is a phase shift. \nTo perform an [Amplitude Amplification](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/96b4d28a-a5ce-4c96-85df-d42587b13c57), two phase shifts are needed.\nA phase shift can be used as an [Oracle](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/1cc7e9d6-ab37-412e-8afa-604a25de296e).\n\n"}', 'https://quantumcomputingpatterns.org/assets/pattern-icons/phase_shift_icon.png', '{"Alias": "", "Intent": "Distinguish the important aspects of a state in an efficient manner\n\n", "Result": "A phase shift of some states in $G$ cannot be detected by measurement, since the amplitudes of the states do not change.  \nBut the phase-shifted states can be used for further computations to increase the probability to measure a \"good\" solution. Since only the phase and not the measurable amplitude of the states is changed, this operation has no classical equivalent.\n\n", "Context": "In an iterative algorithm wherein each iteration the solution shall be improved, the parts of the computational basis improving the solution should be indicated. One possible indication is a phase shift.\n\n", "Solution": "According to [(Rieffel and Polak 2014)](https://mitpress.mit.edu/books/quantum-computing) the subsequent operator $S_G^\\phi$ can be implemented efficiently regarding the number of applied gates:\n\n\n$$\n\\newcommand{\\colVec}[1]{% inline column vector\n\\bigl( \\begin{smallmatrix}#1\\end{smallmatrix}\\bigr)\n}\n\\newcommand{\\bigColVec}[1]{% inline column vector\n\\left( \\begin{matrix}#1\\end{matrix}\\right)\n}\n\\newcommand{\\state}[1]{{\\left| #1 \\right>}}\\sum_{x=0}^{N-1} \\alpha_x \\state{x}  \\xrightarrow{S_G^\\phi}  \\sum_{x\\in G}e^{i\\phi} \\alpha_x \\state{x} + \\sum_{x\\notin G} \\alpha_x \\state{x}$$\nThis operator marks the qubits which are improving the solution (and, thus, are in the ``good'''' subset $G \\subseteq \\{0, ..., N - 1\\})$ by a phase shift with a phase $\\phi$, while leaving the remaining qubits untouched. ", "Variants": "Another variant of this solution is to modify the operator such that it applies a phase shift on the qubits in $G$ with a different phase, i.e. $\\phi = \\phi (x)$.\n\n", "Known Uses": "For example, in the prominent algorithms of Grover and Deutsch-Jozsa, a phase shift is used.\n\n[Grover''s Algorithm (PlanQK)](https://platform.planqk.de/algorithms/86dfd279-db46-4adb-84a7-39bcf1d19d3a/)\n[Dürr-Høyer Quantum Minimization Algorithm (PlanQK)](https://platform.planqk.de/algorithms/061f4eb3-d9ee-4f47-befc-9e242bf801ce/)\n[Quantum approximate optimization algorithm (PlanQK)](https://platform.planqk.de/algorithms/fae60bca-d2b6-4aa2-88b7-58caace34179/)", "Related Patterns": "For a specific indicator function $f$ specifying a set of \"good\" states in $G$, a [Function Table](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/3f3fabf0-7fa7-4b43-a74a-46a7ac2c55ee) based on this indicator function is a phase shift. \nTo perform an [Amplitude Amplification](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/96b4d28a-a5ce-4c96-85df-d42587b13c57), two phase shifts are needed.\nA phase shift can be used as an [Oracle](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/1cc7e9d6-ab37-412e-8afa-604a25de296e).\n\n"}', 'af7780d5-1f97-4536-8da7-4194b093ab1d', 'https://link.springer.com/chapter/10.1007/978-3-030-14082-3_19', false, false, 'circuit-level');
INSERT INTO public.pattern (id, name, uri, content, icon_url, rendered_content, pattern_language_id, paper_ref, deployment_modeling_behavior_pattern, deployment_modeling_structure_pattern, tags) VALUES ('1c95912a-128b-44e7-b2d4-930f7ba11060', 'Post-Selective Measurement', 'https://patternpedia.org/patternLanguages/reformulatedQuantumComputingPatterns/post-selectiveMeasurement', '{"Alias": "", "Intent": "Select one branch of a superposition to proceed with", "Result": "As the resulting approach is probabilistic, thus, the average number of iterations needed depends on the amplitude of the selected branch. In the example above, the algorithm proceeds with a probability of 50\\%.", "Context": "As quantum operations are unitary, they perform linear transformations. However, sometimes a non-linear transformation is desirable. For example, if the result of a computation is stored in one branch of the superposition, e.g.,\n$$\\newcommand{\\state}[1]{{\\left| #1 \\right>}}\\state{\\psi}=\\frac{1}{\\sqrt{2}}\\state{1}\\state{f(x)} + \\frac{1}{\\sqrt{2}} \\state{0}\\state{g(x)}$$\n one would like to proceed with $\\newcommand{\\state}[1]{{\\left| #1 \\right>}}\\state{1}\\state{f(x)}$ and discard the rest of the superposition.", "Solution": "Use measurement to force the quantum state to collapse into one of the two branches. \nFor the example above, measuring the first qubit in the computational basis results in either $\\newcommand{\\state}[1]{{\\left| #1 \\right>}}\\state{0}$ or $\\newcommand{\\state}[1]{{\\left| #1 \\right>}}\\state{1}$. If the measurement indicates that the preferred branch was selected (i.e., $\\newcommand{\\state}[1]{{\\left| #1 \\right>}}\\state{1}$ for our example)), one can proceed with further calculations (shown in the pattern sketch). Otherwise, the current computation is discarded and restarted from the beginning, i.e., by first resetting each qubit to $\\newcommand{\\state}[1]{{\\left| #1 \\right>}}\\state{0}$ followed by the operations of the rest of the circuit.", "Variants": "", "Known Uses": "A non-linear transformation can be favorable for designing quantum neural networks [[Cao et al. 2017](https://arxiv.org/abs/1711.11240)]. The HHL algorithm [[Harrow, Hassidim and Lloyd 2009](https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.103.150502)] and various other algorithms that build on it, for example, the Quantum Support Vector Machine [Duan et al. 2020](https://www.sciencedirect.com/science/article/abs/pii/S037596012030462X)], use this technique._Post-Selective Measurements_ are also used in repeat-until-success circuits [[Paetznick and Svore](https://arxiv.org/abs/1311.1074)] that restore the state before the measurement via a recovery operation instead of restarting the whole computation. OpenQASM 3.0 introduces the functionality to explicitly model such an approach through the usage of measurements within a _while_ loop [[Cross et al. 2021](https://arxiv.org/abs/2104.14722)].\n\n[HHL Algorithm (PlanQK)](https://platform.planqk.de/algorithms/8c6909bd-a258-4702-8356-6ef28321a826/)", "Related Patterns": "[Amplitude Amplification](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/96b4d28a-a5ce-4c96-85df-d42587b13c57) can be used to increase the probability to select a particular branch."}', 'http://quantumcomputingpatterns.org/assets/pattern-icons/post_selective_measurement_icon.png', '{"Alias": "", "Intent": "Select one branch of a superposition to proceed with", "Result": "As the resulting approach is probabilistic, thus, the average number of iterations needed depends on the amplitude of the selected branch. In the example above, the algorithm proceeds with a probability of 50\\%.", "Context": "As quantum operations are unitary, they perform linear transformations. However, sometimes a non-linear transformation is desirable. For example, if the result of a computation is stored in one branch of the superposition, e.g.,\n$$\\newcommand{\\state}[1]{{\\left| #1 \\right>}}\\state{\\psi}=\\frac{1}{\\sqrt{2}}\\state{1}\\state{f(x)} + \\frac{1}{\\sqrt{2}} \\state{0}\\state{g(x)}$$\n one would like to proceed with $\\newcommand{\\state}[1]{{\\left| #1 \\right>}}\\state{1}\\state{f(x)}$ and discard the rest of the superposition.", "Solution": "Use measurement to force the quantum state to collapse into one of the two branches. \nFor the example above, measuring the first qubit in the computational basis results in either $\\newcommand{\\state}[1]{{\\left| #1 \\right>}}\\state{0}$ or $\\newcommand{\\state}[1]{{\\left| #1 \\right>}}\\state{1}$. If the measurement indicates that the preferred branch was selected (i.e., $\\newcommand{\\state}[1]{{\\left| #1 \\right>}}\\state{1}$ for our example)), one can proceed with further calculations (shown in the pattern sketch). Otherwise, the current computation is discarded and restarted from the beginning, i.e., by first resetting each qubit to $\\newcommand{\\state}[1]{{\\left| #1 \\right>}}\\state{0}$ followed by the operations of the rest of the circuit.", "Variants": "", "Known Uses": "A non-linear transformation can be favorable for designing quantum neural networks [[Cao et al. 2017](https://arxiv.org/abs/1711.11240)]. The HHL algorithm [[Harrow, Hassidim and Lloyd 2009](https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.103.150502)] and various other algorithms that build on it, for example, the Quantum Support Vector Machine [Duan et al. 2020](https://www.sciencedirect.com/science/article/abs/pii/S037596012030462X)], use this technique._Post-Selective Measurements_ are also used in repeat-until-success circuits [[Paetznick and Svore](https://arxiv.org/abs/1311.1074)] that restore the state before the measurement via a recovery operation instead of restarting the whole computation. OpenQASM 3.0 introduces the functionality to explicitly model such an approach through the usage of measurements within a _while_ loop [[Cross et al. 2021](https://arxiv.org/abs/2104.14722)].\n\n[HHL Algorithm (PlanQK)](https://platform.planqk.de/algorithms/8c6909bd-a258-4702-8356-6ef28321a826/)", "Related Patterns": "[Amplitude Amplification](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/96b4d28a-a5ce-4c96-85df-d42587b13c57) can be used to increase the probability to select a particular branch."}', 'af7780d5-1f97-4536-8da7-4194b093ab1d', 'Weigold, M., et al.: Encoding patterns for quantum algorithms. IET Quant. Comm. 1–12 (2021). https://doi.org/10.1049/qtc2.12032', false, false, 'circuit-level');
INSERT INTO public.pattern (id, name, uri, content, icon_url, rendered_content, pattern_language_id, paper_ref, deployment_modeling_behavior_pattern, deployment_modeling_structure_pattern, tags) VALUES ('9af072e8-875b-4e7d-980a-98cc6e0e7fd6', 'Pre-deployed Execution', 'https://patternpedia.org/patternLanguages/quantumAlgorithmPatterns/pre-deployedExecution', '{"Alias": "–", "Forces": "Quantum service offerings vary significantly feature-wise and often rely on different authentication mechanisms, proprietary formats, and SDKs. Additional technical expertise may be required to successfully execute a provided quantum circuit with its pre- and post-processing steps that can be hosted separately, e.g., due to data processing requirements. In certain cases, it is more beneficial to execute quantum and classical parts of the application in proximity of each other, e.g., to reduce the networking overhead.", "Intent": "How to execute quantum circuits with classical pre- and post-processing steps that have custom deployment requirements?", "Result": "The deployment of quantum applications is decoupled from its execution, hence, enabling the invocation by other users or integration with other applications, e.g., a pre-deployed VQA can be subsumed as a part of another application. In the case of hybrid runtimes, the pre-deployed application benefits from provider-managed execution transparency but is locked into the requirements and limitations of the underlying offering. In the Distributed Deployment variant, developers can benefit from combining different services for specific parts of the application.", "Context": "Most quantum algorithms are hybrid, e.g., VQAs contain a hybrid loop with many successive executions of parameterized quantum circuits with optimization steps in-between performed on classical hardware [[Cerezo et al., 2021]](https://www.nature.com/articles/s42254-021-00348-9). Further, quantum devices are accessed via the cloud and to execute a circuit, it is queued in the job-queue of the respective service, which may not support the execution of classical code parts. Thus, a quantum circuit and its classical pre- and post-processing steps may need to be deployed in a specific manner, e.g., together or using specific combinations of cloud service offerings.", "Examples": "–", "Solution": " Pre-deploy the quantum circuit with its pre- and post-processing steps either on (i) a single quantum offering that supports execution of quantum and classical parts, or (ii) a specific combination of quantum and cloud offerings that fulfills the given deployment requirements. Figure 4 shows the solution sketch of this pattern: In *Step 1*, the quantum and classical parts are deployed according to deployment preferences. The subsequent execution and fetching of the results shown in *Steps 2&3* can be done independently by developers or client applications.\n\n![Solution Sketch for Pre-deployed Execution](https://raw.githubusercontent.com/PatternAtlas/pattern-atlas-content/main/sketches/quantum_computing_patterns/pre-deployed-single-column.svg)\n\n\n**Variants:** One deployment target option in *Step 1* is a Hybrid Execution Environment offering that can speed up the interaction between quantum and classical computations. Hence, they reduce the network overhead and queuing times for many successive quantum circuit executions. Another variant is a Distributed Deployment in which parts of the quantum application are deployed on a combination of different cloud offerings. Implementation of quantum and classical parts, as well as their deployment models, depend on chosen technologies, e.g., implementation of QAOA for Qiskit Runtime would impose more coding and deployment modeling constraints compared to more general deployment scenarios such as packaging the quantum application as one or more containers that can be deployed to a container orchestration engine such as Kubernetes and later executed via client requests.", "Known Uses": "Qiskit Runtime [[Qiskit, 2023a]](https://qiskit.org/documentation/) is a service from IBM, which offers a hybrid execution environment that enables deploying a quantum application packaged as a Python file with a JSON meta-data file, and subsequently executing it via a publicly available HTTP endpoint. A similar service is Amazon Braket Hybrid Jobs  [[AWS, 2023]](https://docs.aws.amazon.com/braket/latest/developerguide/braket-using.html). Microsoft also introduced the hybrid execution environment and shows an example how to use it [[Frachon, 2023]](https://devblogs.microsoft.com/qsharp/azure-quantum-unlocks-the-next-generation-of-hybrid-quantum-computing/). For distributed deployment scenarios, various cloud offerings can be employed for classical tasks. Example offerings from AWS include AWS Lambda for executing classical Python code, AWS S3 as an object storage offering, and Amazon Cloudwatch for monitoring.", "Related Pattern": "Pre-deployed execution of hybrid applications improves the reusability of different algorithms such as the VQA and the more concrete patterns like VQE and QAOA [[Weigold et al., 2021b]](https://doi.org/10.1007/978-3-030-87568-8_2). Additionally, pre- and post-processing steps, such as STATE PREPARATION [[Leymann, 2019]](https://link.springer.com/chapter/10.1007/978-3-030-14082-3_19) or READOUT ERROR MITIGATION [[Beisel et al., 2022]](https://www.thinkmind.org/index.php?view=article&articleid=patterns_2022_2_10_70007), can be applied to run on preferred execution targets."}', 'https://raw.githubusercontent.com/PatternAtlas/pattern-atlas-content/main/icons/quantum_computing_patterns/pre-deployed-execution-thin.svg', '{"Alias": "–", "Forces": "Quantum service offerings vary significantly feature-wise and often rely on different authentication mechanisms, proprietary formats, and SDKs. Additional technical expertise may be required to successfully execute a provided quantum circuit with its pre- and post-processing steps that can be hosted separately, e.g., due to data processing requirements. In certain cases, it is more beneficial to execute quantum and classical parts of the application in proximity of each other, e.g., to reduce the networking overhead.", "Intent": "How to execute quantum circuits with classical pre- and post-processing steps that have custom deployment requirements?", "Result": "The deployment of quantum applications is decoupled from its execution, hence, enabling the invocation by other users or integration with other applications, e.g., a pre-deployed VQA can be subsumed as a part of another application. In the case of hybrid runtimes, the pre-deployed application benefits from provider-managed execution transparency but is locked into the requirements and limitations of the underlying offering. In the Distributed Deployment variant, developers can benefit from combining different services for specific parts of the application.", "Context": "Most quantum algorithms are hybrid, e.g., VQAs contain a hybrid loop with many successive executions of parameterized quantum circuits with optimization steps in-between performed on classical hardware [[Cerezo et al., 2021]](https://www.nature.com/articles/s42254-021-00348-9). Further, quantum devices are accessed via the cloud and to execute a circuit, it is queued in the job-queue of the respective service, which may not support the execution of classical code parts. Thus, a quantum circuit and its classical pre- and post-processing steps may need to be deployed in a specific manner, e.g., together or using specific combinations of cloud service offerings.", "Examples": "–", "Solution": " Pre-deploy the quantum circuit with its pre- and post-processing steps either on (i) a single quantum offering that supports execution of quantum and classical parts, or (ii) a specific combination of quantum and cloud offerings that fulfills the given deployment requirements. Figure 4 shows the solution sketch of this pattern: In *Step 1*, the quantum and classical parts are deployed according to deployment preferences. The subsequent execution and fetching of the results shown in *Steps 2&3* can be done independently by developers or client applications.\n\n![Solution Sketch for Pre-deployed Execution](https://raw.githubusercontent.com/PatternAtlas/pattern-atlas-content/main/sketches/quantum_computing_patterns/pre-deployed-single-column.svg)\n\n\n**Variants:** One deployment target option in *Step 1* is a Hybrid Execution Environment offering that can speed up the interaction between quantum and classical computations. Hence, they reduce the network overhead and queuing times for many successive quantum circuit executions. Another variant is a Distributed Deployment in which parts of the quantum application are deployed on a combination of different cloud offerings. Implementation of quantum and classical parts, as well as their deployment models, depend on chosen technologies, e.g., implementation of QAOA for Qiskit Runtime would impose more coding and deployment modeling constraints compared to more general deployment scenarios such as packaging the quantum application as one or more containers that can be deployed to a container orchestration engine such as Kubernetes and later executed via client requests.", "Known Uses": "Qiskit Runtime [[Qiskit, 2023a]](https://qiskit.org/documentation/) is a service from IBM, which offers a hybrid execution environment that enables deploying a quantum application packaged as a Python file with a JSON meta-data file, and subsequently executing it via a publicly available HTTP endpoint. A similar service is Amazon Braket Hybrid Jobs  [[AWS, 2023]](https://docs.aws.amazon.com/braket/latest/developerguide/braket-using.html). Microsoft also introduced the hybrid execution environment and shows an example how to use it [[Frachon, 2023]](https://devblogs.microsoft.com/qsharp/azure-quantum-unlocks-the-next-generation-of-hybrid-quantum-computing/). For distributed deployment scenarios, various cloud offerings can be employed for classical tasks. Example offerings from AWS include AWS Lambda for executing classical Python code, AWS S3 as an object storage offering, and Amazon Cloudwatch for monitoring.", "Related Pattern": "Pre-deployed execution of hybrid applications improves the reusability of different algorithms such as the VQA and the more concrete patterns like VQE and QAOA [[Weigold et al., 2021b]](https://doi.org/10.1007/978-3-030-87568-8_2). Additionally, pre- and post-processing steps, such as STATE PREPARATION [[Leymann, 2019]](https://link.springer.com/chapter/10.1007/978-3-030-14082-3_19) or READOUT ERROR MITIGATION [[Beisel et al., 2022]](https://www.thinkmind.org/index.php?view=article&articleid=patterns_2022_2_10_70007), can be applied to run on preferred execution targets."}', 'af7780d5-1f97-4536-8da7-4194b093ab1d', 'https://www.scitepress.org/Link.aspx?doi=10.5220/0012057700003538', NULL, NULL, 'behavioral');
INSERT INTO public.pattern (id, name, uri, content, icon_url, rendered_content, pattern_language_id, paper_ref, deployment_modeling_behavior_pattern, deployment_modeling_structure_pattern, tags) VALUES ('aa90de15-b7e3-45a7-bb48-f0a5b8b2c479', 'Quantum Circuit Translator', 'https://patternpedia.org/patternLanguages/quantumAlgorithmPatterns/quantumCircuitTranslator', '{"Alias": "–", "Forces": "There are a multitude of quantum programming languages available for implementing quantum algorithms [[Vietz et al. 2021]](https://doi.org/10.1007/978-3-030-77980-1_10). A quantum circuit may be implemented in a programming language that is incompatible with the targeted quantum computer. The circuit needs to be re-implemented in a compatible quantum programming language and instruction set. However, a manual re-implementation is error-prone, time-consuming, and requires expertise in quantum computing, and, hence, is not feasible for real-world problem sizes. Therefore, an automatic translation, transforming unsupported gates into gates natively supported by the quantum computer, is required.", "Intent": "How can a quantum circuit be executed by different quantum computers with different instruction sets?", "Result": "A Quantum Circuit Translator is able to automatically translate a quantum circuit into a target format, enabling components with different circuit formats and instruction sets to use the same circuit. A Quantum Circuit Translator increases the reusability of [Quantum Modules](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/424c803a-aefb-4b54-8e45-d177fedac893), as it enables their use with different quantum computers. However, the translated circuits do not need to be executed directly, but can instead be used as inputs for a [Quantum Module Template](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/d5cda8c9-f39b-474a-9032-c17131884975). Therefore, a Quantum Circuit Translator enables the composition of quantum algorithms based on modules implemented in different programming languages. Thus, a Quantum Circuit Translator can be used to increase the interoperability of [Quantum Modules](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/424c803a-aefb-4b54-8e45-d177fedac893).", "Context": "Quantum circuits can be implemented in different programming languages and with different quantum gates. However, quantum computers typically only support specific circuit formats and instruction sets, which hinders interoperability and leads to vendor lock-in [[Salm et al. 2020]](https://doi.org/10.1007/978-3-030-64846-6_5). Thus, executing a quantum circuit on different quantum computers often requires a translation of the quantum circuit.", "Examples": "–", "Solution": "Use a translator to convert the quantum circuit into the target language and transpile the circuit to the target instruction set, i.e., replace unsupported gates with equivalent gates from the target instruction set.\n\n![Solution sketch quantum circuit translator](https://raw.githubusercontent.com/PatternAtlas/pattern-atlas-content/86db502508692e2de1af9a3dfbb2e5ff28e03201/sketches/quantum_computing_patterns/quantum-circuit-translator.svg)\n\nThe solution sketch shows the application of a Quantum Circuit Translator that translates a quantum circuit between two programming languages and instruction sets. The SWAP gate connecting the outer qubit wires in the left quantum circuit has been decomposed into three C-NOT gates in the right target quantum circuit.", "Known Uses": "A widely used format for defining quantum circuits is OpenQASM [[Cross et al. 2022]](https://doi.org/10.1145/3505636), an open quantum assembly language. It can be imported and exported by many quantum software development kits (SDKs) such as [Amazon Braket](https://docs.aws.amazon.com/braket/latest/developerguide/braket-using.html), [Qiskit](https://qiskit.org/documentation) and [Cirq](https://quantumai.google/cirq). For estimating whether a quantum circuit can be executed, the NISQ Analyzer [[Salm et al. 2020]](https://doi.org/10.1007/978-3-030-64846-6_5) needs the transpiled circuit for the respective quantum device. It includes multiple circuit translators. For the Python SDK Pennylane [[Bergholm et al. 2018]](https://arxiv.org/abs/1811.04968) there is a plugin enabling the support for IBM quantum computers without additional libraries. Explicit translation is supported by pytket [Pytket Extensions](https://github.com/CQCL/pytket-cirq) from and to [Cirq](https://quantumai.google/cirq). [Qconvert](https://github.com/quantastica/qconvert) can convert from pyQuil or OpenQASM to several other formats by using their web tool.", "Related Pattern": "The Quantum Circuit Translator pattern is related to the [Message Translator](pattern-languages/f6b807aa-5905-4435-aec6-324355a0483f/29f4224d-6b91-4218-aed6-0db3e5fa9dc2) pattern from the [enterprise integration pattern language](pattern-languages/f6b807aa-5905-4435-aec6-324355a0483f). With a [Canonical Data Model](pattern-languages/f6b807aa-5905-4435-aec6-324355a0483f/98ccd4dc-86a8-4652-b2c1-5b83b6f078e1) quantum circuits of any language can be translated into any other language using at most two translators for each language. A circuit translator can be used to translate circuits generated by a [Quantum Module](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/424c803a-aefb-4b54-8e45-d177fedac893) implemented in one programming language before using them with a [Quantum Module Template](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/d5cda8c9-f39b-474a-9032-c17131884975) implemented in a different programming language."}', 'https://raw.githubusercontent.com/PatternAtlas/pattern-atlas-content/7870b15afcae629bfbc0d0022fcb758832b3b8eb/icons/quantum_computing_patterns/quantum-circuit-translator.svg', '{"Alias": "–", "Forces": "There are a multitude of quantum programming languages available for implementing quantum algorithms [[Vietz et al. 2021]](https://doi.org/10.1007/978-3-030-77980-1_10). A quantum circuit may be implemented in a programming language that is incompatible with the targeted quantum computer. The circuit needs to be re-implemented in a compatible quantum programming language and instruction set. However, a manual re-implementation is error-prone, time-consuming, and requires expertise in quantum computing, and, hence, is not feasible for real-world problem sizes. Therefore, an automatic translation, transforming unsupported gates into gates natively supported by the quantum computer, is required.", "Intent": "How can a quantum circuit be executed by different quantum computers with different instruction sets?", "Result": "A Quantum Circuit Translator is able to automatically translate a quantum circuit into a target format, enabling components with different circuit formats and instruction sets to use the same circuit. A Quantum Circuit Translator increases the reusability of [Quantum Modules](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/424c803a-aefb-4b54-8e45-d177fedac893), as it enables their use with different quantum computers. However, the translated circuits do not need to be executed directly, but can instead be used as inputs for a [Quantum Module Template](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/d5cda8c9-f39b-474a-9032-c17131884975). Therefore, a Quantum Circuit Translator enables the composition of quantum algorithms based on modules implemented in different programming languages. Thus, a Quantum Circuit Translator can be used to increase the interoperability of [Quantum Modules](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/424c803a-aefb-4b54-8e45-d177fedac893).", "Context": "Quantum circuits can be implemented in different programming languages and with different quantum gates. However, quantum computers typically only support specific circuit formats and instruction sets, which hinders interoperability and leads to vendor lock-in [[Salm et al. 2020]](https://doi.org/10.1007/978-3-030-64846-6_5). Thus, executing a quantum circuit on different quantum computers often requires a translation of the quantum circuit.", "Examples": "–", "Solution": "Use a translator to convert the quantum circuit into the target language and transpile the circuit to the target instruction set, i.e., replace unsupported gates with equivalent gates from the target instruction set.\n\n![Solution sketch quantum circuit translator](https://raw.githubusercontent.com/PatternAtlas/pattern-atlas-content/86db502508692e2de1af9a3dfbb2e5ff28e03201/sketches/quantum_computing_patterns/quantum-circuit-translator.svg)\n\nThe solution sketch shows the application of a Quantum Circuit Translator that translates a quantum circuit between two programming languages and instruction sets. The SWAP gate connecting the outer qubit wires in the left quantum circuit has been decomposed into three C-NOT gates in the right target quantum circuit.", "Known Uses": "A widely used format for defining quantum circuits is OpenQASM [[Cross et al. 2022]](https://doi.org/10.1145/3505636), an open quantum assembly language. It can be imported and exported by many quantum software development kits (SDKs) such as [Amazon Braket](https://docs.aws.amazon.com/braket/latest/developerguide/braket-using.html), [Qiskit](https://qiskit.org/documentation) and [Cirq](https://quantumai.google/cirq). For estimating whether a quantum circuit can be executed, the NISQ Analyzer [[Salm et al. 2020]](https://doi.org/10.1007/978-3-030-64846-6_5) needs the transpiled circuit for the respective quantum device. It includes multiple circuit translators. For the Python SDK Pennylane [[Bergholm et al. 2018]](https://arxiv.org/abs/1811.04968) there is a plugin enabling the support for IBM quantum computers without additional libraries. Explicit translation is supported by pytket [Pytket Extensions](https://github.com/CQCL/pytket-cirq) from and to [Cirq](https://quantumai.google/cirq). [Qconvert](https://github.com/quantastica/qconvert) can convert from pyQuil or OpenQASM to several other formats by using their web tool.", "Related Pattern": "The Quantum Circuit Translator pattern is related to the [Message Translator](pattern-languages/f6b807aa-5905-4435-aec6-324355a0483f/29f4224d-6b91-4218-aed6-0db3e5fa9dc2) pattern from the [enterprise integration pattern language](pattern-languages/f6b807aa-5905-4435-aec6-324355a0483f). With a [Canonical Data Model](pattern-languages/f6b807aa-5905-4435-aec6-324355a0483f/98ccd4dc-86a8-4652-b2c1-5b83b6f078e1) quantum circuits of any language can be translated into any other language using at most two translators for each language. A circuit translator can be used to translate circuits generated by a [Quantum Module](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/424c803a-aefb-4b54-8e45-d177fedac893) implemented in one programming language before using them with a [Quantum Module Template](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/d5cda8c9-f39b-474a-9032-c17131884975) implemented in a different programming language."}', 'af7780d5-1f97-4536-8da7-4194b093ab1d', 'IARIA, 2023', NULL, NULL, 'design');
INSERT INTO public.pattern (id, name, uri, content, icon_url, rendered_content, pattern_language_id, paper_ref, deployment_modeling_behavior_pattern, deployment_modeling_structure_pattern, tags) VALUES ('dd15032b-ce2b-40b6-80ac-97623255b531', 'Quantum-Classic Split', 'https://patternpedia.org/patternLanguages/reformulatedQuantumComputingPatterns/quantum-classicSplit', '{"Alias": "Enter your input for this section here.", "Intent": "Split computational tasks into a quantum part running on a quantum computer and a classical part running on a classical computer.", "Result": "Since the part running on a classical computer and the part on a quantum computer can depend on each other, e.g., in an iterative solution, several interactions between the systems may be needed.\nConsequently, if a classical computer and a quantum computer are connected via a queue, the queuing time, i.e., the time messages are waiting in the queue, also contributes to the overall runtime. \n\n", "Context": "There are many quantum algorithms that require pre-processing or post-processing which must be done on a classical device.\nThus, it is often necessary to split the algorithms into quantum parts and classical parts. \nSimilarly, to run a quantum algorithm on a quantum computer that contains a small number of, possibly noisy, qubits, it may also be beneficial to split the algorithm into a quantum part of reasonable size and a classical part [(Preskill 2018)](https://quantum-journal.org/papers/q-2018-08-06-79/).\n\n ", "Solution": "The main idea is to split an algorithm into quantum parts and classical parts. \nHowever, how an algorithm can be split depends on the problem and its implementation.\n\n", "Variants": "Enter your input for this section here.", "Known Uses": "Prominent quantum algorithms that depend on classical pre-processing or post-processing are Shor’s algorithm [(Shor 1994)](https://ieeexplore.ieee.org/document/365700) and Simon’s algorithm [(Simon 1997)](https://epubs.siam.org/doi/10.1137/S0097539796298637).\nAnother example is the algorithm stated in [(Farhi, Goldstone and Gutmann 2014)](https://arxiv.org/abs/1411.4028) which is used to solve combinatorial optimization problems and therefore uses classical pre-processing.\nTo enable factorization on NISQ devices the algorithm presented in [(Anschuetz et al. 2018)](https://link.springer.com/chapter/10.1007/978-3-030-14082-3_7) uses a quantum-classic split.\n\n[Hybrid Transfer Learning (PlanQK)](https://platform.planqk.de/algorithms/2803f6d4-094e-4aa9-b09d-5847fba03d21/)\n[Quantum approximate optimization algorithm (PlanQK)](https://platform.planqk.de/algorithms/fae60bca-d2b6-4aa2-88b7-58caace34179/)\n[Quantum-Assisted Genetic Algorithm (PlanQK)](https://platform.planqk.de/algorithms/efc367a5-cc55-438a-995d-9bc6eca63e5e/)\n[Quantum Boltzmann Machine (Gate-based) (PlanQK)](https://platform.planqk.de/algorithms/ae9bac80-672e-432a-983f-a3a7e1a8c92c/)\n[Quantum Generative Adversarial Network (PlanQK)](https://platform.planqk.de/algorithms/c83040fe-e0a7-42d4-be3c-77e223bfdaeb/)\n[Shor''s Algorithm (PlanQK)](https://platform.planqk.de/algorithms/e7413acf-c25e-4de8-ab78-75bfc836a839/)", "Related Patterns": "To pass Information from the classical part of an algorithm to its quantum parts, proper [Initialization](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/312bc9d3-26c0-40ae-b90b-56effd136c0d) is needed.\n\n"}', 'https://quantumcomputingpatterns.org/assets/pattern-icons/quantum_classic_split_icon.png', '{"Alias": "Enter your input for this section here.", "Intent": "Split computational tasks into a quantum part running on a quantum computer and a classical part running on a classical computer.", "Result": "Since the part running on a classical computer and the part on a quantum computer can depend on each other, e.g., in an iterative solution, several interactions between the systems may be needed.\nConsequently, if a classical computer and a quantum computer are connected via a queue, the queuing time, i.e., the time messages are waiting in the queue, also contributes to the overall runtime. \n\n", "Context": "There are many quantum algorithms that require pre-processing or post-processing which must be done on a classical device.\nThus, it is often necessary to split the algorithms into quantum parts and classical parts. \nSimilarly, to run a quantum algorithm on a quantum computer that contains a small number of, possibly noisy, qubits, it may also be beneficial to split the algorithm into a quantum part of reasonable size and a classical part [(Preskill 2018)](https://quantum-journal.org/papers/q-2018-08-06-79/).\n\n ", "Solution": "The main idea is to split an algorithm into quantum parts and classical parts. \nHowever, how an algorithm can be split depends on the problem and its implementation.\n\n", "Variants": "Enter your input for this section here.", "Known Uses": "Prominent quantum algorithms that depend on classical pre-processing or post-processing are Shor’s algorithm [(Shor 1994)](https://ieeexplore.ieee.org/document/365700) and Simon’s algorithm [(Simon 1997)](https://epubs.siam.org/doi/10.1137/S0097539796298637).\nAnother example is the algorithm stated in [(Farhi, Goldstone and Gutmann 2014)](https://arxiv.org/abs/1411.4028) which is used to solve combinatorial optimization problems and therefore uses classical pre-processing.\nTo enable factorization on NISQ devices the algorithm presented in [(Anschuetz et al. 2018)](https://link.springer.com/chapter/10.1007/978-3-030-14082-3_7) uses a quantum-classic split.\n\n[Hybrid Transfer Learning (PlanQK)](https://platform.planqk.de/algorithms/2803f6d4-094e-4aa9-b09d-5847fba03d21/)\n[Quantum approximate optimization algorithm (PlanQK)](https://platform.planqk.de/algorithms/fae60bca-d2b6-4aa2-88b7-58caace34179/)\n[Quantum-Assisted Genetic Algorithm (PlanQK)](https://platform.planqk.de/algorithms/efc367a5-cc55-438a-995d-9bc6eca63e5e/)\n[Quantum Boltzmann Machine (Gate-based) (PlanQK)](https://platform.planqk.de/algorithms/ae9bac80-672e-432a-983f-a3a7e1a8c92c/)\n[Quantum Generative Adversarial Network (PlanQK)](https://platform.planqk.de/algorithms/c83040fe-e0a7-42d4-be3c-77e223bfdaeb/)\n[Shor''s Algorithm (PlanQK)](https://platform.planqk.de/algorithms/e7413acf-c25e-4de8-ab78-75bfc836a839/)", "Related Patterns": "To pass Information from the classical part of an algorithm to its quantum parts, proper [Initialization](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/312bc9d3-26c0-40ae-b90b-56effd136c0d) is needed.\n\n"}', 'af7780d5-1f97-4536-8da7-4194b093ab1d', 'https://link.springer.com/chapter/10.1007/978-3-030-14082-3_19', false, false, 'design');
INSERT INTO public.pattern (id, name, uri, content, icon_url, rendered_content, pattern_language_id, paper_ref, deployment_modeling_behavior_pattern, deployment_modeling_structure_pattern, tags) VALUES ('424c803a-aefb-4b54-8e45-d177fedac893', 'Quantum Module', 'https://patternpedia.org/patternLanguages/quantumAlgorithmPatterns/quantumModule', '{"Alias": "–", "Forces": "Quantum circuits to be processed by a quantum\ncomputer must already contain all appropriately encoded input values. A static implementation of a quantum circuit that does not allow the quantum circuit to be changed based on some input values cannot be reused to solve different problems. Thus, a reusable implementation of the quantum part of a quantum algorithm needs to be able to adapt the quantum circuit to different input values. The input values that need to be encoded in a quantum circuit are, first, the problem to be solved, e.g., an implementation of Shor’s algorithm [[Shor 1997]](https://doi.org/10.1137/s0097539795293172) would require as input the number to be factored into primes, and second, parameters used for optimization or machine learning, e.g., for QAOA [[Weigold et al. 2021]](https://doi.org/10.1007/978-3-030-87568-8_2).\n\n\nMoreover, implementing the quantum part of a quantum algorithm requires in depth knowledge of quantum computing and the underlying mathematical concepts. Thus, quantum computing experts are required in the development teams. However, other parts of the algorithm that only require classical computation, e.g., classical optimizers, may not require quantum computing knowledge at all and can be implemented by different teams without a quantum computing expert.", "Intent": "How can the implementation of the quantum part of a quantum algorithm be packaged for reuse independent of concrete input values?", "Result": "A quantum algorithm implementation is partitioned into (i) quantum modules containing the implementations of the quantum part, and (ii) additional classical code required for the control flow and other classical computations of the quantum algorithm. The quantum modules are independent of the concrete input values, which increases their reusability for different quantum algorithm implementations.\n\n\nThe separation of code that generates quantum circuits into quantum modules can thus also be reflected in the organizational structure of the development teams. Only the teams working on the quantum modules need quantum computing experts, while other teams mainly need experts in classical software engineering.\n\n", "Context": "Each quantum algorithm is a hybrid algorithm, i.e., parts of the algorithm require quantum computers and other parts require classical computers for their execution. For the execution of the quantum part, a quantum circuit implementing the required operations is needed. However, quantum circuits are problem-specific and, thus, depend on various inputs, e.g., the problem instance or initial values for parameterized quantum gates, which are then optimized by a classical optimizer. Therefore, the implementation of the quantum part of a quantum algorithm must be input-agnostic in order to be reusable. ", "Examples": "–", "Solution": "Separate the implementation of the quantum part\nof the quantum algorithm into one or more quantum modules. These modules contain the code that generates quantum circuits based on input values provided to the module. Quantum modules can also be used to reduce the number of code duplicates by implementing common parts of a quantum circuit as a reusable Quantum Module.\n\n![Solution sketch quantum module](https://raw.githubusercontent.com/PatternAtlas/pattern-atlas-content/7870b15afcae629bfbc0d0022fcb758832b3b8eb/sketches/quantum_computing_patterns/quantum-module.svg)\n\nThe solution sketch depicts that a quantum module receives input values and uses generative code to construct quantum circuits depending on these input values. This ensures the reusability of the quantum module, as the implementation can create quantum circuits for different problem sizes as well as parameters.\n\n", "Known Uses": "Quantum Modules can already be found in several libraries for building quantum circuits. In [Amazon Braket](https://docs.aws.amazon.com/braket/latest/developerguide/braket-using.html), the Grover algorithm [[Grover 1996]](https://doi.org/10.1145/237814.237866) is offered as a module with functions to build the oracle and execute the Grover search. Another example of a Quantum Module for creating oracles is the PhaseOracle in [Qiskit](https://qiskit.org/documentation). Generic parts used in multiple quantum algorithms, such as the quantum fourier transformation used in Shor’s algorithm [[Shor 1997]](https://doi.org/10.1137/s0097539795293172) are available in [Amazon Braket](https://docs.aws.amazon.com/braket/latest/developerguide/braket-using.html) and [Qiskit](https://qiskit.org/documentation). The quantum phase estimation, which is also part of Shor’s algorithm can be constructed in [Qiskit](https://qiskit.org/documentation) with the PhaseEstimation module.", "Related Pattern": "A Quantum Module generating specific quantum circuits for a quantum algorithm can be used inside a [Hybrid Module](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/4074490a-4236-49ed-83d1-625ce58e2dbd) that contains the implementation of the overall quantum algorithm with its quantum and classical parts. Quantum circuits generated by a Quantum Module can be integrated into a [Quantum Module Template](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/d5cda8c9-f39b-474a-9032-c17131884975) to create a complete quantum circuit, if the Quantum Module only generates a part of a quantum circuit. The boundary of a Quantum Module is directly corresponding to the [Quantum-Classic Split](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/dd15032b-ce2b-40b6-80ac-97623255b531). The Quantum-Classic Split pattern states, that there is necessarily a separation – a split – between code executed on classical computers and code executed on quantum computers. Thus, the Quantum Module pattern is related to this pattern."}', 'https://raw.githubusercontent.com/PatternAtlas/pattern-atlas-content/7870b15afcae629bfbc0d0022fcb758832b3b8eb/icons/quantum_computing_patterns/quantum-module.svg', '{"Alias": "–", "Forces": "Quantum circuits to be processed by a quantum\ncomputer must already contain all appropriately encoded input values. A static implementation of a quantum circuit that does not allow the quantum circuit to be changed based on some input values cannot be reused to solve different problems. Thus, a reusable implementation of the quantum part of a quantum algorithm needs to be able to adapt the quantum circuit to different input values. The input values that need to be encoded in a quantum circuit are, first, the problem to be solved, e.g., an implementation of Shor’s algorithm [[Shor 1997]](https://doi.org/10.1137/s0097539795293172) would require as input the number to be factored into primes, and second, parameters used for optimization or machine learning, e.g., for QAOA [[Weigold et al. 2021]](https://doi.org/10.1007/978-3-030-87568-8_2).\n\n\nMoreover, implementing the quantum part of a quantum algorithm requires in depth knowledge of quantum computing and the underlying mathematical concepts. Thus, quantum computing experts are required in the development teams. However, other parts of the algorithm that only require classical computation, e.g., classical optimizers, may not require quantum computing knowledge at all and can be implemented by different teams without a quantum computing expert.", "Intent": "How can the implementation of the quantum part of a quantum algorithm be packaged for reuse independent of concrete input values?", "Result": "A quantum algorithm implementation is partitioned into (i) quantum modules containing the implementations of the quantum part, and (ii) additional classical code required for the control flow and other classical computations of the quantum algorithm. The quantum modules are independent of the concrete input values, which increases their reusability for different quantum algorithm implementations.\n\n\nThe separation of code that generates quantum circuits into quantum modules can thus also be reflected in the organizational structure of the development teams. Only the teams working on the quantum modules need quantum computing experts, while other teams mainly need experts in classical software engineering.\n\n", "Context": "Each quantum algorithm is a hybrid algorithm, i.e., parts of the algorithm require quantum computers and other parts require classical computers for their execution. For the execution of the quantum part, a quantum circuit implementing the required operations is needed. However, quantum circuits are problem-specific and, thus, depend on various inputs, e.g., the problem instance or initial values for parameterized quantum gates, which are then optimized by a classical optimizer. Therefore, the implementation of the quantum part of a quantum algorithm must be input-agnostic in order to be reusable. ", "Examples": "–", "Solution": "Separate the implementation of the quantum part\nof the quantum algorithm into one or more quantum modules. These modules contain the code that generates quantum circuits based on input values provided to the module. Quantum modules can also be used to reduce the number of code duplicates by implementing common parts of a quantum circuit as a reusable Quantum Module.\n\n![Solution sketch quantum module](https://raw.githubusercontent.com/PatternAtlas/pattern-atlas-content/7870b15afcae629bfbc0d0022fcb758832b3b8eb/sketches/quantum_computing_patterns/quantum-module.svg)\n\nThe solution sketch depicts that a quantum module receives input values and uses generative code to construct quantum circuits depending on these input values. This ensures the reusability of the quantum module, as the implementation can create quantum circuits for different problem sizes as well as parameters.\n\n", "Known Uses": "Quantum Modules can already be found in several libraries for building quantum circuits. In [Amazon Braket](https://docs.aws.amazon.com/braket/latest/developerguide/braket-using.html), the Grover algorithm [[Grover 1996]](https://doi.org/10.1145/237814.237866) is offered as a module with functions to build the oracle and execute the Grover search. Another example of a Quantum Module for creating oracles is the PhaseOracle in [Qiskit](https://qiskit.org/documentation). Generic parts used in multiple quantum algorithms, such as the quantum fourier transformation used in Shor’s algorithm [[Shor 1997]](https://doi.org/10.1137/s0097539795293172) are available in [Amazon Braket](https://docs.aws.amazon.com/braket/latest/developerguide/braket-using.html) and [Qiskit](https://qiskit.org/documentation). The quantum phase estimation, which is also part of Shor’s algorithm can be constructed in [Qiskit](https://qiskit.org/documentation) with the PhaseEstimation module.", "Related Pattern": "A Quantum Module generating specific quantum circuits for a quantum algorithm can be used inside a [Hybrid Module](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/4074490a-4236-49ed-83d1-625ce58e2dbd) that contains the implementation of the overall quantum algorithm with its quantum and classical parts. Quantum circuits generated by a Quantum Module can be integrated into a [Quantum Module Template](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/d5cda8c9-f39b-474a-9032-c17131884975) to create a complete quantum circuit, if the Quantum Module only generates a part of a quantum circuit. The boundary of a Quantum Module is directly corresponding to the [Quantum-Classic Split](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/dd15032b-ce2b-40b6-80ac-97623255b531). The Quantum-Classic Split pattern states, that there is necessarily a separation – a split – between code executed on classical computers and code executed on quantum computers. Thus, the Quantum Module pattern is related to this pattern."}', 'af7780d5-1f97-4536-8da7-4194b093ab1d', 'IARIA, 2023', NULL, NULL, 'design');
INSERT INTO public.pattern (id, name, uri, content, icon_url, rendered_content, pattern_language_id, paper_ref, deployment_modeling_behavior_pattern, deployment_modeling_structure_pattern, tags) VALUES ('d5cda8c9-f39b-474a-9032-c17131884975', 'Quantum Module Template', 'https://patternpedia.org/patternLanguages/quantumAlgorithmPatterns/quantumModuleTemplate', '{"Alias": "–", "Forces": "Quantum algorithms may intentionally leave parts of the behavior of the quantum part unspecified until a later point in time. For example, the Grover search [[Grover 1996]](https://doi.org/10.1145/237814.237866) uses an unspecified placeholder gate, as the specific function that marks the correct values cannot be known before it has been decided what to search for. In the case of QAOA, the choice of a suitable ansatz depends on information that is only available at runtime. However, for the algorithms to be executed, the missing behavior must be integrated before the execution of the quantum circuits on a quantum computer. Note, that similar situations can arise if the development of a quantum algorithm is split between different teams.\n\n\nIntegrating quantum behavior into an existing circuit requires a specification of the requirements an implementation has to fulfill to be integrated and function correctly. This includes the specification of the input qubits available, possible ancilla qubits, on which qubits and in what form the output is expected, and any other requirements or restrictions, e.g., on the creation of entanglement between quantum bits. Some of the restrictions, e.g., the number of available ancilla qubits, may additionally depend on the quantum computer used for execution, as a quantum computer with more qubits can allocate more ancilla qubits if the number of qubits used in the circuit is otherwise constant.", "Intent": "How can the implementation of the quantum part of a quantum algorithm be packaged for reuse when some of the behavior is determined later?", "Result": "The generic behavior of the quantum part of a quantum algorithm is implemented as Quantum Module Template that requires behavior inputs to generate an executable complete quantum circuit. The behavior inputs specify the parts of the algorithm’s behavior that cannot be known in advance. Thereby, their influence on the resulting quantum circuit can be significantly higher than with a [Quantum Module](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/424c803a-aefb-4b54-8e45-d177fedac893). The behavior inputs must be compatible with the required input definitions of the template.\n\n\nThe integration of the behavior inputs can be done at design time if the behavior is provided as [Quantum Module](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/424c803a-aefb-4b54-8e45-d177fedac893), since the Quantum Module generates the circuit based on the input values. Templates can be nested inside other templates to compose quantum circuits from Quantum Modules implementing higher level circuit functions. This facilitates the replacement of a part of a quantum circuit if that part should be generated by a new Quantum Module implementing an improved algorithm, e.g., a more efficient state preparation.", "Context": "Some quantum algorithms can be implemented in a reusable manner, but their behavior may be partially modified depending on the problem to which the algorithm is applied. For example, the Grover search algorithm [[Grover 1996]](https://doi.org/10.1145/237814.237866) contains an unspecified oracle. The information required for defining the concrete behavior of this oracle may not be available until a later point in time. Similar cases are algorithms like QAOA [[Weigold et al. 2021]](https://doi.org/10.1007/978-3-030-87568-8_2), which do not specify a concrete ansatz to use. Thus, implementations of the quantum part of such algorithms, where the unspecified behavior can be integrated later, are required.", "Examples": "–", "Solution": "Implement the generic behavior of the quantum part of a quantum algorithm in a Quantum Module Template. This module accepts inputs, that define the unspecified behavior to be integrated into the final quantum circuit. The behavior can either be specified as a quantum circuit or as a [Quantum Module](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/424c803a-aefb-4b54-8e45-d177fedac893) that generates the required quantum circuit. This circuit then gets integrated by the Quantum Module Template into the main quantum circuit that represents the generic behavior.\n\n\nTo ensure that the behavior input, in form of a quantum circuit, can be integrated to correctly perform the operations it contains, the Quantum Module Template must include specifications in the documentation that can be used to build a compatible quantum circuit, as outlined in the pattern forces. This specification is mainly a contract that needs to be fulfilled by the quantum circuit serving as input for the template. Similar contracts, e.g., plugin contracts [Marquardt 1999](http://www.kmarquardt.de/papers/EuroPLoP1999.PlugInPatterns.pdf), are also used in classical software engineering.\n\n![Solution sketch quantum module template](https://raw.githubusercontent.com/PatternAtlas/pattern-atlas-content/7870b15afcae629bfbc0d0022fcb758832b3b8eb/sketches/quantum_computing_patterns/quantum-module-template.svg)\n\nThe sketch shows the essential building blocks of a Quantum Module Template. The template requires two kinds of inputs: (i) the input values representing the problem to be solved as well as parameters affecting the circuit generation, as used in the[Quantum Module](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/424c803a-aefb-4b54-8e45-d177fedac893), and (ii) behavior inputs partially specifying the behavior of the algorithm, provided in the form of a quantum circuit or a [Quantum Module](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/424c803a-aefb-4b54-8e45-d177fedac893). Much like the Quantum Module, the Quantum Module Template uses the input values to generate a quantum circuit, which is still incomplete as it does not include the behavior from the behavior inputs yet. If the behavior inputs are provided in the form of a quantum module, this module is used to generate a quantum circuit from the inputs. Finally, the quantum circuit is integrated into the incomplete main circuit. However, implementations of the template are not limited to the exemplary steps shown here.", "Known Uses": "Various quantum algorithms, e.g., the algorithm of Deutsch [[Collins et al. 1998]](https://doi.org/10.1103/PhysRevA.58.R1633) or the Grover search [[Grover 1996]](https://doi.org/10.1145/237814.237866), use an unspecified unitary gate as placeholder. Implementations of the generic behavior of these algorithms are available in [Amazon Braket](https://docs.aws.amazon.com/braket/latest/developerguide/braket-using.html) and [Qiskit](https://qiskit.org/documentation). These algorithms need oracle circuits to replace the placeholder gate, which are described in the [Oracle](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/1cc7e9d6-ab37-412e-8afa-604a25de296e) pattern. The oracle replacement is described in [[Weder et al. 2020]](https://doi.org/10.1109/UCC48980.2020.00046) in an Oracle Expansion Task for workflows using the Quantum Modeling Extension. Generic parts of QAOA [[Weigold et al. 2021]](https://doi.org/10.1007/978-3-030-87568-8_2), such as state preparation and the mixer operator are implemented in [Amazon Braket](https://docs.aws.amazon.com/braket/latest/developerguide/braket-using.html) and [Qiskit](https://qiskit.org/documentation) and can be used by providing a quantum circuit encoding the cost function.", "Related Pattern": "A Quantum Module Template is a special kind of [Quantum Module](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/424c803a-aefb-4b54-8e45-d177fedac893) that additionally accepts behavior inputs, which are integrated into the generated quantum circuit. Quantum Module Templates can be used to integrate, e.g., [Oracles](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/1cc7e9d6-ab37-412e-8afa-604a25de296e) and [Initialization](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/312bc9d3-26c0-40ae-b90b-56effd136c0d) circuits into an executable quantum circuit allowing circuits to be built from smaller modules."}', 'https://raw.githubusercontent.com/PatternAtlas/pattern-atlas-content/7870b15afcae629bfbc0d0022fcb758832b3b8eb/icons/quantum_computing_patterns/quantum-module-template.svg', '{"Alias": "–", "Forces": "Quantum algorithms may intentionally leave parts of the behavior of the quantum part unspecified until a later point in time. For example, the Grover search [[Grover 1996]](https://doi.org/10.1145/237814.237866) uses an unspecified placeholder gate, as the specific function that marks the correct values cannot be known before it has been decided what to search for. In the case of QAOA, the choice of a suitable ansatz depends on information that is only available at runtime. However, for the algorithms to be executed, the missing behavior must be integrated before the execution of the quantum circuits on a quantum computer. Note, that similar situations can arise if the development of a quantum algorithm is split between different teams.\n\n\nIntegrating quantum behavior into an existing circuit requires a specification of the requirements an implementation has to fulfill to be integrated and function correctly. This includes the specification of the input qubits available, possible ancilla qubits, on which qubits and in what form the output is expected, and any other requirements or restrictions, e.g., on the creation of entanglement between quantum bits. Some of the restrictions, e.g., the number of available ancilla qubits, may additionally depend on the quantum computer used for execution, as a quantum computer with more qubits can allocate more ancilla qubits if the number of qubits used in the circuit is otherwise constant.", "Intent": "How can the implementation of the quantum part of a quantum algorithm be packaged for reuse when some of the behavior is determined later?", "Result": "The generic behavior of the quantum part of a quantum algorithm is implemented as Quantum Module Template that requires behavior inputs to generate an executable complete quantum circuit. The behavior inputs specify the parts of the algorithm’s behavior that cannot be known in advance. Thereby, their influence on the resulting quantum circuit can be significantly higher than with a [Quantum Module](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/424c803a-aefb-4b54-8e45-d177fedac893). The behavior inputs must be compatible with the required input definitions of the template.\n\n\nThe integration of the behavior inputs can be done at design time if the behavior is provided as [Quantum Module](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/424c803a-aefb-4b54-8e45-d177fedac893), since the Quantum Module generates the circuit based on the input values. Templates can be nested inside other templates to compose quantum circuits from Quantum Modules implementing higher level circuit functions. This facilitates the replacement of a part of a quantum circuit if that part should be generated by a new Quantum Module implementing an improved algorithm, e.g., a more efficient state preparation.", "Context": "Some quantum algorithms can be implemented in a reusable manner, but their behavior may be partially modified depending on the problem to which the algorithm is applied. For example, the Grover search algorithm [[Grover 1996]](https://doi.org/10.1145/237814.237866) contains an unspecified oracle. The information required for defining the concrete behavior of this oracle may not be available until a later point in time. Similar cases are algorithms like QAOA [[Weigold et al. 2021]](https://doi.org/10.1007/978-3-030-87568-8_2), which do not specify a concrete ansatz to use. Thus, implementations of the quantum part of such algorithms, where the unspecified behavior can be integrated later, are required.", "Examples": "–", "Solution": "Implement the generic behavior of the quantum part of a quantum algorithm in a Quantum Module Template. This module accepts inputs, that define the unspecified behavior to be integrated into the final quantum circuit. The behavior can either be specified as a quantum circuit or as a [Quantum Module](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/424c803a-aefb-4b54-8e45-d177fedac893) that generates the required quantum circuit. This circuit then gets integrated by the Quantum Module Template into the main quantum circuit that represents the generic behavior.\n\n\nTo ensure that the behavior input, in form of a quantum circuit, can be integrated to correctly perform the operations it contains, the Quantum Module Template must include specifications in the documentation that can be used to build a compatible quantum circuit, as outlined in the pattern forces. This specification is mainly a contract that needs to be fulfilled by the quantum circuit serving as input for the template. Similar contracts, e.g., plugin contracts [Marquardt 1999](http://www.kmarquardt.de/papers/EuroPLoP1999.PlugInPatterns.pdf), are also used in classical software engineering.\n\n![Solution sketch quantum module template](https://raw.githubusercontent.com/PatternAtlas/pattern-atlas-content/7870b15afcae629bfbc0d0022fcb758832b3b8eb/sketches/quantum_computing_patterns/quantum-module-template.svg)\n\nThe sketch shows the essential building blocks of a Quantum Module Template. The template requires two kinds of inputs: (i) the input values representing the problem to be solved as well as parameters affecting the circuit generation, as used in the[Quantum Module](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/424c803a-aefb-4b54-8e45-d177fedac893), and (ii) behavior inputs partially specifying the behavior of the algorithm, provided in the form of a quantum circuit or a [Quantum Module](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/424c803a-aefb-4b54-8e45-d177fedac893). Much like the Quantum Module, the Quantum Module Template uses the input values to generate a quantum circuit, which is still incomplete as it does not include the behavior from the behavior inputs yet. If the behavior inputs are provided in the form of a quantum module, this module is used to generate a quantum circuit from the inputs. Finally, the quantum circuit is integrated into the incomplete main circuit. However, implementations of the template are not limited to the exemplary steps shown here.", "Known Uses": "Various quantum algorithms, e.g., the algorithm of Deutsch [[Collins et al. 1998]](https://doi.org/10.1103/PhysRevA.58.R1633) or the Grover search [[Grover 1996]](https://doi.org/10.1145/237814.237866), use an unspecified unitary gate as placeholder. Implementations of the generic behavior of these algorithms are available in [Amazon Braket](https://docs.aws.amazon.com/braket/latest/developerguide/braket-using.html) and [Qiskit](https://qiskit.org/documentation). These algorithms need oracle circuits to replace the placeholder gate, which are described in the [Oracle](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/1cc7e9d6-ab37-412e-8afa-604a25de296e) pattern. The oracle replacement is described in [[Weder et al. 2020]](https://doi.org/10.1109/UCC48980.2020.00046) in an Oracle Expansion Task for workflows using the Quantum Modeling Extension. Generic parts of QAOA [[Weigold et al. 2021]](https://doi.org/10.1007/978-3-030-87568-8_2), such as state preparation and the mixer operator are implemented in [Amazon Braket](https://docs.aws.amazon.com/braket/latest/developerguide/braket-using.html) and [Qiskit](https://qiskit.org/documentation) and can be used by providing a quantum circuit encoding the cost function.", "Related Pattern": "A Quantum Module Template is a special kind of [Quantum Module](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/424c803a-aefb-4b54-8e45-d177fedac893) that additionally accepts behavior inputs, which are integrated into the generated quantum circuit. Quantum Module Templates can be used to integrate, e.g., [Oracles](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/1cc7e9d6-ab37-412e-8afa-604a25de296e) and [Initialization](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/312bc9d3-26c0-40ae-b90b-56effd136c0d) circuits into an executable quantum circuit allowing circuits to be built from smaller modules."}', 'af7780d5-1f97-4536-8da7-4194b093ab1d', 'IARIA, 2023', NULL, NULL, 'design');
INSERT INTO public.pattern (id, name, uri, content, icon_url, rendered_content, pattern_language_id, paper_ref, deployment_modeling_behavior_pattern, deployment_modeling_structure_pattern, tags) VALUES ('a4ea9f6c-5b0a-4beb-a056-8b261d96ba80', 'Quantum Phase Estimation', 'https://patternpedia.org/patternLanguages/reformulatedQuantumComputingPatterns/quantumPhaseEstimation', '{"Alias": "Phase estimation algorithm (PEA)", "Intent": "Approximate the eigenvalue of a unitary matrix.", "Result": "If $\\varphi$ is a rational number, the ancilla register contains the eigenvalue in [Basis Encoding](#/patterns/0) (assuming a proper number of anchillae). Otherwise, an approximation is produced with a probability of at least $\\frac{4}{\\pi}$. Increasing the precision of the approximation by adding more ancillae is costly because this also increases the number of required controlled-$U$ operations. Because  of  these  demanding  hardware requirements, this algorithm is often regarded as non-suitable for NISQ devices.", "Context": "Given a unitary matrix $U$ and one of its eigenstates, the corresponding eigenvalue should be determined. The eigenstate $\\newcommand{\\state}[1]{{\\left| #1 \\right>}}\\state{v}$ is given on a register in [Basis Encoding](#/patterns/0). Applying $U$ to the eigenstate $\\newcommand{\\state}[1]{{\\left| #1 \\right>}}\\state{v}$ results in a global phase: \n$$U\\newcommand{\\state}[1]{{\\left| #1 \\right>}}\\state{v} = e^{2\\pi i \\varphi} \\state{v}$$\nwhere the eigenvalue $\\lambda = e^{2\\pi i \\varphi}$ is uniquely determined by $\\varphi \\in [0,1]$. Therefore, it is sufficient to estimate $\\varphi$.", "Solution": "Use the circuit shown in the pattern sketch to estimate the approximation of $\\theta$. First, a register of $m$ ancillae is brought into an [Uniform Superposition](#/patterns/16). Next, controlled versions of powers of $U$ are applied on the register of the eigenstate following the scheme depicted inthe pattern sketch. Each application of a controlled-$U$ operation results in a _phase kickback_ of the control qubit, i.e., this qubit acquires a relative phase of $\\varphi$. This results in the overall state:\n$$\\newcommand{\\state}[1]{{\\left| #1 \\right>}} \\state{\\psi} = \n    \\sum_{y=0}^{2^m-1}e^{2\\pi \\varphi y}\\state{y}$$\n where $\\varphi$ is encoded in the relative phase. \nTo extract this information, the inverse of the quantum fourier transformation is applied on the ancilla register. ", "Variants": "The second register can also be initialized as an arbitrary quantum state which is always a linear combination of eigenvectors. In this case, the algorithm approximates a superposition of eigenvalues for these eigenvectors in the output register. Other variants of this algorithm further improve the depth of the circuit or require fewer measurements. ", "Known Uses": "_Quantum Phase Estimation_ is at the heart of many algorithms [[Cleve et al. 1998](https://royalsocietypublishing.org/doi/abs/10.1098/rspa.1998.0164)]. One prominent example which we review in a later section is the HHL algorithm [[Harrow, Hassidim and Lloyd 2009](https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.103.150502)]. Other QML algorithms follow a similar scheme [[Schuld and Petruccione 2018](http://dx.doi.org/10.1007/978-3-319-96424-9), [Duan et al. 2020](https://www.sciencedirect.com/science/article/abs/pii/S037596012030462X)], e.g., quantum support vector machine (QSVM) [[Rebentrost et al. 2014](https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.113.130503)] or quantum principal component analysis (QPCA) [[Lloyd et al. 2014](https://www.nature.com/articles/nphys3029)]. [Qiskit]( https://qiskit.org/documentation/stubs/qiskit.circuit.library.PhaseEstimation.html) provides an implementation for this pattern.\n\n[Shor''s Algorithm (PlanQK)](https://platform.planqk.de/algorithms/e7413acf-c25e-4de8-ab78-75bfc836a839/)\n[HHL Algorithm (PlanQK)](https://platform.planqk.de/algorithms/8c6909bd-a258-4702-8356-6ef28321a826/)", "Related Patterns": "This pattern uses [Amplitude Encoding](#/patterns/2) and [Matrix Encoding](#/patterns/11) and produces an output in [Basis Encoding](#/patterns/0)."}', 'https://quantumcomputingpatterns.org/assets/pattern-icons/qpe_icon.png', '{"Alias": "Phase estimation algorithm (PEA)", "Intent": "Approximate the eigenvalue of a unitary matrix.", "Result": "If $\\varphi$ is a rational number, the ancilla register contains the eigenvalue in [Basis Encoding](#/patterns/0) (assuming a proper number of anchillae). Otherwise, an approximation is produced with a probability of at least $\\frac{4}{\\pi}$. Increasing the precision of the approximation by adding more ancillae is costly because this also increases the number of required controlled-$U$ operations. Because  of  these  demanding  hardware requirements, this algorithm is often regarded as non-suitable for NISQ devices.", "Context": "Given a unitary matrix $U$ and one of its eigenstates, the corresponding eigenvalue should be determined. The eigenstate $\\newcommand{\\state}[1]{{\\left| #1 \\right>}}\\state{v}$ is given on a register in [Basis Encoding](#/patterns/0). Applying $U$ to the eigenstate $\\newcommand{\\state}[1]{{\\left| #1 \\right>}}\\state{v}$ results in a global phase: \n$$U\\newcommand{\\state}[1]{{\\left| #1 \\right>}}\\state{v} = e^{2\\pi i \\varphi} \\state{v}$$\nwhere the eigenvalue $\\lambda = e^{2\\pi i \\varphi}$ is uniquely determined by $\\varphi \\in [0,1]$. Therefore, it is sufficient to estimate $\\varphi$.", "Solution": "Use the circuit shown in the pattern sketch to estimate the approximation of $\\theta$. First, a register of $m$ ancillae is brought into an [Uniform Superposition](#/patterns/16). Next, controlled versions of powers of $U$ are applied on the register of the eigenstate following the scheme depicted inthe pattern sketch. Each application of a controlled-$U$ operation results in a _phase kickback_ of the control qubit, i.e., this qubit acquires a relative phase of $\\varphi$. This results in the overall state:\n$$\\newcommand{\\state}[1]{{\\left| #1 \\right>}} \\state{\\psi} = \n    \\sum_{y=0}^{2^m-1}e^{2\\pi \\varphi y}\\state{y}$$\n where $\\varphi$ is encoded in the relative phase. \nTo extract this information, the inverse of the quantum fourier transformation is applied on the ancilla register. ", "Variants": "The second register can also be initialized as an arbitrary quantum state which is always a linear combination of eigenvectors. In this case, the algorithm approximates a superposition of eigenvalues for these eigenvectors in the output register. Other variants of this algorithm further improve the depth of the circuit or require fewer measurements. ", "Known Uses": "_Quantum Phase Estimation_ is at the heart of many algorithms [[Cleve et al. 1998](https://royalsocietypublishing.org/doi/abs/10.1098/rspa.1998.0164)]. One prominent example which we review in a later section is the HHL algorithm [[Harrow, Hassidim and Lloyd 2009](https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.103.150502)]. Other QML algorithms follow a similar scheme [[Schuld and Petruccione 2018](http://dx.doi.org/10.1007/978-3-319-96424-9), [Duan et al. 2020](https://www.sciencedirect.com/science/article/abs/pii/S037596012030462X)], e.g., quantum support vector machine (QSVM) [[Rebentrost et al. 2014](https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.113.130503)] or quantum principal component analysis (QPCA) [[Lloyd et al. 2014](https://www.nature.com/articles/nphys3029)]. [Qiskit]( https://qiskit.org/documentation/stubs/qiskit.circuit.library.PhaseEstimation.html) provides an implementation for this pattern.\n\n[Shor''s Algorithm (PlanQK)](https://platform.planqk.de/algorithms/e7413acf-c25e-4de8-ab78-75bfc836a839/)\n[HHL Algorithm (PlanQK)](https://platform.planqk.de/algorithms/8c6909bd-a258-4702-8356-6ef28321a826/)", "Related Patterns": "This pattern uses [Amplitude Encoding](#/patterns/2) and [Matrix Encoding](#/patterns/11) and produces an output in [Basis Encoding](#/patterns/0)."}', 'af7780d5-1f97-4536-8da7-4194b093ab1d', 'Weigold, M., et al.: Encoding patterns for quantum algorithms. IET Quant. Comm. 1–12 (2021). https://doi.org/10.1049/qtc2.12032', false, false, 'algorithm');
INSERT INTO public.pattern (id, name, uri, content, icon_url, rendered_content, pattern_language_id, paper_ref, deployment_modeling_behavior_pattern, deployment_modeling_structure_pattern, tags) VALUES ('d9c57511-1101-4707-99bf-36f43a12cb13', 'Quantum Random Access Memory (QRAM) Encoding', 'https://patternpedia.org/patternLanguages/reformulatedQuantumComputingPatterns/quantumRandomAccessMemory(qram)Encoding', '{"Alias": "Enter your input for this section here.", "Intent": " \"Use a quantum random access memory to access a superposition of data values at once\" [(Weigold et al. 2021)](https://ieeexplore.ieee.org/document/9425837/)\n\n", "Result": "To apply this encoding, $l$ qubits are needed to represent the data values in [Basis Encoding](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/bcd4c7a1-3c92-4f8c-a530-72b8b95d3750). \nFor the address register, additionally $\\lceil log(n) \\rceil$ qubits are needed containing up to $n$ addresses. \nSince \\textsc{Basis Encoding} is used to represent the data values, the computational properties are similar to other digital encodings (e.g., [Quantum Associative Memory (QuAM)](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/482714a7-8409-4165-93fe-72b02c2ae99c) and [Basis Encoding](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/bcd4c7a1-3c92-4f8c-a530-72b8b95d3750)): \nSince a set of data values is represented in superposition, the data values can be manipulated at once (using quantum parallelism). \nFurthermore, multiple arithmetic operations (e.g., addition or multiplication) for [Basis Encoding](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/bcd4c7a1-3c92-4f8c-a530-72b8b95d3750) are known that can also be applied to values in superposition.\n \n\nNote that algorithms that specify the usage of a QRAM share the following assumption: \nState preparation via the QRAM is efficient and, therefore, of logarithmic runtime [(Schuld and Petruccione 2018)](https://www.springer.com/gp/book/9783319964232). \nHowever, to our best knowledge, there are currently no commercial hardware implementations for QRAM.\nThus, a different state preparation routine has to load the data in the specified encoding. \nA major disadvantage today is that currently no state preparation routine for an arbitrary state is known to be as efficient as the logarithmic runtime of a QRAM. \nAs a result, a theoretically exponential speed-up of an algorithm using QRAM is only possible if the state preparation can be realized by an efficient state preparation method. \n\n", "Context": "For accessing the values of input data, a random access memory is needed.\n\n", "Solution": "When a classical random access memory (RAM) gets an address to a memory index, it transfers the data value stored at this address into a specified output register. \nThe functionality of quantum random access memory (QRAM) is similar, however, the registers are not classical but quantum registers [(Johnston, Harrigan and Gimeno-Segovia 2019)](https://www.oreilly.com/library/view/programming-quantum-computers/9781492039679/). \nConsequently, the address and output registers can be in  superposition instead of only single values.\nThe solution sketch demonstrates the loading process of a QRAM [(Giovannetti, Lloyd and Maccone 2008)](https://arxiv.org/abs/0708.1879) holding a superposition of the first two addresses ($\\newcommand{\\state}[1]{{\\left| #1 \\right>}} \\frac{1}{\\sqrt{2}}\\state{00} + \\frac{1}{\\sqrt{2}}\\state{01})$ as input register. \nLoading the data values of the corresponding addresses results in the following state:\n\n\n$$\n\\newcommand{\\colVec}[1]{% inline column vector\n\\bigl( \\begin{smallmatrix}#1\\end{smallmatrix}\\bigr)\n}\n\\newcommand{\\bigColVec}[1]{% inline column vector\n\\left( \\begin{matrix}#1\\end{matrix}\\right)\n}\n\\newcommand{\\state}[1]{{\\left| #1 \\right>}}\\state{\\psi} = \\frac{1}{\\sqrt{2}} \\state{00}\\state{010} + \\frac{1}{\\sqrt{2}}\\state{01}\\state{110}\n$$  \n\n\nLoading $m$ of $n$ data values using a QRAM can be generalized as follows [(Schuld and Petruccione 2018)](https://www.springer.com/gp/book/9783319964232): \n\n\n$$\n\\newcommand{\\colVec}[1]{% inline column vector\n\\bigl( \\begin{smallmatrix}#1\\end{smallmatrix}\\bigr)\n}\n\\newcommand{\\bigColVec}[1]{% inline column vector\n\\left( \\begin{matrix}#1\\end{matrix}\\right)\n}\n\\newcommand{\\state}[1]{{\\left| #1 \\right>}}\n  \\frac{1}{\\sqrt{m}}\\sum_{i=0}^{m-1}\n    \\state{a}_i\\state{0} \\ \\underrightarrow{QRAM}  \\frac{1}{\\sqrt{m}}\\sum_{i=0}^{m-1}\n \\state{a}_i\\state{x_a}\n $$  \n\n\nThereby,  the  first register specifies the  address  register  containing a  superposition  of $m$ addresses, and the second register is specified as output register.\nFurthermore, $\\newcommand{\\state}[1]{{\\left| #1 \\right>}} \\state{a}_i$ denotes the $i$-th data value address which has to be loaded \nand $x_a$ is the data value stored at this address.\nThe task of the QRAM is to load each data value $\\newcommand{\\state}[1]{{\\left| #1 \\right>}} \\state{x_a}$ of the addresses in the first register to the output register. \nConsequently, $\\newcommand{\\state}[1]{{\\left| #1 \\right>}} \\state{a}_i\\state{x_a}$ is part of the combined output state of both registers.\nIn dependence of the address values and their corresponding data values, this could create entanglement.\n\n![](https://quantumcomputingpatterns.org/assets/sketches/qram_solution.png)\n\nPattern sketch, taken from: Weigold, Manuela; Barzen, Johanna; Leymann, Frank; Salm, Marie: [“Expanding Data Encoding Patterns For Quantum Algorithms.”](https://ieeexplore.ieee.org/document/9425837/) In: 2021 IEEE 18th International Conference on Software Architecture Companion (ICSA-C), IEEE, 2021.", "Variants": "Enter your input for this section here.", "Known Uses": "An alternative state preparation to realize [Quantum Random Access Memory (QRAM) Encoding](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/d9c57511-1101-4707-99bf-36f43a12cb13) can be found in [(Cortese and Braje 2018)](https://arxiv.org/abs/1803.01958) (circuit family \\#3) or [(Prakash 2014)](https://www2.eecs.berkeley.edu/Pubs/TechRpts/2014/EECS-2014-211.pdf).\nAlgorithms for solving semi-definite programs [(Mitarai, Kitagawa and Fujii 2019)](http://arxiv.org/pdf/1805.11250v2)  use [Quantum Random Access Memory (QRAM) Encoding](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/d9c57511-1101-4707-99bf-36f43a12cb13). \nA QRAM is required or assumed in various other algorithms [(Giovannetti, Lloyd and Maccone 2008)](https://arxiv.org/abs/0708.1879), [(Rebentrost, Mohseni and Lloyd 2014)](http://www.ncbi.nlm.nih.gov/pubmed/25302877) , [(Wiebe, Kapoor and Svore 2014)](https://arxiv.org/abs/1412.3489), [(Lloyd, Mohseni and Rebentrost 2013)](https://arxiv.org/abs/1307.0401). \nA prominent example of an algorithm that uses this encoding is the HHL algorithm for solving linear equations [(Harrow, Hassidim and Lloyd 2009)](https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.103.150502) which uses [Quantum Random Access Memory (QRAM) Encoding](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/d9c57511-1101-4707-99bf-36f43a12cb13) as an intermediate representation for eigenvalues [(Mitarai, Kitagawa and Fujii 2019)](http://arxiv.org/pdf/1805.11250v2).  \n\n[HHL Algorithm (PlanQK)](https://platform.planqk.de/algorithms/8c6909bd-a258-4702-8356-6ef28321a826/)\n", "Related Patterns": "This pattern is a refinement of [Initialization](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/312bc9d3-26c0-40ae-b90b-56effd136c0d) which makes use of [Basis Encoding](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/bcd4c7a1-3c92-4f8c-a530-72b8b95d3750). Since the address and output register of QRAM Encoding may be entangled, [Creating Entanglement](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/3d1f3991-df47-4d42-8f9a-e6dcf4e3ccec) can be realized with this pattern."}', 'https://quantumcomputingpatterns.org/assets/pattern-icons/qram_icon.png', '{"Alias": "Enter your input for this section here.", "Intent": " \"Use a quantum random access memory to access a superposition of data values at once\" [(Weigold et al. 2021)](https://ieeexplore.ieee.org/document/9425837/)\n\n", "Result": "To apply this encoding, $l$ qubits are needed to represent the data values in [Basis Encoding](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/bcd4c7a1-3c92-4f8c-a530-72b8b95d3750). \nFor the address register, additionally $\\lceil log(n) \\rceil$ qubits are needed containing up to $n$ addresses. \nSince \\textsc{Basis Encoding} is used to represent the data values, the computational properties are similar to other digital encodings (e.g., [Quantum Associative Memory (QuAM)](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/482714a7-8409-4165-93fe-72b02c2ae99c) and [Basis Encoding](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/bcd4c7a1-3c92-4f8c-a530-72b8b95d3750)): \nSince a set of data values is represented in superposition, the data values can be manipulated at once (using quantum parallelism). \nFurthermore, multiple arithmetic operations (e.g., addition or multiplication) for [Basis Encoding](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/bcd4c7a1-3c92-4f8c-a530-72b8b95d3750) are known that can also be applied to values in superposition.\n \n\nNote that algorithms that specify the usage of a QRAM share the following assumption: \nState preparation via the QRAM is efficient and, therefore, of logarithmic runtime [(Schuld and Petruccione 2018)](https://www.springer.com/gp/book/9783319964232). \nHowever, to our best knowledge, there are currently no commercial hardware implementations for QRAM.\nThus, a different state preparation routine has to load the data in the specified encoding. \nA major disadvantage today is that currently no state preparation routine for an arbitrary state is known to be as efficient as the logarithmic runtime of a QRAM. \nAs a result, a theoretically exponential speed-up of an algorithm using QRAM is only possible if the state preparation can be realized by an efficient state preparation method. \n\n", "Context": "For accessing the values of input data, a random access memory is needed.\n\n", "Solution": "When a classical random access memory (RAM) gets an address to a memory index, it transfers the data value stored at this address into a specified output register. \nThe functionality of quantum random access memory (QRAM) is similar, however, the registers are not classical but quantum registers [(Johnston, Harrigan and Gimeno-Segovia 2019)](https://www.oreilly.com/library/view/programming-quantum-computers/9781492039679/). \nConsequently, the address and output registers can be in  superposition instead of only single values.\nThe solution sketch demonstrates the loading process of a QRAM [(Giovannetti, Lloyd and Maccone 2008)](https://arxiv.org/abs/0708.1879) holding a superposition of the first two addresses ($\\newcommand{\\state}[1]{{\\left| #1 \\right>}} \\frac{1}{\\sqrt{2}}\\state{00} + \\frac{1}{\\sqrt{2}}\\state{01})$ as input register. \nLoading the data values of the corresponding addresses results in the following state:\n\n\n$$\n\\newcommand{\\colVec}[1]{% inline column vector\n\\bigl( \\begin{smallmatrix}#1\\end{smallmatrix}\\bigr)\n}\n\\newcommand{\\bigColVec}[1]{% inline column vector\n\\left( \\begin{matrix}#1\\end{matrix}\\right)\n}\n\\newcommand{\\state}[1]{{\\left| #1 \\right>}}\\state{\\psi} = \\frac{1}{\\sqrt{2}} \\state{00}\\state{010} + \\frac{1}{\\sqrt{2}}\\state{01}\\state{110}\n$$  \n\n\nLoading $m$ of $n$ data values using a QRAM can be generalized as follows [(Schuld and Petruccione 2018)](https://www.springer.com/gp/book/9783319964232): \n\n\n$$\n\\newcommand{\\colVec}[1]{% inline column vector\n\\bigl( \\begin{smallmatrix}#1\\end{smallmatrix}\\bigr)\n}\n\\newcommand{\\bigColVec}[1]{% inline column vector\n\\left( \\begin{matrix}#1\\end{matrix}\\right)\n}\n\\newcommand{\\state}[1]{{\\left| #1 \\right>}}\n  \\frac{1}{\\sqrt{m}}\\sum_{i=0}^{m-1}\n    \\state{a}_i\\state{0} \\ \\underrightarrow{QRAM}  \\frac{1}{\\sqrt{m}}\\sum_{i=0}^{m-1}\n \\state{a}_i\\state{x_a}\n $$  \n\n\nThereby,  the  first register specifies the  address  register  containing a  superposition  of $m$ addresses, and the second register is specified as output register.\nFurthermore, $\\newcommand{\\state}[1]{{\\left| #1 \\right>}} \\state{a}_i$ denotes the $i$-th data value address which has to be loaded \nand $x_a$ is the data value stored at this address.\nThe task of the QRAM is to load each data value $\\newcommand{\\state}[1]{{\\left| #1 \\right>}} \\state{x_a}$ of the addresses in the first register to the output register. \nConsequently, $\\newcommand{\\state}[1]{{\\left| #1 \\right>}} \\state{a}_i\\state{x_a}$ is part of the combined output state of both registers.\nIn dependence of the address values and their corresponding data values, this could create entanglement.\n\n![](https://quantumcomputingpatterns.org/assets/sketches/qram_solution.png)\n\nPattern sketch, taken from: Weigold, Manuela; Barzen, Johanna; Leymann, Frank; Salm, Marie: [“Expanding Data Encoding Patterns For Quantum Algorithms.”](https://ieeexplore.ieee.org/document/9425837/) In: 2021 IEEE 18th International Conference on Software Architecture Companion (ICSA-C), IEEE, 2021.", "Variants": "Enter your input for this section here.", "Known Uses": "An alternative state preparation to realize [Quantum Random Access Memory (QRAM) Encoding](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/d9c57511-1101-4707-99bf-36f43a12cb13) can be found in [(Cortese and Braje 2018)](https://arxiv.org/abs/1803.01958) (circuit family \\#3) or [(Prakash 2014)](https://www2.eecs.berkeley.edu/Pubs/TechRpts/2014/EECS-2014-211.pdf).\nAlgorithms for solving semi-definite programs [(Mitarai, Kitagawa and Fujii 2019)](http://arxiv.org/pdf/1805.11250v2)  use [Quantum Random Access Memory (QRAM) Encoding](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/d9c57511-1101-4707-99bf-36f43a12cb13). \nA QRAM is required or assumed in various other algorithms [(Giovannetti, Lloyd and Maccone 2008)](https://arxiv.org/abs/0708.1879), [(Rebentrost, Mohseni and Lloyd 2014)](http://www.ncbi.nlm.nih.gov/pubmed/25302877) , [(Wiebe, Kapoor and Svore 2014)](https://arxiv.org/abs/1412.3489), [(Lloyd, Mohseni and Rebentrost 2013)](https://arxiv.org/abs/1307.0401). \nA prominent example of an algorithm that uses this encoding is the HHL algorithm for solving linear equations [(Harrow, Hassidim and Lloyd 2009)](https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.103.150502) which uses [Quantum Random Access Memory (QRAM) Encoding](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/d9c57511-1101-4707-99bf-36f43a12cb13) as an intermediate representation for eigenvalues [(Mitarai, Kitagawa and Fujii 2019)](http://arxiv.org/pdf/1805.11250v2).  \n\n[HHL Algorithm (PlanQK)](https://platform.planqk.de/algorithms/8c6909bd-a258-4702-8356-6ef28321a826/)\n", "Related Patterns": "This pattern is a refinement of [Initialization](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/312bc9d3-26c0-40ae-b90b-56effd136c0d) which makes use of [Basis Encoding](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/bcd4c7a1-3c92-4f8c-a530-72b8b95d3750). Since the address and output register of QRAM Encoding may be entangled, [Creating Entanglement](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/3d1f3991-df47-4d42-8f9a-e6dcf4e3ccec) can be realized with this pattern."}', 'af7780d5-1f97-4536-8da7-4194b093ab1d', 'https://ieeexplore.ieee.org/document/9425837/', false, false, 'encoding');
INSERT INTO public.pattern (id, name, uri, content, icon_url, rendered_content, pattern_language_id, paper_ref, deployment_modeling_behavior_pattern, deployment_modeling_structure_pattern, tags) VALUES ('ddd64fb6-b324-45eb-8e21-8193dc311841', 'Speedup via Verifying', 'https://patternpedia.org/patternLanguages/reformulatedQuantumComputingPatterns/speedupViaVerifying', '{"Alias": "", "Intent": "Achieve a computational speedup on computation when verification of a solution is simple.", "Result": "This pattern requires that an oracle is given which can verify the solutions.\n\n", "Context": "There are many problems for which finding a solution is hard, but for an alleged solution it is easy to verify whether it is correct. \nFor example, determining the factorization of a certain number is hard when the number is huge, but multiplying prime numbers to verify that their product equals the number is simple.\nThus, to check if a list of prime numbers is the factorization of a specific number, multiplying the prime numbers is sufficient to verify the factorization. \n\n", "Solution": "For certain problems, finding a solution can be done faster by exploiting quantum parallelism:\nFirst, all possible solutions are created, then this list of solutions is searched for correct solutions by verifying the correctness of each solution. \nThe Grover algorithm is used for searching through the possible solutions relying on an oracle to verify whether the possible solutions are correct.\nThis means that $O(\\sqrt{N})$ applications of the oracle are needed to determine the solution. \n\n", "Variants": "", "Known Uses": "This technique can be applied for e.g., cracking keys, finding Hamiltonian cycles,  solving 3-SAT, or the traveling salesman problem.\n\n[Grover''s Algorithm (PlanQK)](https://platform.planqk.de/algorithms/86dfd279-db46-4adb-84a7-39bcf1d19d3a/)\n[Dürr-Høyer Quantum Minimization Algorithm (PlanQK)](https://platform.planqk.de/algorithms/061f4eb3-d9ee-4f47-befc-9e242bf801ce/)\n", "Related Patterns": "An [Oracle](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/1cc7e9d6-ab37-412e-8afa-604a25de296e) is used to verify solutions.\nThe Grover algorithm used for the scanning increases the probability to measure a correct solution via [Amplitude Amplification](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/96b4d28a-a5ce-4c96-85df-d42587b13c57). \n\n"}', 'https://quantumcomputingpatterns.org/assets/pattern-icons/speedup_by_verification_icon.png', '{"Alias": "", "Intent": "Achieve a computational speedup on computation when verification of a solution is simple.", "Result": "This pattern requires that an oracle is given which can verify the solutions.\n\n", "Context": "There are many problems for which finding a solution is hard, but for an alleged solution it is easy to verify whether it is correct. \nFor example, determining the factorization of a certain number is hard when the number is huge, but multiplying prime numbers to verify that their product equals the number is simple.\nThus, to check if a list of prime numbers is the factorization of a specific number, multiplying the prime numbers is sufficient to verify the factorization. \n\n", "Solution": "For certain problems, finding a solution can be done faster by exploiting quantum parallelism:\nFirst, all possible solutions are created, then this list of solutions is searched for correct solutions by verifying the correctness of each solution. \nThe Grover algorithm is used for searching through the possible solutions relying on an oracle to verify whether the possible solutions are correct.\nThis means that $O(\\sqrt{N})$ applications of the oracle are needed to determine the solution. \n\n", "Variants": "", "Known Uses": "This technique can be applied for e.g., cracking keys, finding Hamiltonian cycles,  solving 3-SAT, or the traveling salesman problem.\n\n[Grover''s Algorithm (PlanQK)](https://platform.planqk.de/algorithms/86dfd279-db46-4adb-84a7-39bcf1d19d3a/)\n[Dürr-Høyer Quantum Minimization Algorithm (PlanQK)](https://platform.planqk.de/algorithms/061f4eb3-d9ee-4f47-befc-9e242bf801ce/)\n", "Related Patterns": "An [Oracle](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/1cc7e9d6-ab37-412e-8afa-604a25de296e) is used to verify solutions.\nThe Grover algorithm used for the scanning increases the probability to measure a correct solution via [Amplitude Amplification](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/96b4d28a-a5ce-4c96-85df-d42587b13c57). \n\n"}', 'af7780d5-1f97-4536-8da7-4194b093ab1d', 'https://link.springer.com/chapter/10.1007/978-3-030-14082-3_19', false, false, 'circuit-level');
INSERT INTO public.pattern (id, name, uri, content, icon_url, rendered_content, pattern_language_id, paper_ref, deployment_modeling_behavior_pattern, deployment_modeling_structure_pattern, tags) VALUES ('5850c6ab-5c87-4331-8439-73692a403228', 'Standalone Circuit Execution', 'https://patternpedia.org/patternLanguages/quantumAlgorithmPatterns/standaloneCircuitExecution', '{"Alias": "–", "Forces": "Quantum offerings vary in features and capabilities. Use of advanced offerings for simple use cases may incur unnecessary management overhead and even block the task due to lacking technical expertise, e.g., deployment automation and integration technologies. In contrast, certain quantum offerings reduce the amount of required management efforts, e.g., by generating execution requests automatically.", "Intent": "How to execute standalone quantum circuits that impose no deployment or integration requirements?", "Result": "Quantum offerings supporting this pattern provide a simple way for executing quantum circuits. However, classical pre- and post-processing steps can not be defined using these offerings. Thus, this style of execution is not suitable for running larger quantum applications and integration with external applications is either very limited or not supported at all. Additionally, running computations with this pattern cannot take advantage of prioritized executions.", "Context": "In some scenarios, only standalone quantum circuits need to be executed, such as circuit design and testing or education. Thereby, it is beneficial to execute quantum circuits with minimal effort and required knowledge about different quantum offerings as well as deployment or integration technologies.", "Examples": "–", "Solution": "Execute quantum circuits via quantum offerings that do not require implementing custom deployment logic or integration with other services. Figure 2 shows the solution sketch in which distinct quantum circuits are executed using offerings capable of creating and executing circuits. This includes dedicated graphical circuit composers or text-based tools transmitting the quantum circuits to the offering. Typically, providers are responsible for the majority of the management efforts, e.g., deployment of circuits and authentication to the underlying quantum offering.\n\n![Solution Sketch for Standalone Circuit Execution](https://raw.githubusercontent.com/PatternAtlas/pattern-atlas-content/main/sketches/quantum_computing_patterns/ad-hoc-circuit.svg)", "Known Uses": "Vendors such as IBM [[IBM, 2023b]](https://quantum-computing.ibm.com/lab/docs/iql/) or Pasqal [[Pasqal, 2023]](https://pasqal.io ) support this pattern via graphical circuit composer services that enable modeling quantum circuits visually and executing them from the GUI, hence, abstracting away the authentication and construction of the invocation request.", "Related Pattern": "In scenarios when quantum circuits are executed for testing purposes and afterwards require the integration with classical pre- and post-processing steps, the AD-HOC HYBRID CODE EXECUTION can be used. Additionally, different quantum computing patterns can be used while modeling quantum circuits, e.g., AMPLITUDE AMPLIFICATION or UNIFORM SUPERPOSITION [[Leymann, 2019]](https://link.springer.com/chapter/10.1007/978-3-030-14082-3_19)."}', 'https://raw.githubusercontent.com/PatternAtlas/pattern-atlas-content/main/icons/quantum_computing_patterns/ad-hoc-circuit-thin.svg', '{"Alias": "–", "Forces": "Quantum offerings vary in features and capabilities. Use of advanced offerings for simple use cases may incur unnecessary management overhead and even block the task due to lacking technical expertise, e.g., deployment automation and integration technologies. In contrast, certain quantum offerings reduce the amount of required management efforts, e.g., by generating execution requests automatically.", "Intent": "How to execute standalone quantum circuits that impose no deployment or integration requirements?", "Result": "Quantum offerings supporting this pattern provide a simple way for executing quantum circuits. However, classical pre- and post-processing steps can not be defined using these offerings. Thus, this style of execution is not suitable for running larger quantum applications and integration with external applications is either very limited or not supported at all. Additionally, running computations with this pattern cannot take advantage of prioritized executions.", "Context": "In some scenarios, only standalone quantum circuits need to be executed, such as circuit design and testing or education. Thereby, it is beneficial to execute quantum circuits with minimal effort and required knowledge about different quantum offerings as well as deployment or integration technologies.", "Examples": "–", "Solution": "Execute quantum circuits via quantum offerings that do not require implementing custom deployment logic or integration with other services. Figure 2 shows the solution sketch in which distinct quantum circuits are executed using offerings capable of creating and executing circuits. This includes dedicated graphical circuit composers or text-based tools transmitting the quantum circuits to the offering. Typically, providers are responsible for the majority of the management efforts, e.g., deployment of circuits and authentication to the underlying quantum offering.\n\n![Solution Sketch for Standalone Circuit Execution](https://raw.githubusercontent.com/PatternAtlas/pattern-atlas-content/main/sketches/quantum_computing_patterns/ad-hoc-circuit.svg)", "Known Uses": "Vendors such as IBM [[IBM, 2023b]](https://quantum-computing.ibm.com/lab/docs/iql/) or Pasqal [[Pasqal, 2023]](https://pasqal.io ) support this pattern via graphical circuit composer services that enable modeling quantum circuits visually and executing them from the GUI, hence, abstracting away the authentication and construction of the invocation request.", "Related Pattern": "In scenarios when quantum circuits are executed for testing purposes and afterwards require the integration with classical pre- and post-processing steps, the AD-HOC HYBRID CODE EXECUTION can be used. Additionally, different quantum computing patterns can be used while modeling quantum circuits, e.g., AMPLITUDE AMPLIFICATION or UNIFORM SUPERPOSITION [[Leymann, 2019]](https://link.springer.com/chapter/10.1007/978-3-030-14082-3_19)."}', 'af7780d5-1f97-4536-8da7-4194b093ab1d', 'https://www.scitepress.org/Link.aspx?doi=10.5220/0012057700003538', NULL, NULL, 'design');
INSERT INTO public.pattern (id, name, uri, content, icon_url, rendered_content, pattern_language_id, paper_ref, deployment_modeling_behavior_pattern, deployment_modeling_structure_pattern, tags) VALUES ('bc795a9b-7977-4e01-b513-f9f5aba38aa7', 'Variational Quantum Algorithm (VQA)', 'https://patternpedia.org/patternLanguages/reformulatedQuantumComputingPatterns/variationalQuantumAlgorithm(vqa)', '{"Alias": "", "Intent": "\"Optimize the parameters of a quantum circuit on a classical computer\" [(Weigold et al. 2021)](https://www.springer.com/de/book/9783030648459)\n\n", "Result": "However, choosing $f$, the observables for measuring the qubits and an ansatz is not trivial.\nThe convergence of the algorithm depends on multiple factors: the objective function and the optimization strategy for updating the parameters. \nRegarding the objective function, one major obstacle for the convergence of the solution are regions of the function which contain only a small norm of the gradient (these regions are also referred to as *barren plateaus*). \nThese regions can significantly influence how fast the solution converges [(Cerezo et al. 2020)](https://arxiv.org/abs/2012.09265) or in the worst case, result in non-convergence of the algorithm. \nSince the optimization procedure is performed classically, the classical computation can impact the overall runtime. \n\n", "Context": "The best solution for a problem must be found or approximated across all possible solutions. \nAn individual solution can be evaluated by an objective function $C$ that is also given.  \nBy definition, this function is *faithful*, i.e, its minimum value indicates the best solution [(Cerezo et al. 2020)](https://arxiv.org/abs/2012.09265). \nPreferably, $C$ is also *operationally meaningful* which means that solutions can be compared: smaller values of $C$ also indicate better solutions. \nSince the number of possible solutions increases exponentially with the size of the problems, it is too expensive in terms of computations to evaluate all possible solutions. \n\n", "Solution": "A hybrid setup is used to evaluate and optimize solutions. \nOn the quantum computer, an initial state is created that may also encode or be varied according to a set of input data $x$ (refer to the quantum circuit in the upper part of the solution sketch). \nOn this state, an ansatz $U(\\theta)$ is applied which is a circuit that depends on a set of parameters $\\theta$. \nThis results in the  $\\newcommand{\\state}[1]{{\\left| #1 \\right>}} \\state{\\psi_{out}(x,\\theta)}$ state. \nA canonical example of an ansatz is to apply multiple one-qubit operations defining a rotation in the Bloch Sphere around a rotation angle that depends on $\\theta$.\nHowever, plenty of other parameterized circuits have been proposed as an ansatz. \nThen, based on the expectation values of the output state $\\newcommand{\\state}[1]{{\\left| #1 \\right>}} \\state{\\psi_{out}(x,\\theta)}$, the objective function $C$ for the parameter values $\\theta$ is calculated by the classical computer: \n\n\n$$\n\\newcommand{\\state}[1]{{\\left| #1 \\right>}}\nC(\\theta)=\\sum_i f_i(\\left<O_i\\right>_{\\state{\\psi_{out}(x,\\theta)}})\n$$  \n\n\nwhere $O_i$ is the observable and $\\newcommand{\\state}[1]{{\\left| #1 \\right>}} \\left<O_i\\right>_{\\state{\\psi_{out}(x,\\theta)}}$ the expectation value of the $i$-th measurement to which the function $f$ assigns an overall cost.\nIf $C(\\theta)$ is sufficiently low, i.e., the termination criteria are fulfilled, the algorithm ends. \nOtherwise, the parameter set $\\theta$ is optimized further for the next iteration. \n\n![](https://quantumcomputingpatterns.org/assets/sketches/variational_solution.png)\n\nPattern sketch, taken from: Weigold, Manuela; Barzen, Johanna; Leymann, Frank; and Vietz, Daniel: [Patterns For Hybrid Quantum Algorithms.](https://doi.org/10.1007/978-3-030-87568-8_2) In: Proceedings of the 15th Symposium and Summer School on Service-Oriented Computing (SummerSOC 2021).", "Variants": "", "Known Uses": "A plethora of algorithms make use of this pattern, e.g., in quantum machine learning this technique was used for developing quantum classifiers [(Mitarai et al. 2018)](https://arxiv.org/abs/1803.00745v3), \nas well as a quantum version of neural networks [(Farhi and Neven 2018)](https://arxiv.org/abs/1802.06002) or support vector machine [(Havlíček et al. 2019)](https://www.nature.com/articles/s41586-019-0980-2), [(Schuld and Killoran 2019)](https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.122.040504). \nA variational algorithm for factorization has been presented in [(Anschuetz et al. 2018)](https://arxiv.org/abs/1808.08927). \n\n[Quantum approximate optimization algorithm (PlanQK)](https://platform.planqk.de/algorithms/fae60bca-d2b6-4aa2-88b7-58caace34179/)\n[Variational Quantum Eigensolver (PlanQK)](https://platform.planqk.de/algorithms/28fbfa6b-329b-4d99-8c75-f9dbdd365a4f/)\n[Hybrid Transfer Learning (PlanQK)](https://platform.planqk.de/algorithms/2803f6d4-094e-4aa9-b09d-5847fba03d21/)\n[Quantum Boltzmann Machine (Gate-based) (PlanQK)](https://platform.planqk.de/algorithms/ae9bac80-672e-432a-983f-a3a7e1a8c92c/)", "Related Patterns": "This pattern is a refinement of [Quantum-Classic Split](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/dd15032b-ce2b-40b6-80ac-97623255b531) [(Leymann 2019)](https://www.iaas.uni-stuttgart.de/publications/INPROC-2019-05-Towards_a_Pattern_Language_for_Quantum_Algorithms.pdf). \nWithin the quantum computation, [Initialization](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/312bc9d3-26c0-40ae-b90b-56effd136c0d) [(Leymann 2019)](https://www.iaas.uni-stuttgart.de/publications/INPROC-2019-05-Towards_a_Pattern_Language_for_Quantum_Algorithms.pdf) is used.  \n \n"}', 'https://quantumcomputingpatterns.org/assets/pattern-icons/vqa_icon.png', '{"Alias": "", "Intent": "\"Optimize the parameters of a quantum circuit on a classical computer\" [(Weigold et al. 2021)](https://www.springer.com/de/book/9783030648459)\n\n", "Result": "However, choosing $f$, the observables for measuring the qubits and an ansatz is not trivial.\nThe convergence of the algorithm depends on multiple factors: the objective function and the optimization strategy for updating the parameters. \nRegarding the objective function, one major obstacle for the convergence of the solution are regions of the function which contain only a small norm of the gradient (these regions are also referred to as *barren plateaus*). \nThese regions can significantly influence how fast the solution converges [(Cerezo et al. 2020)](https://arxiv.org/abs/2012.09265) or in the worst case, result in non-convergence of the algorithm. \nSince the optimization procedure is performed classically, the classical computation can impact the overall runtime. \n\n", "Context": "The best solution for a problem must be found or approximated across all possible solutions. \nAn individual solution can be evaluated by an objective function $C$ that is also given.  \nBy definition, this function is *faithful*, i.e, its minimum value indicates the best solution [(Cerezo et al. 2020)](https://arxiv.org/abs/2012.09265). \nPreferably, $C$ is also *operationally meaningful* which means that solutions can be compared: smaller values of $C$ also indicate better solutions. \nSince the number of possible solutions increases exponentially with the size of the problems, it is too expensive in terms of computations to evaluate all possible solutions. \n\n", "Solution": "A hybrid setup is used to evaluate and optimize solutions. \nOn the quantum computer, an initial state is created that may also encode or be varied according to a set of input data $x$ (refer to the quantum circuit in the upper part of the solution sketch). \nOn this state, an ansatz $U(\\theta)$ is applied which is a circuit that depends on a set of parameters $\\theta$. \nThis results in the  $\\newcommand{\\state}[1]{{\\left| #1 \\right>}} \\state{\\psi_{out}(x,\\theta)}$ state. \nA canonical example of an ansatz is to apply multiple one-qubit operations defining a rotation in the Bloch Sphere around a rotation angle that depends on $\\theta$.\nHowever, plenty of other parameterized circuits have been proposed as an ansatz. \nThen, based on the expectation values of the output state $\\newcommand{\\state}[1]{{\\left| #1 \\right>}} \\state{\\psi_{out}(x,\\theta)}$, the objective function $C$ for the parameter values $\\theta$ is calculated by the classical computer: \n\n\n$$\n\\newcommand{\\state}[1]{{\\left| #1 \\right>}}\nC(\\theta)=\\sum_i f_i(\\left<O_i\\right>_{\\state{\\psi_{out}(x,\\theta)}})\n$$  \n\n\nwhere $O_i$ is the observable and $\\newcommand{\\state}[1]{{\\left| #1 \\right>}} \\left<O_i\\right>_{\\state{\\psi_{out}(x,\\theta)}}$ the expectation value of the $i$-th measurement to which the function $f$ assigns an overall cost.\nIf $C(\\theta)$ is sufficiently low, i.e., the termination criteria are fulfilled, the algorithm ends. \nOtherwise, the parameter set $\\theta$ is optimized further for the next iteration. \n\n![](https://quantumcomputingpatterns.org/assets/sketches/variational_solution.png)\n\nPattern sketch, taken from: Weigold, Manuela; Barzen, Johanna; Leymann, Frank; and Vietz, Daniel: [Patterns For Hybrid Quantum Algorithms.](https://doi.org/10.1007/978-3-030-87568-8_2) In: Proceedings of the 15th Symposium and Summer School on Service-Oriented Computing (SummerSOC 2021).", "Variants": "", "Known Uses": "A plethora of algorithms make use of this pattern, e.g., in quantum machine learning this technique was used for developing quantum classifiers [(Mitarai et al. 2018)](https://arxiv.org/abs/1803.00745v3), \nas well as a quantum version of neural networks [(Farhi and Neven 2018)](https://arxiv.org/abs/1802.06002) or support vector machine [(Havlíček et al. 2019)](https://www.nature.com/articles/s41586-019-0980-2), [(Schuld and Killoran 2019)](https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.122.040504). \nA variational algorithm for factorization has been presented in [(Anschuetz et al. 2018)](https://arxiv.org/abs/1808.08927). \n\n[Quantum approximate optimization algorithm (PlanQK)](https://platform.planqk.de/algorithms/fae60bca-d2b6-4aa2-88b7-58caace34179/)\n[Variational Quantum Eigensolver (PlanQK)](https://platform.planqk.de/algorithms/28fbfa6b-329b-4d99-8c75-f9dbdd365a4f/)\n[Hybrid Transfer Learning (PlanQK)](https://platform.planqk.de/algorithms/2803f6d4-094e-4aa9-b09d-5847fba03d21/)\n[Quantum Boltzmann Machine (Gate-based) (PlanQK)](https://platform.planqk.de/algorithms/ae9bac80-672e-432a-983f-a3a7e1a8c92c/)", "Related Patterns": "This pattern is a refinement of [Quantum-Classic Split](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/dd15032b-ce2b-40b6-80ac-97623255b531) [(Leymann 2019)](https://www.iaas.uni-stuttgart.de/publications/INPROC-2019-05-Towards_a_Pattern_Language_for_Quantum_Algorithms.pdf). \nWithin the quantum computation, [Initialization](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/312bc9d3-26c0-40ae-b90b-56effd136c0d) [(Leymann 2019)](https://www.iaas.uni-stuttgart.de/publications/INPROC-2019-05-Towards_a_Pattern_Language_for_Quantum_Algorithms.pdf) is used.  \n \n"}', 'af7780d5-1f97-4536-8da7-4194b093ab1d', 'Weigold, M.; Barzen, J.; Leymann, F.; and Vietz, D: Patterns For Hybrid Quantum Algorithms. In: Proceedings of the 15th Symposium and Summer School on Service-Oriented Computing (SummerSOC 2021), https://doi.org/10.1007/978-3-030-87568-8_2', false, false, 'algorithm');
INSERT INTO public.pattern (id, name, uri, content, icon_url, rendered_content, pattern_language_id, paper_ref, deployment_modeling_behavior_pattern, deployment_modeling_structure_pattern, tags) VALUES ('27a5d147-a323-4c6a-84ef-45d80cae923d', 'Variational Quantum Eigensolver (VQE)', 'https://patternpedia.org/patternLanguages/reformulatedQuantumComputingPatterns/variationalQuantumEigensolver(vqe)', '{"Alias": "An alias for this pattern is Quantum Variational Eigensolver (QVE) [(Mitarai et al. 2018)](https://arxiv.org/abs/1803.00745v3).\n", "Intent": "\"Approximate the lowest eigenvalue of a matrix\" [(Weigold et al. 2021)](https://www.springer.com/de/book/9783030648459)", "Result": "Since a [Variational Quantum Algorithm (VQA)](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/bc795a9b-7977-4e01-b513-f9f5aba38aa7) approach is used, the convergence of the overall algorithm depends on the objective function, the ansatz, and the chosen optimization strategy. \nBased on the outcome of this algorithm (an approximation of the lowest eigenvalue), a follow-up algorithm for finding other eigenvalues of $H$ can be applied (see known uses).\nIf all eigenvalues are known, a principal component analysis can be done to perform a dimension reduction. \n\n", "Context": "A hermitian matrix $H$ is given, for which the lowest eigenvalue has to be determined.\nSince the current NISQ devices cannot provide the resources needed to make use of the quantum phase estimation algorithm, an alternative approach must be used. \n\n", "Solution": "As a first step, $H$ is re-written as a weighted sum of Pauli strings: \n\n\n$$\n    H=\\sum_{\\alpha} h_\\alpha P_\\alpha\n$$  \n\n\nUsing the iterative structure of the  [Variational Quantum Algorithm (VQA)](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/bc795a9b-7977-4e01-b513-f9f5aba38aa7), a suitable ansatz is chosen for the preparation of trial states. \nPopular choices include the unitary coupled cluster ansatz [(Taube and Bartlett 2006)](https://onlinelibrary.wiley.com/doi/10.1002/qua.21198) or an ansatz inspired by hardware [(Cerezo et al. 2020)](https://arxiv.org/abs/2012.09265). \nThe objective function is then defined as follows:\n\n\n$$C(\\theta) = \\left<\\psi(\\theta)|H|\\psi(\\theta) \\right> = \\sum_{\\alpha} h_\\alpha \\left< \\psi(\\theta)|P_\\alpha|\\psi(\\theta) \\right>$$\n\n\ni.e., the solution is evaluated by the sum of the expectation values of the Pauli string. \nThe variational principle guarantees that the sum of expectation values is greater than or equal to the smallest eigenvalue which must be approximated. \nIf the termination condition has not been fulfilled by $C(\\theta)$, the parameters are further optimized and updated as described in the [Variational Quantum Algorithm (VQA)](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/bc795a9b-7977-4e01-b513-f9f5aba38aa7). \n\n", "Variants": "", "Known Uses": "[Higgott, Wang and Brierley 2019](https://quantum-journal.org/papers/q-2019-07-01-156/) extends the initial description of this algorithm [Peruzzo et al. 2014](https://www.nature.com/articles/ncomms5213) by an approach for finding other eigenvalues of $H$. \nThis pattern is especially important for applications in which the ground state of a quantum chemical system has to be determined and has been experimentally applied for various quantum chemistry systems [Cao et al. 2019](https://pubs.acs.org/doi/10.1021/acs.chemrev.8b00803). \n\n[Variational Quantum Eigensolver (PlanQK)](https://platform.planqk.de/algorithms/28fbfa6b-329b-4d99-8c75-f9dbdd365a4f/)", "Related Patterns": "This patterns uses the structure described in the [Variational Quantum Algorithm (VQA)](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/bc795a9b-7977-4e01-b513-f9f5aba38aa7). \n\n"}', 'https://quantumcomputingpatterns.org/assets/pattern-icons/vqe_icon.png', '{"Alias": "An alias for this pattern is Quantum Variational Eigensolver (QVE) [(Mitarai et al. 2018)](https://arxiv.org/abs/1803.00745v3).\n", "Intent": "\"Approximate the lowest eigenvalue of a matrix\" [(Weigold et al. 2021)](https://www.springer.com/de/book/9783030648459)", "Result": "Since a [Variational Quantum Algorithm (VQA)](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/bc795a9b-7977-4e01-b513-f9f5aba38aa7) approach is used, the convergence of the overall algorithm depends on the objective function, the ansatz, and the chosen optimization strategy. \nBased on the outcome of this algorithm (an approximation of the lowest eigenvalue), a follow-up algorithm for finding other eigenvalues of $H$ can be applied (see known uses).\nIf all eigenvalues are known, a principal component analysis can be done to perform a dimension reduction. \n\n", "Context": "A hermitian matrix $H$ is given, for which the lowest eigenvalue has to be determined.\nSince the current NISQ devices cannot provide the resources needed to make use of the quantum phase estimation algorithm, an alternative approach must be used. \n\n", "Solution": "As a first step, $H$ is re-written as a weighted sum of Pauli strings: \n\n\n$$\n    H=\\sum_{\\alpha} h_\\alpha P_\\alpha\n$$  \n\n\nUsing the iterative structure of the  [Variational Quantum Algorithm (VQA)](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/bc795a9b-7977-4e01-b513-f9f5aba38aa7), a suitable ansatz is chosen for the preparation of trial states. \nPopular choices include the unitary coupled cluster ansatz [(Taube and Bartlett 2006)](https://onlinelibrary.wiley.com/doi/10.1002/qua.21198) or an ansatz inspired by hardware [(Cerezo et al. 2020)](https://arxiv.org/abs/2012.09265). \nThe objective function is then defined as follows:\n\n\n$$C(\\theta) = \\left<\\psi(\\theta)|H|\\psi(\\theta) \\right> = \\sum_{\\alpha} h_\\alpha \\left< \\psi(\\theta)|P_\\alpha|\\psi(\\theta) \\right>$$\n\n\ni.e., the solution is evaluated by the sum of the expectation values of the Pauli string. \nThe variational principle guarantees that the sum of expectation values is greater than or equal to the smallest eigenvalue which must be approximated. \nIf the termination condition has not been fulfilled by $C(\\theta)$, the parameters are further optimized and updated as described in the [Variational Quantum Algorithm (VQA)](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/bc795a9b-7977-4e01-b513-f9f5aba38aa7). \n\n", "Variants": "", "Known Uses": "[Higgott, Wang and Brierley 2019](https://quantum-journal.org/papers/q-2019-07-01-156/) extends the initial description of this algorithm [Peruzzo et al. 2014](https://www.nature.com/articles/ncomms5213) by an approach for finding other eigenvalues of $H$. \nThis pattern is especially important for applications in which the ground state of a quantum chemical system has to be determined and has been experimentally applied for various quantum chemistry systems [Cao et al. 2019](https://pubs.acs.org/doi/10.1021/acs.chemrev.8b00803). \n\n[Variational Quantum Eigensolver (PlanQK)](https://platform.planqk.de/algorithms/28fbfa6b-329b-4d99-8c75-f9dbdd365a4f/)", "Related Patterns": "This patterns uses the structure described in the [Variational Quantum Algorithm (VQA)](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/bc795a9b-7977-4e01-b513-f9f5aba38aa7). \n\n"}', 'af7780d5-1f97-4536-8da7-4194b093ab1d', 'Weigold, M.; Barzen, J.; Leymann, F.; and Vietz, D: Patterns For Hybrid Quantum Algorithms. In: Proceedings of the 15th Symposium and Summer School on Service-Oriented Computing (SummerSOC 2021), https://doi.org/10.1007/978-3-030-87568-8_2', false, false, 'algorithm');
INSERT INTO public.pattern (id, name, uri, content, icon_url, rendered_content, pattern_language_id, paper_ref, deployment_modeling_behavior_pattern, deployment_modeling_structure_pattern, tags) VALUES ('3ea9e187-e91b-4852-84eb-b35b5c480892', 'Warm Start', 'https://patternpedia.org/patternLanguages/reformulatedQuantumComputingPatterns/warmStart', '{"Alias": "", "Intent": " \"Fine-tune an optimization algorithm by warm starting it\" [(Weigold et al. 2021)](https://www.springer.com/de/book/9783030648459)", "Result": "Using the warm starting approach, a proceeding optimization is initialized with the classical approximation result which should be nearer to the optimum than a random starting point. \nThe warm starting procedure should also be taken into account for the overall runtime complexity. \n\n", "Context": "The best solution for an optimization problem must be found or approximated. \nFor classical methods, the *Unique Game Conjecture* (UGC) states that there is a theoretical upper bound for the approximation ratio which can not be further improved.\nThis implies that classical methods can only approximate up to this bound, i.e., up to a certain extent. \nHowever, since the UGC is not true when entanglement is used, quantum algorithms have the potential to surpass these bounds, i.e., they can approximate better solutions than classical algorithms. \n\n", "Solution": "Start by using a classical approach to approximate the best solution. \nThe classical approximation result can often be found as a solution for a related problem, e.g., by weakening or eliminating constraints of the problem.  \n\n", "Variants": "", "Known Uses": "Warm starting was shown to be beneficial for the MaxCut problem [Tate et al. 2020](https://www.researchgate.net/publication/344911160_Bridging_Classical_and_Quantum_with_SDP_initialized_warm-starts_for_QAOA) and another optimization use case [Egger, Marecek and Woerner 2020](https://arxiv.org/abs/2009.10095).\nThe approach presented in [Barkoutsos 2018](https://arxiv.org/abs/1805.04340) can also be regarded as a warm start for [Variational Quantum Eigensolver (VQE)](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/27a5d147-a323-4c6a-84ef-45d80cae923d) [Egger, Marecek and Woerner 2020](https://arxiv.org/abs/2009.10095).\n\n[Quantum approximate optimization algorithm (PlanQK)](https://platform.planqk.de/algorithms/fae60bca-d2b6-4aa2-88b7-58caace34179/)\n[Hybrid Transfer Learning (PlanQK)](https://platform.planqk.de/algorithms/2803f6d4-094e-4aa9-b09d-5847fba03d21/)", "Related Patterns": "Warm start can be used to provide initial starting solutions for [Quantum Approximate Optimization Algorithm (QAOA)](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/da93f915-7f4c-49df-99d0-80d91f26a337) or [Variational Quantum Eigensolver (VQE)](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/27a5d147-a323-4c6a-84ef-45d80cae923d). \n\n"}', 'https://quantumcomputingpatterns.org/assets/pattern-icons/warmstart_icon.png', '{"Alias": "", "Intent": " \"Fine-tune an optimization algorithm by warm starting it\" [(Weigold et al. 2021)](https://www.springer.com/de/book/9783030648459)", "Result": "Using the warm starting approach, a proceeding optimization is initialized with the classical approximation result which should be nearer to the optimum than a random starting point. \nThe warm starting procedure should also be taken into account for the overall runtime complexity. \n\n", "Context": "The best solution for an optimization problem must be found or approximated. \nFor classical methods, the *Unique Game Conjecture* (UGC) states that there is a theoretical upper bound for the approximation ratio which can not be further improved.\nThis implies that classical methods can only approximate up to this bound, i.e., up to a certain extent. \nHowever, since the UGC is not true when entanglement is used, quantum algorithms have the potential to surpass these bounds, i.e., they can approximate better solutions than classical algorithms. \n\n", "Solution": "Start by using a classical approach to approximate the best solution. \nThe classical approximation result can often be found as a solution for a related problem, e.g., by weakening or eliminating constraints of the problem.  \n\n", "Variants": "", "Known Uses": "Warm starting was shown to be beneficial for the MaxCut problem [Tate et al. 2020](https://www.researchgate.net/publication/344911160_Bridging_Classical_and_Quantum_with_SDP_initialized_warm-starts_for_QAOA) and another optimization use case [Egger, Marecek and Woerner 2020](https://arxiv.org/abs/2009.10095).\nThe approach presented in [Barkoutsos 2018](https://arxiv.org/abs/1805.04340) can also be regarded as a warm start for [Variational Quantum Eigensolver (VQE)](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/27a5d147-a323-4c6a-84ef-45d80cae923d) [Egger, Marecek and Woerner 2020](https://arxiv.org/abs/2009.10095).\n\n[Quantum approximate optimization algorithm (PlanQK)](https://platform.planqk.de/algorithms/fae60bca-d2b6-4aa2-88b7-58caace34179/)\n[Hybrid Transfer Learning (PlanQK)](https://platform.planqk.de/algorithms/2803f6d4-094e-4aa9-b09d-5847fba03d21/)", "Related Patterns": "Warm start can be used to provide initial starting solutions for [Quantum Approximate Optimization Algorithm (QAOA)](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/da93f915-7f4c-49df-99d0-80d91f26a337) or [Variational Quantum Eigensolver (VQE)](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/27a5d147-a323-4c6a-84ef-45d80cae923d). \n\n"}', 'af7780d5-1f97-4536-8da7-4194b093ab1d', 'Weigold, M.; Barzen, J.; Leymann, F.; and Vietz, D: Patterns For Hybrid Quantum Algorithms. In: Proceedings of the 15th Symposium and Summer School on Service-Oriented Computing (SummerSOC 2021), https://doi.org/10.1007/978-3-030-87568-8_2', false, false, 'augmentation');
INSERT INTO public.pattern (id, name, uri, content, icon_url, rendered_content, pattern_language_id, paper_ref, deployment_modeling_behavior_pattern, deployment_modeling_structure_pattern, tags) VALUES ('3d9bca6e-5fca-40c5-b005-8a794958f3aa', 'Circuit Cutting', 'https://patternpedia.org/patternLanguages/quantumAlgorithmPatterns/circuitCutting', '{"Alias": "Enter your input for this section here.", "Forces": "Enter your input for this section here.", "Intent": "Enter your input for this section here.", "Result": "Enter your input for this section here.", "Context": "Enter your input for this section here.", "Examples": "Enter your input for this section here.", "Solution": "Enter your input for this section here.", "Known Uses": "Enter your input for this section here.", "Related Pattern": "Enter your input for this section here."}', 'https://raw.githubusercontent.com/PatternAtlas/pattern-atlas-content/main/icons/quantum_computing_patterns/circuit-cutting-icon-thin.svg', '{"Alias": "Enter your input for this section here.", "Forces": "Enter your input for this section here.", "Intent": "Enter your input for this section here.", "Result": "Enter your input for this section here.", "Context": "Enter your input for this section here.", "Examples": "Enter your input for this section here.", "Solution": "Enter your input for this section here.", "Known Uses": "Enter your input for this section here.", "Related Pattern": "Enter your input for this section here."}', 'af7780d5-1f97-4536-8da7-4194b093ab1d', NULL, NULL, NULL, NULL);
INSERT INTO public.pattern (id, name, uri, content, icon_url, rendered_content, pattern_language_id, paper_ref, deployment_modeling_behavior_pattern, deployment_modeling_structure_pattern, tags) VALUES ('28c99b35-98ce-4bfe-bb6d-94a65207258a', 'Wire Cut', 'https://patternpedia.org/patternLanguages/quantumAlgorithmPatterns/wireCut', '{"Alias": "Enter your input for this section here.", "Forces": "Enter your input for this section here.", "Intent": "Enter your input for this section here.", "Result": "Enter your input for this section here.", "Context": "Enter your input for this section here.", "Examples": "Enter your input for this section here.", "Solution": "Enter your input for this section here.", "Known Uses": "Enter your input for this section here.", "Related Pattern": "Enter your input for this section here."}', 'https://raw.githubusercontent.com/PatternAtlas/pattern-atlas-content/main/icons/quantum_computing_patterns/wire-cut-icon-thin.svg', '{"Alias": "Enter your input for this section here.", "Forces": "Enter your input for this section here.", "Intent": "Enter your input for this section here.", "Result": "Enter your input for this section here.", "Context": "Enter your input for this section here.", "Examples": "Enter your input for this section here.", "Solution": "Enter your input for this section here.", "Known Uses": "Enter your input for this section here.", "Related Pattern": "Enter your input for this section here."}', 'af7780d5-1f97-4536-8da7-4194b093ab1d', NULL, NULL, NULL, NULL);
INSERT INTO public.pattern (id, name, uri, content, icon_url, rendered_content, pattern_language_id, paper_ref, deployment_modeling_behavior_pattern, deployment_modeling_structure_pattern, tags) VALUES ('7821a1f9-02a0-4833-a048-3bf184b1c6fe', 'Gate Cut', 'https://patternpedia.org/patternLanguages/quantumAlgorithmPatterns/gateCut', '{"Alias": "Enter your input for this section here.", "Forces": "Enter your input for this section here.", "Intent": "Enter your input for this section here.", "Result": "Enter your input for this section here.", "Context": "Enter your input for this section here.", "Examples": "Enter your input for this section here.", "Solution": "Enter your input for this section here.", "Known Uses": "Enter your input for this section here.", "Related Pattern": "Enter your input for this section here."}', 'https://raw.githubusercontent.com/PatternAtlas/pattern-atlas-content/main/icons/quantum_computing_patterns/gate-cut-icon-thin.svg', '{"Alias": "Enter your input for this section here.", "Forces": "Enter your input for this section here.", "Intent": "Enter your input for this section here.", "Result": "Enter your input for this section here.", "Context": "Enter your input for this section here.", "Examples": "Enter your input for this section here.", "Solution": "Enter your input for this section here.", "Known Uses": "Enter your input for this section here.", "Related Pattern": "Enter your input for this section here."}', 'af7780d5-1f97-4536-8da7-4194b093ab1d', NULL, NULL, NULL, NULL);


--
-- TOC entry 3344 (class 0 OID 16549)
-- Dependencies: 240
-- Data for Name: pattern_relation_type; Type: TABLE DATA; Schema: public; Owner: planqk
--



--
-- TOC entry 3343 (class 0 OID 16543)
-- Dependencies: 239
-- Data for Name: pattern_relation; Type: TABLE DATA; Schema: public; Owner: planqk
--



--
-- TOC entry 3347 (class 0 OID 16561)
-- Dependencies: 243
-- Data for Name: publication_authors; Type: TABLE DATA; Schema: public; Owner: planqk
--

INSERT INTO public.publication_authors (publication_id, authors) VALUES ('f05c9136-2f9f-433f-9c35-85009111ee3c', 'Peter W. Shor');
INSERT INTO public.publication_authors (publication_id, authors) VALUES ('87d697a4-6256-4f84-b545-c2024ab380c2', 'Daoyl Dong');
INSERT INTO public.publication_authors (publication_id, authors) VALUES ('87d697a4-6256-4f84-b545-c2024ab380c2', 'Chunlin Chen');
INSERT INTO public.publication_authors (publication_id, authors) VALUES ('87d697a4-6256-4f84-b545-c2024ab380c2', 'Hanxiong Li');
INSERT INTO public.publication_authors (publication_id, authors) VALUES ('87d697a4-6256-4f84-b545-c2024ab380c2', 'Tzyh-Jong Tarn');
INSERT INTO public.publication_authors (publication_id, authors) VALUES ('3aac6a37-10de-4a95-a2bd-381d357df2a4', 'Vojtech Havlicek');
INSERT INTO public.publication_authors (publication_id, authors) VALUES ('3aac6a37-10de-4a95-a2bd-381d357df2a4', 'Antionio D. Córcoles');
INSERT INTO public.publication_authors (publication_id, authors) VALUES ('3aac6a37-10de-4a95-a2bd-381d357df2a4', 'Kristian Temme');
INSERT INTO public.publication_authors (publication_id, authors) VALUES ('3aac6a37-10de-4a95-a2bd-381d357df2a4', 'Aram W. Harrow');
INSERT INTO public.publication_authors (publication_id, authors) VALUES ('3aac6a37-10de-4a95-a2bd-381d357df2a4', 'Abhinav Kandala');
INSERT INTO public.publication_authors (publication_id, authors) VALUES ('3aac6a37-10de-4a95-a2bd-381d357df2a4', 'Jerry M. Chow');
INSERT INTO public.publication_authors (publication_id, authors) VALUES ('3aac6a37-10de-4a95-a2bd-381d357df2a4', 'Jay M. Gambetta');
INSERT INTO public.publication_authors (publication_id, authors) VALUES ('ae6bdf6f-2656-45bd-9b96-0820eea3cdab', 'Dennis Willsch');
INSERT INTO public.publication_authors (publication_id, authors) VALUES ('ae6bdf6f-2656-45bd-9b96-0820eea3cdab', 'Madita Willsch');
INSERT INTO public.publication_authors (publication_id, authors) VALUES ('ae6bdf6f-2656-45bd-9b96-0820eea3cdab', 'Hans De Raedt');
INSERT INTO public.publication_authors (publication_id, authors) VALUES ('ae6bdf6f-2656-45bd-9b96-0820eea3cdab', 'Kristel Michielsen');


--
-- TOC entry 3348 (class 0 OID 16564)
-- Dependencies: 244
-- Data for Name: quantum_algorithm; Type: TABLE DATA; Schema: public; Owner: planqk
--

INSERT INTO public.quantum_algorithm (nisq_ready, quantum_computation_model, speed_up, id) VALUES (false, 0, NULL, '9829e814-a707-479f-80c7-8b49ffa543bc');
INSERT INTO public.quantum_algorithm (nisq_ready, quantum_computation_model, speed_up, id) VALUES (false, 0, NULL, '52ae7837-58e1-47b2-bda3-4134597ef138');


--
-- TOC entry 3349 (class 0 OID 16567)
-- Dependencies: 245
-- Data for Name: quantum_algorithm_revisions; Type: TABLE DATA; Schema: public; Owner: planqk
--

INSERT INTO public.quantum_algorithm_revisions (id, rev, nisq_ready, quantum_computation_model, speed_up) VALUES ('9829e814-a707-479f-80c7-8b49ffa543bc', 6, false, 0, NULL);
INSERT INTO public.quantum_algorithm_revisions (id, rev, nisq_ready, quantum_computation_model, speed_up) VALUES ('52ae7837-58e1-47b2-bda3-4134597ef138', 7, false, 0, NULL);


--
-- TOC entry 3350 (class 0 OID 16570)
-- Dependencies: 246
-- Data for Name: quantum_implementation; Type: TABLE DATA; Schema: public; Owner: planqk
--



--
-- TOC entry 3351 (class 0 OID 16573)
-- Dependencies: 247
-- Data for Name: quantum_implementation_revisions; Type: TABLE DATA; Schema: public; Owner: planqk
--



--
-- TOC entry 3355 (class 0 OID 16591)
-- Dependencies: 251
-- Data for Name: software_platform_cloud_services; Type: TABLE DATA; Schema: public; Owner: planqk
--



--
-- TOC entry 3356 (class 0 OID 16594)
-- Dependencies: 252
-- Data for Name: software_platforms_compute_resources; Type: TABLE DATA; Schema: public; Owner: planqk
--



--
-- TOC entry 3358 (class 0 OID 16603)
-- Dependencies: 254
-- Data for Name: tosca_application; Type: TABLE DATA; Schema: public; Owner: planqk
--



--
-- TOC entry 3359 (class 0 OID 16609)
-- Dependencies: 255
-- Data for Name: tosca_application_revisions; Type: TABLE DATA; Schema: public; Owner: planqk
--



--
-- TOC entry 3365 (class 0 OID 0)
-- Dependencies: 226
-- Name: hibernate_sequence; Type: SEQUENCE SET; Schema: public; Owner: planqk
--

SELECT pg_catalog.setval('public.hibernate_sequence', 7, true);


-- Completed on 2023-11-07 14:57:53 CET

--
-- PostgreSQL database dump complete
--

